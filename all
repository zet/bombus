/*
 * ArchiveList.java
 *
 * Created on 11 Ltrf,hm 2005 пїЅ., 5:24
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package archive;

import Client.Msg;
import Client.Title;
import Messages.MessageList;
import java.util.Vector;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.TextBox;
import locale.SR;
import ui.ComplexString;

/**
 *
 * @author EvgS
 */
public class ArchiveList 
    extends MessageList 
{

    Command cmdDelete=new Command(SR.MS_DELETE /*"Delete"*/, Command.SCREEN, 9);
    Command cmdPaste=new Command(SR.MS_PASTE_BODY /*"Paste Body"*/, Command.SCREEN, 1);
    Command cmdSubj=new Command(SR.MS_PASTE_SUBJECT /*"Paste Subject"*/, Command.SCREEN, 3);
    Command cmdJid=new Command(SR.MS_PASTE_JID /*"Paste Jid"*/, Command.SCREEN, 2);
    //Command cmdNick=new Command("Paste Nickname", Command.SCREEN, 3);
    
    MessageArchive archive=new MessageArchive();
    TextBox target;
    /** Creates a new instance of ArchiveList */
    public ArchiveList(Display display, TextBox target) {
	super ();
	this.target=target;
	setCommandListener(this);
	addCommand(cmdBack);
	addCommand(cmdDelete);
	
	if (target!=null) {
	    addCommand(cmdPaste);
	    addCommand(cmdJid);
	}
        
        attachDisplay(display);
        
        
        try {
            focusedItem(0);
        } catch (Exception e) {}
	
	Title title=new Title(SR.MS_ARCHIVE /*"Archive"*/);
	title.addElement(null);
	title.addRAlign();
	title.addElement(null);
	title.addElement(SR.MS_FREE /*"free "*/);
        setTitleItem(title);
        
    }

    protected void beginPaint() {
        getTitleItem().setElementAt(" ("+String.valueOf(getItemCount())+")",1);
	getTitleItem().setElementAt(String.valueOf(archive.freeSpace()),3);
    }
    
    public int getItemCount() {
	return archive.size();
    }
    
    public Msg getMessage(int index) {
	return archive.msg(index);
    }

    public void commandAction(Command c, Displayable d) {
        super.commandAction(c,d);
	if (c==cmdDelete) {
	    archive.delete(cursor);
	    messages=new Vector();
	    redraw();
	}
	if (c==cmdPaste) { pasteData(0); }
	if (c==cmdSubj) { pasteData(1); }
	if (c==cmdJid) { pasteData(2); }
    }
    
    private void pasteData(int field) {
	if (target==null) return;
	Msg m=getMessage(cursor);
	if (m==null) return;
	String data;
	switch (field) {
	case 1: 
	    data=m.subject;
	    break;
	case 2: 
	    data=m.from;
	    break;
	default:
	    data=m.getBody();
	}
	try {
	    int paste=target.getMaxSize()-target.size();
	    if (paste>data.length()) paste=data.length();
	    target.insert(data.substring(0,paste), target.size());
	} catch (Exception e) {
	    e.printStackTrace();
	}
	destroyView();
    }
    
    public void keyGreen() { pasteData(0); }
    
    public void focusedItem(int index) {
	if (target==null) return;
	try {
	    if (getMessage(index).subject!=null) {
		addCommand(cmdSubj);
		return;
	    }
	} catch (Exception e) { }
	removeCommand(cmdSubj);
    }
    
    public void destroyView(){
	super.destroyView();
	archive.close();
    }
}
/*
 * MessageArchive.java
 *
 * Created on 11 Декабрь 2005 г., 2:33
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package archive;

import Client.Msg;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Vector;
import javax.microedition.rms.RecordEnumeration;
import javax.microedition.rms.RecordStore;
import javax.microedition.rms.RecordStoreException;
import javax.microedition.rms.RecordStoreNotOpenException;

/**
 *
 * @author EvgS
 */
public class MessageArchive {
    
    RecordStore rs;
    Vector indexes;
    /** Creates a new instance of MessageArchive */
    public MessageArchive() {
	try {
	    rs=RecordStore.openRecordStore("archive", true);
	    int size=rs.getNumRecords();
	    indexes=new Vector(size);
	    RecordEnumeration re=rs.enumerateRecords(null, null, false);
	    
	    while (re.hasNextElement() ){
		indexes.addElement(new Integer(re.nextRecordId() ));
	    }
	    
	} catch (Exception e) { e.printStackTrace();}
    }

    /*public void importMessageArchive() {
	try {
	    rs=RecordStore.openRecordStore("archive", true);
	    int size=rs.getNumRecords();
	    indexes=new Vector(size);
	    RecordEnumeration re=rs.enumerateRecords(null, null, false);
	    
	    while (re.hasNextElement() ){
		indexes.addElement(new Integer(re.nextRecordId() ));
	    }
	    
	} catch (Exception e) { e.printStackTrace();}
    }*/

    public int size(){
	return indexes.size();
    }
    
    private int getRecordId(int index) {
	return ((Integer)indexes.elementAt(index)).intValue();
    }
    public Msg msg(int index){
	try {
	    ByteArrayInputStream bais=new ByteArrayInputStream(
		rs.getRecord(getRecordId(index))
	    );
	    DataInputStream dis=new DataInputStream(bais);
	    Msg msg=new Msg(dis);
            msg.itemCollapsed=true; 
	    dis.close();
	    return msg;
	} catch (Exception e) {}
	return null;
    }
    
    public void delete(int index) {
	try {
	    rs.deleteRecord(getRecordId(index));
	    indexes.removeElementAt(index);
	} catch (Exception e) {}
    }

    public int freeSpace(){
	try {
	    return rs.getSizeAvailable()/1024;
	} catch (Exception e) { }
	return 0;
    }
    
    public void close(){
	try {
	    rs.closeRecordStore();
	} catch (Exception e) { e.printStackTrace(); }
	rs=null;
    }
    public static void store(Msg msg) {
	try {
	    ByteArrayOutputStream bout = new ByteArrayOutputStream();
	    DataOutputStream dout = new DataOutputStream( bout );
	    msg.serialize( dout );
	    dout.close();
	    byte b[]=bout.toByteArray();
	    
	    RecordStore rs=RecordStore.openRecordStore("archive", true);
	    rs.addRecord(b, 0, b.length);
	    rs.closeRecordStore();
	    //new MessageArchive()
	} catch (Exception e) { e.printStackTrace(); }
    }
}
/*
 * Account.java
 *
 * Created on 19 Март 2005 г., 21:52
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import com.alsutton.jabber.datablocks.Presence;
import images.RosterIcons;
import java.util.*;
import java.io.*;
import javax.microedition.midlet.MIDlet;
import midlet.Bombus;
import ui.Colors;
import ui.IconTextElement;
import ui.ImageList;
import javax.microedition.rms.*;
import javax.microedition.lcdui.*;
import Client.Roster;
import com.alsutton.jabber.*;

/**
 *
 * @author Eugene Stahov
 */
public class Account extends IconTextElement{
    
    public final static String storage="accnt_db";
            
    private String userName;
    private String password;
    private String server;
    private String hostAddr;
    private int port=5222;
    public boolean active;
    private boolean useSSL;
    private boolean sasl;
    private boolean plainAuth;
    private boolean mucOnly;
    
    private String nick="";
    private String resource="Bombus";
    
    private boolean enableProxy;
    private String proxyHostAddr;
    private int proxyPort;
    
    //private String jid;
        
    /** Creates a new instance of Account */
    public Account() {
        super(RosterIcons.getInstance());
    }
    
    public static Account loadAccount(boolean launch){
	StaticData sd=StaticData.getInstance();
	Account a=sd.account=Account.createFromStorage(Config.getInstance().accountIndex);
	if (a!=null) {
            sd.roster.logoff();
	    sd.roster.resetRoster();
	}
        if (a!=null && launch){
            sd.roster.logoff();
	    sd.roster.resetRoster();
            sd.roster.myStatus=Presence.PRESENCE_ONLINE;
            //sd.roster.querysign=true;
            new Thread(sd.roster).start();
        }
        return a;
    }

    public static Account createFromJad(){
        Account a=new Account();
        MIDlet m=Bombus.getInstance();
        try {
            a.userName=m.getAppProperty("def_user");
            a.password=m.getAppProperty("def_pass");
            a.server=m.getAppProperty("def_server");
            a.hostAddr=m.getAppProperty("def_ip");
        } catch (Exception e) { }
            if (a.server==null) return null;
        return a;
    }
    
    public static Account createFromDataInputStream(DataInputStream inputStream){
        
        int version=0;
        Account a=new Account();
        try {
            version    = inputStream.readByte();
            a.userName = inputStream.readUTF();
            a.password = inputStream.readUTF();
            a.server   = inputStream.readUTF();
            a.hostAddr = inputStream.readUTF();
            a.port     = inputStream.readInt();

            a.nick     = inputStream.readUTF();
            a.resource = inputStream.readUTF();
	    
            // version используется для корректной работы midp1 - аккаунты
            // хранятся в файле без разделения на записи
            if (version>=2) a.useSSL=inputStream.readBoolean();
            if (version>=3) a.plainAuth=inputStream.readBoolean();
            
	    if (version>=4) a.mucOnly=inputStream.readBoolean();
            
            if (version>=5) {
                a.setEnableProxy(inputStream.readBoolean());
                a.setProxyHostAddr(inputStream.readUTF());
                a.setProxyPort(inputStream.readInt());
            }
            
            if (version>=6) 
//#if SASL
                a.sasl=inputStream.readBoolean();
//#else
//#                 a.sasl=false; inputStream.readBoolean();
//#endif

        } catch (IOException e) { e.printStackTrace(); }
            
        return (a.userName==null)?null:a;
    }

    public String toString(){
        StringBuffer s=new StringBuffer();
        if (nick.length()!=0)
            s.append(nick);
        else {
            s.append(userName);
            s.append('@');
            s.append(server);
        }
        s.append('/');
        s.append(resource);
        return s.toString();
        //jid=userName+'@'+server+'/'+resource;
    }
    public String getJid(){
        return userName+'@'+server+'/'+resource;
    }
    /*public String getBareJid(){
        return userName+'@'+server;
    }*/
    
    public static Account createFromStorage(int index) {
        Account a=null;
        DataInputStream is=NvStorage.ReadFileRecord(storage, 0);
        if (is==null) return null;
        try {
            do {
                if (is.available()==0) {a=null; break;}
                a=createFromDataInputStream(is);
                //a.updateJidCache();
                index--;
            } while (index>-1);
            is.close();
        } catch (Exception e) { e.printStackTrace(); }
        return a;
    }
    
    public void saveToDataOutputStream(DataOutputStream outputStream){
        
        if (hostAddr==null) hostAddr="";
        if (proxyHostAddr==null) proxyHostAddr="";
        
        try {
            outputStream.writeByte(6);
            outputStream.writeUTF(userName);
            outputStream.writeUTF(password);
            outputStream.writeUTF(server);
            outputStream.writeUTF(hostAddr);
            outputStream.writeInt(port);
            
            outputStream.writeUTF(nick);
            outputStream.writeUTF(resource);

            outputStream.writeBoolean(useSSL);
            outputStream.writeBoolean(plainAuth);
	    
	    outputStream.writeBoolean(mucOnly);
            
            outputStream.writeBoolean(enableProxy);
            outputStream.writeUTF(proxyHostAddr);
            outputStream.writeInt(proxyPort);
            
            outputStream.writeBoolean(sasl);
	    
        } catch (IOException e) {
            e.printStackTrace();
        }
        
    }
    
    //public void onSelect(){ }
    //public String toString(){ return jid; }
    public int getColor(){ return Colors.LIST_INK; }
    
    protected int getImageIndex() {return active?0:5;}
    public void onSelect(){};

    public String getUserName() { return userName;  }
    public void setUserName(String userName) { this.userName = userName;  }

    public String getPassword() {  return password;  }
    public void setPassword(String password) { this.password = password;  }

    public String getServer() { return server; }
    public String getHostAddr() { return hostAddr; }
    
    public void setServer(String server) { this.server = server; }

    public void setHostAddr(String hostAddr) { this.hostAddr = hostAddr; }

    public int getPort() { return port; }
    public void setPort(int port) { this.port = port; }

    public boolean getUseSSL() { return useSSL; }
    public void setUseSSL(boolean ssl) { this.useSSL = ssl; }

    public boolean getPlainAuth() { return plainAuth; }
    public void setPlainAuth(boolean plain) { this.plainAuth = plain; }
    
    public String getResource() { return resource;  }
    public void setResource(String resource) { this.resource = resource;  }

    public String getNickName() { return (nick.length()==0)?getUserName():nick;  }
    public void setNickName(String nick) { this.nick = nick;  }

    boolean isMucOnly() { return mucOnly; }
    public void setMucOnly(boolean mucOnly) {  this.mucOnly = mucOnly; }

    public JabberStream openJabberStream() throws java.io.IOException{
        String proxy=null;
	StringBuffer url=new StringBuffer();
        if (hostAddr!=null) if (hostAddr.length()>0)
            url.append(hostAddr);
        else
            url.append(server);
        url.append(':');
        url.append(port);
        if (!isEnableProxy()) {
	    url.insert(0, (useSSL)?"ssl://":"socket://");
        } else {
            proxy="socket://" + getProxyHostAddr() + ':' + getProxyPort();
        }
        return new JabberStream(  getServer(), url.toString(), sasl, proxy, null);    
    }

    public boolean isEnableProxy() {
        return enableProxy;
    }

    public void setEnableProxy(boolean enableProxy) {
        this.enableProxy = enableProxy;
    }

    public String getProxyHostAddr() {
        return proxyHostAddr;
    }

    public void setProxyHostAddr(String proxyHostAddr) {
        this.proxyHostAddr = proxyHostAddr;
    }

    public int getProxyPort() {
        return proxyPort;
    }

    public void setProxyPort(int proxyPort) {
        this.proxyPort = proxyPort;
    }

    public boolean isSASL() {
        return sasl;
    }

    public void setSasl(boolean sasl) {
        this.sasl = sasl;
    }
}
/*
 * AccountForm.java
 *
 * Created on 20 Март 2005 г., 21:20
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import javax.microedition.lcdui.Choice;
import javax.microedition.lcdui.ChoiceGroup;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.Form;
import javax.microedition.lcdui.Item;
import javax.microedition.lcdui.ItemStateListener;
import javax.microedition.lcdui.TextField;
import locale.SR;
import ui.ConstMIDP;
import ui.controls.NumberField;

class AccountForm implements CommandListener, ItemStateListener {
    
    private final AccountSelect accountSelect;
    
    private Display display;
    private Displayable parentView;
    
    private Form f;
    private TextField userbox;
    private TextField passbox;
    private TextField servbox;
    private TextField ipbox;
    private NumberField portbox;
    private TextField resourcebox;
    private TextField nickbox;
    private TextField proxyHost;
    private NumberField proxyPort;
    private ChoiceGroup register;
    
    Command cmdOk = new Command(SR.MS_OK /*"OK"*/, Command.OK, 1);
    Command cmdPwd = new Command(SR.MS_SHOWPWD, Command.SCREEN, 2);
    Command cmdCancel = new Command(SR.MS_BACK /*"Back"*/, Command.BACK, 99);
    
    Account account;
    
    boolean newaccount;
    
    public AccountForm(AccountSelect accountSelect, Display display, Account account) {
	this.accountSelect = accountSelect;
	this.display=display;
	parentView=display.getCurrent();
	
	newaccount= account==null;
	if (newaccount) account=new Account();
	this.account=account;
	
	String title = (newaccount)?
	    SR.MS_NEW_ACCOUNT /*"New Account"*/:
	    (account.toString());
	f = new Form(title);
	userbox = new TextField(SR.MS_USERNAME, account.getUserName(), 32, TextField.URL); f.append(userbox);
	passbox = new TextField(SR.MS_PASSWORD, account.getPassword(), 32, TextField.PASSWORD);	f.append(passbox);
        passStars(false);
	servbox = new TextField(SR.MS_SERVER,   account.getServer(),   32, TextField.URL); f.append(servbox);
	ipbox = new TextField(SR.MS_HOST_IP, account.getHostAddr(), 32, TextField.URL);	f.append(ipbox);
	portbox = new NumberField(SR.MS_PORT, account.getPort(), 0, 65535); f.append(portbox);
	register = new ChoiceGroup(null, Choice.MULTIPLE);
	register.append(SR.MS_SSL,null);
	register.append(SR.MS_PLAIN_PWD,null);
	register.append(SR.MS_SASL,null);
	register.append(SR.MS_CONFERENCES_ONLY,null);
	register.append(SR.MS_PROXY_ENABLE,null);
	register.append(SR.MS_REGISTER_ACCOUNT,null);
	boolean b[] = {account.getUseSSL(), account.getPlainAuth(), account.isSASL(), account.isMucOnly(), account.isEnableProxy(), false};
	
	register.setSelectedFlags(b);
	f.append(register);
        
	proxyHost = new TextField(SR.MS_PROXY_HOST,   account.getProxyHostAddr(),   32, TextField.URL); f.append(proxyHost);
	proxyPort = new NumberField(SR.PROXY_PORT, account.getProxyPort(), 0, 65535);	f.append(proxyPort);
        
	resourcebox = new TextField(SR.MS_RESOURCE, account.getResource(), 32, TextField.ANY); f.append(resourcebox);
	nickbox = new TextField(SR.MS_ACCOUNT_NAME, account.getNickName(), 32, TextField.ANY); f.append(nickbox);
	
	f.addCommand(cmdOk);
        f.addCommand(cmdPwd);
	f.addCommand(cmdCancel);
	
	f.setCommandListener(this);
	f.setItemStateListener(this);
	
	display.setCurrent(f);
    }
    
    private void passStars(boolean force) {
	if (passbox.size()==0 || force)
	    passbox.setConstraints(TextField.ANY | ConstMIDP.TEXTFIELD_SENSITIVE);
        fixPassBugWEME();
    }
    
    private String fixPassBugWEME(){
        String newPass=passbox.getString();
        String oldPass=account.getPassword();
        
        if (oldPass!=null)
            if (oldPass.length()==newPass.length() && newPass.startsWith("**") && newPass.endsWith("**")) {
                newPass=oldPass;
                passbox.setString(oldPass);
            }
        return newPass;
    }
    
    public void itemStateChanged(Item item) {
	if (item==userbox) {
	    String user = userbox.getString();
	    int at = user.indexOf('@');
	    if (at==-1) return;
	    //userbox.setString(user.substring(0,at));
	    servbox.setString(user.substring(at+1));
	}
	if (item==passbox) passStars(false);
    }
    
    public void commandAction(Command c, Displayable d) {
	if (c==cmdCancel) {
	    destroyView();
	    return;
	}
	if (c==cmdOk) {
	    boolean b[] = new boolean[6];
	    register.getSelectedFlags(b);
	    String user = userbox.getString();
	    int at = user.indexOf('@');
	    if (at!=-1) user=user.substring(0, at);
	    account.setUserName(user.trim());
            
	    account.setPassword(fixPassBugWEME());
            
	    account.setServer(servbox.getString().trim());
	    account.setHostAddr(ipbox.getString());
	    account.setResource(resourcebox.getString());
	    account.setNickName(nickbox.getString());
	    account.setUseSSL(b[0]);
	    account.setPlainAuth(b[1]);
//#if SASL
            account.setSasl(b[2]);
//#endif
	    account.setMucOnly(b[3]);
	    account.setEnableProxy(b[4]);
	    //account.updateJidCache();
	    
	    account.setPort(portbox.getValue());

	    account.setProxyHostAddr(proxyHost.getString());
            account.setProxyPort(proxyPort.getValue());
	    
	    if (newaccount) accountSelect.accountList.addElement(account);
	    accountSelect.rmsUpdate();
	    accountSelect.commandState();
	    
	    if (b[5])
		new AccountRegister(account, display, parentView); 
	    else destroyView();
	}
        if (c==cmdPwd) passStars(true);
    }
    
    public void destroyView()	{
	if (display!=null)   display.setCurrent(parentView);
    }
}
/*
 * AccountRegister.java
 *
 * Created on 24 Апрель 2005 г., 2:36
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import com.alsutton.jabber.*;
import com.alsutton.jabber.datablocks.*;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.*;

/**
 *
 * @author Evg_S
 */
public class AccountRegister 
        implements         
            JabberListener,
            CommandListener,
            Runnable
{
    
    private Display display;
    private Displayable parentView;
    
    private Account raccount;
    private JabberStream theStream ;
    private SplashScreen spl=SplashScreen.getInstance();
    //private Command cmdOK=new Command("Cancel",Command.BACK, 2);
    private Command cmdCancel=new Command(SR.MS_CANCEL,Command.BACK, 2);
    
    /** Creates a new instance of AccountRegister */
    public AccountRegister(Account account, Display display, Displayable parentView) {
        this.display=display;
        this.parentView=parentView;//display.getCurrent();
        
        
        raccount=account;
        spl.setProgress(SR.MS_STARTUP,5);
        display.setCurrent(spl);
        spl.addCommand(cmdCancel);
        spl.setCommandListener(this);
        
        new Thread(this).start();
    }
    public void run() {
        try {
            spl.setProgress(SR.MS_CONNECT_TO +raccount.getServer(),30);
            theStream= raccount.openJabberStream();
            theStream.setJabberListener( this );
        } catch( Exception e ) {
            e.printStackTrace();
            spl.setFailed();
        }

    }
    
    public void rosterItemNotify(){}
    
    public void connectionTerminated( Exception e ) {
        //l.setTitleImgL(0);
        //System.out.println( "Connection terminated" );
        if( e != null ) {
            e.printStackTrace();
        }
    }

    public void beginConversation(String SessionId) {
        spl.setProgress(SR.MS_REGISTERING,60);
        IqRegister iq=new IqRegister(raccount.getUserName(),raccount.getPassword(), "regac");
        //try {
            theStream.send(iq);
        //} catch (Exception e) {e.printStackTrace();}
    }
    public void blockArrived( JabberDataBlock data ) {
        theStream.close();
        //destroyView();
        if (data instanceof Iq) {
            int pgs=100;
            String type=data.getTypeAttribute();
            String title=SR.MS_DONE; 
            if (!type.equals("result")) {
                pgs=0;
                title=SR.MS_ERROR_ +((JabberDataBlock)
                    data.getChildBlock("error").
                        getChildBlocks().
                        firstElement()).getTagName();
            }
            spl.setProgress(title,pgs);
        }
    }
    
    public void commandAction(Command c, Displayable d) {
        spl.setCommandListener(null);
        spl.removeCommand(cmdCancel);
        try {
            theStream.close();
        } catch (Exception e) { 
            e.printStackTrace();
        }
        destroyView();
    }
    
    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView);
    }

}
/*
 * AccountPicker.java
 *
 * Created on 19 Март 2005 г., 23:26
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import images.RosterIcons;
import locale.SR;
import midlet.Bombus;
import ui.*;
import java.io.*;
import java.util.*;
import javax.microedition.lcdui.*;
import ui.controls.NumberField;


/**
 *
 * @author Eugene Stahov
 */
public class AccountSelect 
        extends VirtualList 
        implements CommandListener{

    Vector accountList;
    int activeAccount;
    
    Command cmdLogin=new Command(SR.MS_SELLOGIN, Command.OK,1);
    Command cmdSelect=new Command(SR.MS_NOLOGIN, Command.SCREEN,2);
    Command cmdAdd=new Command(SR.MS_NEW_ACCOUNT, Command.SCREEN,3);
    Command cmdEdit=new Command(SR.MS_EDIT,Command.ITEM,3);
    Command cmdDel=new Command(SR.MS_DELETE,Command.ITEM,4);
    Command cmdCancel=new Command(SR.MS_BACK,Command.BACK,99);
    Command cmdQuit=new Command(SR.MS_APP_QUIT,Command.SCREEN,10);
    
    /** Creates a new instance of AccountPicker */
    public AccountSelect(Display display, boolean enableQuit) {
        super();
        //this.display=display;

        setTitleItem(new Title(SR.MS_ACCOUNTS));
        
        accountList=new Vector();
        Account a;
        
        int index=0;
        activeAccount=Config.getInstance().accountIndex;
        do {
            a=Account.createFromStorage(index);
            if (a!=null) {
                accountList.addElement(a);
                a.active=(activeAccount==index);
                index++;
             }
       } while (a!=null);
        if (accountList.isEmpty()) {
            a=Account.createFromJad();
            if (a!=null) {
                //a.updateJidCache();
                accountList.addElement(a);
                rmsUpdate();
            }
        }
        attachDisplay(display);
        addCommand(cmdAdd);
        
        if (enableQuit) addCommand(cmdQuit);
        
        commandState();
        setCommandListener(this);
    }
    
    void commandState(){
        if (accountList.isEmpty()) {
            removeCommand(cmdEdit);
            removeCommand(cmdDel);
            removeCommand(cmdSelect);
            removeCommand(cmdLogin);
            removeCommand(cmdCancel);
        } else {
            addCommand(cmdEdit);
            addCommand(cmdDel);
            addCommand(cmdLogin);
            addCommand(cmdSelect);
            if (activeAccount>=0)
                addCommand(cmdCancel);  // нельзя выйти без активного аккаунта
        }
    }

    public VirtualElement getItemRef(int Index) { return (VirtualElement)accountList.elementAt(Index); }
    protected int getItemCount() { return accountList.size();  }

    public void commandAction(Command c, Displayable d){
        if (c==cmdQuit) {
            destroyView();
            Bombus.getInstance().notifyDestroyed();
        }
        if (c==cmdCancel) {
            destroyView();
            //Account.launchAccount();
            //StaticData.getInstance().account_index=0;
        }
        if (c==cmdLogin) switchAccount(true);
        if (c==cmdSelect) switchAccount(false);
        if (c==cmdEdit) new AccountForm(this, display,(Account)getFocusedObject());
        if (c==cmdAdd) {
            new AccountForm(this, display, null);
        }
        if (c==cmdDel) {
            accountList.removeElement(getFocusedObject());
            rmsUpdate();
            moveCursorHome();
            commandState();
            redraw();
        }
        
    }
    
    private void switchAccount(boolean login){
        destroyView();
	Config cf=Config.getInstance();
        cf.accountIndex=cursor;
        cf.saveToStorage();
        Account.loadAccount(login);
    }
    
    public void eventOk(){ switchAccount(true); }
    
    void rmsUpdate(){
        DataOutputStream outputStream=NvStorage.CreateDataOutputStream();
        for (int i=0;i<accountList.size();i++) 
            ((Account)accountList.elementAt(i)).saveToDataOutputStream(outputStream);
        NvStorage.writeFileRecord(outputStream, Account.storage, 0, true);
    }

}
/*
 * ActiveContacts.java
 *
 * Created on 20 Январь 2005 г., 21:20
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */
 
package Client;

import java.util.Enumeration;
import java.util.Vector;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import locale.SR;
import ui.VirtualElement;
import ui.VirtualList;

/**
 *
 * @author EvgS
 */
public class ActiveContacts 
    extends VirtualList
    implements CommandListener
{
    
    Vector activeContacts;
    
    private Command cmdCancel=new Command(SR.MS_CANCEL, Command.BACK, 99);
    private Command cmdSelect=new Command(SR.MS_SELECT, Command.SCREEN, 1);
    /** Creates a new instance of ActiveContacts */
    public ActiveContacts(Display display, Contact current) {
	super();
	activeContacts=new Vector();
	for (Enumeration r=StaticData.getInstance().roster.getHContacts().elements(); 
	    r.hasMoreElements(); ) 
	{
	    Contact c=(Contact)r.nextElement();
	    if (c.active()) activeContacts.addElement(c);
	}
	// не создаём вид, если нет активных контактов
	if (getItemCount()==0) return;
	
        Title title=new Title(2, String.valueOf(getItemCount()), " ");
        title.addElement(SR.MS_ACTIVE_CONTACTS);
        setTitleItem(title);

	addCommand(cmdSelect);
	addCommand(cmdCancel);
	setCommandListener(this);
	
	try {
            int focus=activeContacts.indexOf(current);
            moveCursorTo(focus, true);
        } catch (Exception e) {}
        //if (current!=null) mov
	
	attachDisplay(display);
    }

    protected int getItemCount() { return activeContacts.size(); }
    protected VirtualElement getItemRef(int index) { 
	return (VirtualElement) activeContacts.elementAt(index);
    }

    public void eventOk() {
	Contact c=(Contact)getFocusedObject();
	new ContactMessageList((Contact)c,display).setParentView(StaticData.getInstance().roster);
    }
    
    public void commandAction(Command c, Displayable d) {
	if (c==cmdCancel) destroyView();
	if (c==cmdSelect) eventOk();
    }
    
    public void keyPressed(int keyCode) {
	if (keyCode==KEY_NUM3) destroyView();
	else super.keyPressed(keyCode);
    }
}
/*
 * AlertProfile.java
 *
 * Created on 28 Март 2005 г., 0:05
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import images.RosterIcons;
import locale.SR;
import ui.*;
import javax.microedition.lcdui.*;

/**
 *
 * @author Eugene Stahov
 */
public class AlertProfile extends VirtualList implements CommandListener {
    public final static int AUTO=0;
    public final static int ALL=1;
    public final static int VIBRA=2;
    public final static int SOUND=3;
    public final static int NONE=4;
    
    private final static String[] alertNames=
    { "Auto", "All signals", "Vibra", "Sound", "No signals"};
    
    private Profile profile=new Profile();
    int defp;
    Config cf;
    
    /** Creates a new instance of Profile */
    
    private Command cmdOk=new Command(SR.MS_SELECT,Command.OK,1);
    private Command cmdDef=new Command(SR.MS_SETDEFAULT,Command.OK,2);
    private Command cmdCancel=new Command(SR.MS_BACK,Command.BACK,99);
    /** Creates a new instance of SelectStatus */
    public AlertProfile(Display d) {
        super();
        
        cf=Config.getInstance();
        
        setTitleItem(new Title(SR.MS_ALERT_PROFILE));
        
        addCommand(cmdOk);
        addCommand(cmdDef);
        addCommand(cmdCancel);
        setCommandListener(this);
        
        int p=cf.profile;
        defp=cf.def_profile;
        
        moveCursorTo(p, true);
        attachDisplay(d);
    }
    
    int index;
    public VirtualElement getItemRef(int Index){ index=Index; return profile;}
    private class Profile extends IconTextElement {
        public Profile(){
            super(RosterIcons.getInstance());
        }
        //public void onSelect(){}
        public int getColor(){ return Colors.LIST_INK; }
        public int getImageIndex(){return index+RosterIcons.ICON_PROFILE_INDEX;}
        public String toString(){ 
            StringBuffer s=new StringBuffer(alertNames[index]);
            if (index==defp) s.append(" (default)");
            return s.toString();
        }
    }
    
    public void commandAction(Command c, Displayable d){
        if (c==cmdOk) eventOk(); 
        if (c==cmdDef) { 
            cf.def_profile=defp=cursor;
	    cf.saveToStorage();
            redraw();
        }
        if (c==cmdCancel) destroyView();
    }
    
    public void eventOk(){
        cf.profile=cursor;
        destroyView();
    }
    
    public int getItemCount(){   return alertNames.length; }
    

    /** */
    public static void playNotify(Display display, int event) {
        Config cf=Config.getInstance();
        String message=cf.messagesnd;
	String type=cf.messageSndType;
	int volume=cf.soundVol;
        int profile=cf.profile;
        if (profile==AUTO) profile=ALL;
        
        EventNotify notify=null;
        
        boolean blFlashEn=cf.blFlash;   // motorola e398 backlight bug
        
        switch (profile) {
            case ALL:   notify=new EventNotify(display, type, message, cf.vibraLen, blFlashEn); break;
            case NONE:  notify=new EventNotify(display, null, null,    0,           false    ); break;
            case VIBRA: notify=new EventNotify(display, null, null,    cf.vibraLen, blFlashEn); break;
            case SOUND: notify=new EventNotify(display, type, message, 0,           blFlashEn); break;
        }
        if (notify!=null) notify.startNotify();
    }
}
/*
 * Config.java
 *
 * Created on 19 Март 2005 г., 18:37
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import Info.Version;
import images.RosterIcons;
import images.SmilesIcons;
import java.io.*;
import java.util.*;
import javax.microedition.lcdui.Font;
import midlet.Bombus;
import ui.FontCache;
import util.StringLoader;
import ui.Time;
import ui.VirtualElement;
import ui.VirtualList;
//import javax.microedition.rms.*;

/**
 *
 * @author Eugene Stahov
 */
public class Config {
    
    public final int vibraLen=getIntProperty("vibra_len",500);
    
    public int keepAlive=200;//getIntProperty("keep_alive",200);
    public int keepAliveType=getIntProperty("keep_alive_type",0);

    /*public int socketLINGER=getIntProperty("LINGER",-1);
    public int socketRCVBUF=getIntProperty("RCVBUF",-1);
    public int socketSNDBUF=getIntProperty("SNDBUF",-1);*/

    public boolean ghostMotor=getBooleanProperty("moto_e398",false);
    public boolean blFlash=!ghostMotor; //true;
    
    public boolean msgLog=getBooleanProperty("msg_log",false);
    
    public boolean muc119=getBooleanProperty("muc_119",true);	// before muc 1.19 use muc#owner instead of muc#admin
    
    public int sounsMsgIndex=0;

    public String messagesnd;
    public String messageSndType;
    
    public int soundVol=100;
    
//#if !(MIDP1)
    public char keyLock=getCharProperty("key_lock",'*');
    public char keyVibra=getCharProperty("key_vibra",'#');
//#else
//#     public boolean msgLogPresence=getBooleanProperty("msg_log_presence",false);
//#     public boolean msgLogConfPresence=getBooleanProperty("msg_log_conf_presence",false);
//#     public boolean msgLogConf=getBooleanProperty("msg_log_conf",false);
//#     public final String msgPath=getStringProperty("msg_log_path","");
//#     public final String siemensCfgPath=getStringProperty("cfg_path","");
//#     public char keyLock=getCharProperty("key_lock",'#');
//#     public char keyVibra=getCharProperty("key_vibra",'*');
//#endif
    
    public char keyHide=getCharProperty("key_hide",'9');
    public char keyOfflines=getCharProperty("key_offlines",'0');
    
//#if USE_LED_PATTERN
//#     public int m55LedPattern=0;
//#endif
    
    public String defGcRoom=getStringProperty("gc_room","bombus@conference.jabber.ru");
    
    //public String xmlLang=getStringProperty("xml_lang",null);
    
    // non-volatile values
    //public TimeZone tz=new RuGmt(0);
    public int accountIndex=-1;
    public boolean fullscreen=false;
    public int def_profile=0;
    public boolean smiles=true;
    public boolean showOfflineContacts=true;
    public boolean showTransports=true;
    public boolean selfContact=false;
    public boolean notInList=true;
    public boolean ignore=false;
    public boolean eventComposing=false;
    
    public boolean storeConfPresence=true;      
    
    public boolean autoLogin=true;
    public boolean autoJoinConferences=false;
    
    public boolean autoFocus=true;
    
    public int gmtOffset;
    public int locOffset;
    
    public boolean popupFromMinimized=true;
    public boolean memMonitor;
    
    public int font1=0;
    public int font2=0;
    public int font3=0;

    public int lang=0;  //en
    public boolean capsState=true;
    public int textWrap=0;
    
    // runtime values
    public boolean allowMinimize=false;
    public int profile=0;
    public int lastProfile=0;
    
    public boolean istreamWaiting;

    // Singleton
    private static Config instance;

    
    public static Config getInstance(){
	if (instance==null) {
	    instance=new Config();
	    // this method called outside class constructor to avoid recursion
            // because using of NvStorage methods depending on Config.getInstance()
	    instance.loadFromStorage();
	    instance.loadSoundName();

            //FontCache.balloonFontSize=Font.SIZE_SMALL;
            FontCache.rosterFontSize=instance.font1;
            FontCache.msgFontSize=instance.font2;
            FontCache.resetCache();
	}
	return instance;
    }
    
    /** Creates a new instance of Config */
    private Config() {
     
        
	int gmtloc=TimeZone.getDefault().getRawOffset()/3600000;
	locOffset=getIntProperty( "time_loc_offset", 0);
	gmtOffset=getIntProperty("time_gmt_offset", gmtloc);
	
	int greenKeyCode=VirtualList.SIEMENS_GREEN;
	
	String platform=Version.getPlatformName();
	
	if (platform.startsWith("SonyE")) {
            //prefetch images
            RosterIcons.getInstance();
            SmilesIcons.getInstance();
            
	    allowMinimize=true;
            greenKeyCode=VirtualList.SE_GREEN;
	}
	if (platform.startsWith("Nokia")) {
	    blFlash=false;
	    greenKeyCode=VirtualList.NOKIA_GREEN;
	}
	if (platform.startsWith("Moto")) {
	    ghostMotor=true;
	    blFlash=false;
            istreamWaiting=true;
	    greenKeyCode=VirtualList.MOTOROLA_GREEN;
	    VirtualList.keyClear=0x1000;
	    VirtualList.keyVolDown=VirtualList.MOTOE680_VOL_DOWN;
	}
        
	/*if (platform.startsWith("j2me")) {
	    greenKeyCode=VirtualList.MOTOROLA_GREEN;
	    VirtualList.keyClear=0x1000;
	    VirtualList.keyVolDown=VirtualList.MOTOE680_VOL_DOWN;
            istreamWaiting=true;
	}*/
        
        if (Version.isSiemens==true) {
            keyLock='#';
            keyVibra='*';
        }
        
	VirtualList.greenKeyCode=greenKeyCode;
//#if USE_LED_PATTERN
//#         if (platform.startsWith("M55"))
//#         m55LedPattern=getIntProperty("led_pattern",5);
//#endif
    }
    
    protected void loadFromStorage(){
	try {
	    DataInputStream inputStream=NvStorage.ReadFileRecord("config", 0);
	    accountIndex = inputStream.readInt();
	    showOfflineContacts=inputStream.readBoolean();
	    fullscreen=inputStream.readBoolean();
	    def_profile = inputStream.readInt();
	    smiles=inputStream.readBoolean();
	    showTransports=inputStream.readBoolean();
	    selfContact=inputStream.readBoolean();
	    notInList=inputStream.readBoolean();
	    ignore=inputStream.readBoolean();
	    eventComposing=inputStream.readBoolean();
	    
	    gmtOffset=inputStream.readInt();
	    locOffset=inputStream.readInt();
	    
	    sounsMsgIndex=inputStream.readInt();
	    soundVol=inputStream.readInt();
	    
	    autoLogin=inputStream.readBoolean();
	    autoJoinConferences=inputStream.readBoolean();
	    
	    keepAlive=inputStream.readInt();
	    
	    popupFromMinimized=inputStream.readBoolean();
	    
	    blFlash=inputStream.readBoolean();
	    memMonitor=inputStream.readBoolean();
            
            font1=inputStream.readInt();
            font2=inputStream.readInt();
            
            autoFocus=inputStream.readBoolean();
            
            lang=inputStream.readInt();
            
            storeConfPresence=inputStream.readBoolean();
            
            capsState=inputStream.readBoolean();
	    
	    textWrap=inputStream.readInt();
	    
	    inputStream.close();
	} catch (Exception e) {
	    e.printStackTrace();
	}
	
	lastProfile=profile=def_profile;
        if (lastProfile==AlertProfile.VIBRA) lastProfile=0;
	updateTime();
	VirtualList.fullscreen=fullscreen;
	VirtualList.memMonitor=memMonitor;
    }
    
    public void loadSoundName(){
	Vector files[]=new StringLoader().stringLoader("/sounds/res.txt", 3);
	messageSndType=(String) files[0].elementAt(sounsMsgIndex);
	messagesnd=(String) files[1].elementAt(sounsMsgIndex);
    }
    public String langFileName(){
        if (lang==0) return null;   //english
	Vector files[]=new StringLoader().stringLoader("/lang/res.txt", 2);
	return (String) files[0].elementAt(lang);
    }
    
    public void saveToStorage(){
	
	DataOutputStream outputStream=NvStorage.CreateDataOutputStream();
	
	try {
	    outputStream.writeInt(accountIndex);
	    outputStream.writeBoolean(showOfflineContacts);
	    outputStream.writeBoolean(fullscreen);
	    outputStream.writeInt(def_profile);
	    outputStream.writeBoolean(smiles);
	    outputStream.writeBoolean(showTransports);
	    outputStream.writeBoolean(selfContact);
	    outputStream.writeBoolean(notInList);
	    outputStream.writeBoolean(ignore);
	    outputStream.writeBoolean(eventComposing);
	    
	    outputStream.writeInt(gmtOffset);
	    outputStream.writeInt(locOffset);
	    
	    outputStream.writeInt(sounsMsgIndex);
	    outputStream.writeInt(soundVol);
	    
	    outputStream.writeBoolean(autoLogin);
	    outputStream.writeBoolean(autoJoinConferences);
	    
	    outputStream.writeInt(keepAlive);

	    outputStream.writeBoolean(popupFromMinimized);
	    
	    outputStream.writeBoolean(blFlash);
	    outputStream.writeBoolean(memMonitor);
            
            outputStream.writeInt(font1);
            outputStream.writeInt(font2);
            
            outputStream.writeBoolean(autoFocus);
            
            outputStream.writeInt(lang);
            
            outputStream.writeBoolean(storeConfPresence); 

            outputStream.writeBoolean(capsState); 
	    
	    outputStream.writeInt(textWrap);
	    
	} catch (IOException e) { e.printStackTrace(); }
	
	NvStorage.writeFileRecord(outputStream, "config", 0, true);
    }
    
    
    public void updateTime(){
	Time.setOffset(gmtOffset, locOffset);
    }
    
    
    public final String getStringProperty(final String key, final String defvalue) {
	try {
	    String s=Bombus.getInstance().getAppProperty(key);
	    return (s==null)?defvalue:s;
	} catch (Exception e) {	}
        // возвращает defvalue, если атрибут не существует или имеет неправильный формат
        return defvalue;
    }
    
    public final int getIntProperty(final String key, final int defvalue) {
	try {
	    String s=Bombus.getInstance().getAppProperty(key);
	    return Integer.parseInt(s); //throws NullPointerException or NumberFormatException
	} catch (Exception e) { }
        // возвращает defvalue, если атрибут не существует или имеет неправильный формат
	return defvalue;
    }
    
    public final char getCharProperty(final String key, final char defvalue) {
	try {
	    String s=Bombus.getInstance().getAppProperty(key);
	    return s.charAt(0); //throws NullPointerException или IndexOutOfBoundsException
	} catch (Exception e) {	}
        // возвращает defvalue, если атрибут не существует или имеет неправильный формат
        return defvalue;
    }
    
    public final boolean getBooleanProperty(final String key, final boolean defvalue) {
	try {
	    String s=Bombus.getInstance().getAppProperty(key);
	    if (s.equals("true")) return true;
	    if (s.equals("yes")) return true;
	    if (s.equals("1")) return true;
            return false;
	} catch (Exception e) { }
        // возвращает defvalue, если атрибут не существует 
        return defvalue;
    }
    
}
/*
 * ConfigForm.java
 *
 * Created on 2 Май 2005 г., 18:19
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import java.util.Enumeration;
import java.util.Vector;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.controls.NumberField;
import util.StringLoader;
import ui.*;

/**
 *
 * @author Evg_S
 */

/*
 * roster elements:
 *  [] self-contact
 *  [] offline contacts
 *  [] transports
 *  [] hidden group
 *  [] not-in-list
 *  [] clock
 *
 * message
 *  [] show smiles
 *  [] history
 *  [] composing
 *
 * startup actions
 *  [] login
 *  [] Join conferences
 *
 * application
 *  [] fullscreen
 */

public class ConfigForm implements
	CommandListener 
//#if !(MIDP1)
	,ItemCommandListener
//#endif
	//,ItemStateListener
{
    private Display display;
    private Displayable parentView;

    Form f;
    ChoiceGroup roster;
    ChoiceGroup message;
    ChoiceGroup startup;
    ChoiceGroup application;

    ChoiceGroup lang;
    
    ChoiceGroup sndFile;
    //Gauge sndVol;
    
    ChoiceGroup font1;
    ChoiceGroup font2;
    
    ChoiceGroup textWrap;
    
    NumberField keepAlive;
    NumberField fieldLoc;
    NumberField fieldGmt;
    
    Command cmdOk=new Command(SR.MS_OK,Command.OK,1);
    //Command cmdSign=new Command("- (Sign)",Command.ITEM,2);
    Command cmdPlaySound=new Command(SR.MS_TEST_SOUND, Command.ITEM,10);
    Command cmdCancel=new Command(SR.MS_CANCEL, Command.BACK,99);
    
    Config cf;
    boolean ra[];
    boolean mv[];
    boolean ap[];
    boolean su[];
    Vector files[];
    
    /** Creates a new instance of ConfigForm */
    public ConfigForm(Display display) {
        this.display=display;
        parentView=display.getCurrent();
        
        cf=Config.getInstance();
        
        f=new Form(SR.MS_OPTIONS);
        roster=new ChoiceGroup(SR.MS_ROSTER_ELEMENTS, Choice.MULTIPLE);
        roster.append(SR.MS_OFFLINE_CONTACTS, null);
        roster.append(SR.MS_SELF_CONTACT, null);
        roster.append(SR.MS_TRANSPORTS, null);
        roster.append(SR.MS_IGNORE_LIST, null);
        roster.append(SR.MS_NOT_IN_LIST, null);
        roster.append(SR.MS_AUTOFOCUS,null);
        
        boolean ra[]={
            cf.showOfflineContacts,
            cf.selfContact,
            cf.showTransports, 
            cf.ignore, 
            cf.notInList,
            cf.autoFocus
        };
        this.ra=ra;
        //ra[5]=false;
        roster.setSelectedFlags(ra);

        message=new ChoiceGroup(SR.MS_MESSAGES, Choice.MULTIPLE);
        message.append(SR.MS_SMILES, null);
        message.append(SR.MS_HISTORY, null);
        message.append(SR.MS_STORE_PRESENCE,null);        
        message.append(SR.MS_COMPOSING_EVENTS, null);
//#if (!MIDP1)
        message.append(SR.MS_CAPS_STATE, null);
//#endif
        
        boolean mv[]={
            cf.smiles,
            cf.msgLog,
            cf.storeConfPresence,
            cf.eventComposing
//#if (!MIDP1)
            ,cf.capsState
//#endif
        };
        this.mv=mv;
        
        message.setSelectedFlags(mv);

	startup=new ChoiceGroup(SR.MS_STARTUP_ACTIONS, Choice.MULTIPLE);
        startup.append(SR.MS_AUTOLOGIN, null);
        startup.append(SR.MS_AUTO_CONFERENCES,null);
        su=new boolean[2];
        su[0]=cf.autoLogin;
        su[1]=cf.autoJoinConferences;
        startup.setSelectedFlags(su);
        
        ap=new boolean[4];
	int apctr=0;
        application=new ChoiceGroup(SR.MS_APPLICATION, Choice.MULTIPLE);
//#if !(MIDP1)
        ap[apctr++]=cf.fullscreen;
        application.append(SR.MS_FULLSCREEN,null);
//#endif
        application.append(SR.MS_HEAP_MONITOR,null);
	if (!cf.ghostMotor)
            application.append(SR.MS_FLASHBACKLIGHT,null);
	if (cf.allowMinimize)
	    application.append(SR.MS_ENABLE_POPUP,null);
	ap[apctr++]=cf.memMonitor;
	ap[apctr++]=cf.blFlash;
	ap[apctr++]=cf.popupFromMinimized;
	
        application.setSelectedFlags(ap);
        
	keepAlive=new NumberField(SR.MS_KEEPALIVE_PERIOD, cf.keepAlive, 20, 600 );
	fieldGmt=new NumberField(SR.MS_GMT_OFFSET, cf.gmtOffset, -12, 12); 
        fieldLoc=new NumberField(SR.MS_CLOCK_OFFSET, cf.locOffset, -12, 12 );
        
        sndFile=new ChoiceGroup(SR.MS_SOUND, ConstMIDP.CHOICE_POPUP);
	files=new StringLoader().stringLoader("/sounds/res.txt",3);
	
	for (Enumeration f=files[2].elements(); f.hasMoreElements(); ) {
	    sndFile.append( (String)f.nextElement(), null );
	}
	
	sndFile.setSelectedIndex(cf.sounsMsgIndex, true);

        String fnts[]={"Normal", "Small", "Large"};
        font1=new ChoiceGroup(SR.MS_ROSTER_FONT, ConstMIDP.CHOICE_POPUP, fnts, null);
        font2=new ChoiceGroup(SR.MS_MESSAGE_FONT, ConstMIDP.CHOICE_POPUP, fnts, null);
        font1.setSelectedIndex(cf.font1/8, true);
        font2.setSelectedIndex(cf.font2/8, true);

        f.append(roster);
        f.append(font1);

        f.append(message);
        f.append(font2);
	
	String textWraps[]={SR.MS_TEXTWRAP_CHARACTER, SR.MS_TEXTWRAP_WORD};
	textWrap=new ChoiceGroup(SR.MS_TEXTWRAP, ConstMIDP.CHOICE_POPUP, textWraps,null);
	textWrap.setSelectedIndex(cf.textWrap, true);
	f.append(textWrap);
	
	f.append(sndFile);
	
        lang=new ChoiceGroup("Language", ConstMIDP.CHOICE_POPUP);
	Vector langs[]=new StringLoader().stringLoader("/lang/res.txt",2);
	
	for (Enumeration f=langs[1].elements(); f.hasMoreElements(); ) {
	    lang.append( (String)f.nextElement(), null );
	}
	
        try {
            lang.setSelectedIndex(cf.lang, true);
        } catch (Exception e) {}

        
        //sndVol=new Gauge("Sound volume", true, 10,  cf.soundVol/10);
	//f.append(sndVol);

//#if !(MIDP1)
	sndFile.addCommand(cmdPlaySound);
	sndFile.setItemCommandListener(this);
	//sndVol.addCommand(cmdPlaySound);
	//sndVol.setItemCommandListener(this);
//#else
//# 	f.addCommand(cmdPlaySound);
//#endif
	
	f.append(startup);

	f.append(application);

	f.append(keepAlive);
	
        f.append(SR.MS_TIME_SETTINGS);
        f.append("\n");
        
        f.append(fieldGmt);
        f.append(fieldLoc);
        
        f.append(lang);

        f.addCommand(cmdOk);
        f.addCommand(cmdCancel);
        
        f.setCommandListener(this);
	//f.setItemStateListener(this);
        
        display.setCurrent(f);
    }
    
    public void commandAction(Command c, Displayable d) {
        if (c==cmdOk) {
            roster.getSelectedFlags(ra);
            message.getSelectedFlags(mv);
            application.getSelectedFlags(ap);
	    startup.getSelectedFlags(su);
	    
            cf.showOfflineContacts=ra[0];
            cf.selfContact=ra[1];
            cf.showTransports=ra[2];
            cf.ignore=ra[3];
            cf.notInList=ra[4];
            cf.autoFocus=ra[5];

            cf.smiles=mv[0];
            cf.msgLog=mv[1];
            cf.storeConfPresence=mv[2];
            cf.eventComposing=mv[3];
//#if (!MIDP1)
            cf.capsState=mv[4];
//#endif

	    
	    cf.autoLogin=su[0];
	    cf.autoJoinConferences=su[1];
            
	    int apctr=0;
//#if !(MIDP1)
            VirtualList.fullscreen=cf.fullscreen=ap[apctr++];
            StaticData.getInstance().roster.setFullScreenMode(cf.fullscreen);
//#endif
	    VirtualList.memMonitor=cf.memMonitor=ap[apctr++];
	    cf.blFlash=ap[apctr++];
	    cf.popupFromMinimized=ap[apctr++];
            
	    cf.gmtOffset=fieldGmt.getValue();
	    cf.locOffset=fieldLoc.getValue();
	    cf.keepAlive=keepAlive.getValue();
	    
	    cf.sounsMsgIndex=sndFile.getSelectedIndex();
            
            FontCache.rosterFontSize=cf.font1=font1.getSelectedIndex()*8;
            FontCache.msgFontSize=cf.font2=font2.getSelectedIndex()*8;
            FontCache.resetCache();
	    
	    cf.textWrap=textWrap.getSelectedIndex();
	    
	    //cf.soundVol=sndVol.getValue()*10;
            cf.lang=lang.getSelectedIndex();
	    
	    cf.loadSoundName();
            
            cf.updateTime();
            
            cf.saveToStorage();
            
            StaticData.getInstance().roster.reEnumRoster();
            destroyView();
        }
//#if MIDP1
//#         if (c==cmdPlaySound) testSound();
//#endif
        if (c==cmdCancel) destroyView();
    }

//#if !(MIDP1)
    public void commandAction(Command command, Item item) {
	if (command==cmdPlaySound) {
	    testSound();
	}
    }
//#endif
    
    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView);
//#if !(MIDP1)
        ((Canvas)parentView).setFullScreenMode(cf.fullscreen);
//#endif
    }

    /*public void itemStateChanged(Item item) {
	if (item==sndVol || item==soundFile) 
     */
    private void testSound(){
	int sound=sndFile.getSelectedIndex();
	String soundFile=(String)files[1].elementAt(sound);
	String soundType=(String)files[0].elementAt(sound);
	new EventNotify(display, soundType, soundFile, 0, false).startNotify();
    }

}
/*
 * Contact.java
 *
 * Created on 6 января 2005 г., 19:16
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import images.RosterIcons;
import ui.Colors;
import vcard.VCard;
import java.util.*;
import ui.IconTextElement;
import ui.ImageList;
import com.alsutton.jabber.datablocks.Presence;

/**
 * Contact
 * @author Eugene Stahov
 */
public class Contact extends IconTextElement{
    
    private static int COLORS[]={
        Colors.CONTACT_DEFAULT,
        Colors.CONTACT_CHAT,
        Colors.CONTACT_AWAY,
        Colors.CONTACT_XA,
        Colors.CONTACT_DND,
        Colors.CONTACT_DEFAULT,
        Colors.CONTACT_DEFAULT,
        Colors.CONTACT_DEFAULT
    };
    
    public final static byte ORIGIN_ROSTER=0;
    public final static byte ORIGIN_ROSTERRES=1;
    public final static byte ORIGIN_CLONE=2;
    public final static byte ORIGIN_PRESENCE=3;
    public final static byte ORIGIN_GROUPCHAT=4;
    public final static byte ORIGIN_GC_MEMBER=5;
    public final static byte ORIGIN_GC_MYSELF=6;

   
    /** Creates a new instance of Contact */
    protected Contact (){
        //lastReaded=0;
        super(RosterIcons.getInstance());
        msgs=new Vector();
        key1="";
    }

    public String nick;
    public Jid jid;
    public String bareJid;    // for roster/subscription manipulating
    public int status;
    public int priority;
    private Group group;
    public int transport;
    
    public boolean acceptComposing;
    public Integer incomingComposing;
    
    public String msgSuspended;
    
    //public int key1;
    protected int key0;
    protected String key1;

    public byte origin;
    //public boolean gcMyself;
    
    public String subscr;
    public int offline_type=Presence.PRESENCE_UNKNOWN;
    public boolean ask_subscribe;
    
    public Vector msgs;
    private int newMsgCnt=-1;
    public int unreadType;
    public int lastUnread;
    
    public VCard vcard;
    
    //public long conferenceJoinTime;
    
    public int firstUnread(){
        int unreadIndex=0;
        for (Enumeration e=msgs.elements(); e.hasMoreElements();) {
            if (((Msg)e.nextElement()).unread) break;
            unreadIndex++;
        }
        return unreadIndex;
    }

    public Contact(final String Nick, final String sJid, final int Status, String subscr) {
        this();
        nick=Nick; jid= new Jid(sJid); status=Status;
        bareJid=sJid;
        this.subscr=subscr;
    
        setSortKey((Nick==null)?sJid:Nick);
        //msgs.removeAllElements();
        
        //calculating transport
        transport=RosterIcons.getInstance().getTransportIndex(jid.getTransport());
    }
    
    public Contact clone(Jid newjid, final int status) {
        Contact clone=new Contact();
        clone.group=group; 
        clone.jid=newjid; 
        clone.nick=nick;
        clone.key1=key1;
        clone.subscr=subscr;
        clone.offline_type=offline_type;
        clone.origin=ORIGIN_CLONE; 
        clone.status=status; 
        clone.transport=RosterIcons.getInstance().getTransportIndex(newjid.getTransport()); //<<<<

        clone.bareJid=bareJid;
        return clone;
    }
    
    public int getImageIndex() {
        if (getNewMsgsCount()>0) 
            switch (unreadType) {
                case Msg.MESSAGE_TYPE_AUTH: return RosterIcons.ICON_AUTHRQ_INDEX;
                default: return RosterIcons.ICON_MESSAGE_INDEX;
            }
        if (incomingComposing!=null) return RosterIcons.ICON_COMPOSING_INDEX;
        int st=(status==Presence.PRESENCE_OFFLINE)?offline_type:status;
        if (st<8) st+=transport; 
        return st;
    }
    public int getNewMsgsCount() {
        if (getGroupType()==Groups.TYPE_IGNORE) return 0;
        //return msgs.size()-lastReaded;
        if (newMsgCnt>-1) return newMsgCnt;
        int nm=0;
        unreadType=Msg.MESSAGE_TYPE_IN;
        for (Enumeration e=msgs.elements(); e.hasMoreElements(); ) {
            Msg m=(Msg)e.nextElement();
            if (m.unread) { 
                nm++;
                if (m.messageType==Msg.MESSAGE_TYPE_AUTH) unreadType=m.messageType;
            }
        }
        return newMsgCnt=nm;
    }
    
    public boolean needsCount(){ return (newMsgCnt<0);  }
    
    public boolean active(){
	if (msgs.size()>1) return true;
	if (msgs.size()==0) return false;
	return (((Msg)msgs.elementAt(0)).messageType!=Msg.MESSAGE_TYPE_PRESENCE);
    }
    
    public void resetNewMsgCnt() { newMsgCnt=-1;}
    
    public void setComposing (boolean state) {
        incomingComposing=(state)? new Integer(RosterIcons.ICON_COMPOSING_INDEX):null;
        //System.out.println("Composing:"+state);
    }
    
    public int compare(Contact c){
        //1. status
        int cmp;
        //if (origin>=ORIGIN_GROUPCHAT && c.origin>=ORIGIN_GROUPCHAT) {
        //    if ((cmp=origin-c.origin) !=0) return cmp;
        //} else {
        //    if ((cmp=status-c.status) !=0) return cmp;
        //}
        if ((cmp=key0-c.key0) !=0) return cmp;
        if ((cmp=status-c.status) !=0) return cmp;
        if ((cmp=key1.compareTo(c.key1)) !=0) return cmp;
        if ((cmp=c.priority-priority) !=0) return cmp;
        return c.transport-transport;
        //return 0;
    };
    
    public void addMessage(Msg m) {
        boolean first_replace=false;
        if (m.isPresence()) 
            if (msgs.size()==1) 
                if ( ((Msg)msgs.firstElement()).isPresence())
                    if (origin!=ORIGIN_GROUPCHAT) first_replace=true;
//#if USE_SIEMENS_FILES
//#         Config cf=Config.getInstance();
//# 
//#         if (cf.msgLog && group.index!=Groups.TYPE_TRANSP && group.index!=Groups.TYPE_SEARCH_RESULT)
//#         {
//#             String histRecord=(nick==null)?getBareJid():nick;
//#             String fromName=StaticData.getInstance().account.getUserName();
//#             if (m.messageType!=Msg.MESSAGE_TYPE_OUT) fromName=toString();
//#             boolean allowLog=false;
//#             switch (m.messageType) {
//#                 case Msg.MESSAGE_TYPE_PRESENCE:
//#                     if (origin>=ORIGIN_GROUPCHAT && cf.msgLogConfPresence) allowLog=true;
//#                     if (origin<ORIGIN_GROUPCHAT && cf.msgLogPresence) allowLog=true;
//#                     break;
//#                 default:
//#                     if (origin>=ORIGIN_GROUPCHAT && cf.msgLogConf) allowLog=true;
//#                     if (origin<ORIGIN_GROUPCHAT) allowLog=true;
//#             }
//#             if (allowLog)
//#                 //if (!first_replace || !m.)
//#             {
//#                 StringBuffer body=new StringBuffer(m.getDayTime());
//#                 body.append(" <");
//#                 body.append(fromName);
//#                 body.append("> ");
//#                 if (m.subject!=null) {
//#                     body.append(m.subject);
//#                     body.append("\r\n");
//#                 }
//#                 body.append(m.getBody());
//#                 body.append("\r\n");
//#                 NvStorage.appendFile("Log_"+histRecord, body.toString());
//#             }
//#         }
//#endif
        // пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ - presence, пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ
        if (first_replace) {
            msgs.setElementAt(m,0);
            return;
        } 
        msgs.addElement(m);
        if (m.unread) {
            lastUnread=msgs.size()-1;
            if (m.messageType>unreadType) unreadType=m.messageType;
            if (newMsgCnt>=0) newMsgCnt++;
        }
    }
    
  
    public int getColor() { return (status>7)?0:COLORS[status]; }

    public int getFontIndex(){
        return (status<5)?1:0;
    }
    
    public String toString() { 
        if (origin>ORIGIN_GROUPCHAT) return nick;
        if (origin==ORIGIN_GROUPCHAT) return getJid();
        return (nick==null)?getJid():nick+jid.getResource(); 
    }
    
    public final String getName(){ return (nick==null)?getBareJid():nick; }
    //public void onSelect(){}

    public final String getJid() {
        return jid.getJid();
    }

    public final String getBareJid() {
        return bareJid;
    }

    public final String getNickJid() {
        if (nick==null) return bareJid;
        return nick+" <"+bareJid+">";
    }
    
    /**
     * Splits string like "name@jabber.ru/resource" to vector 
     * containing 2 substrings
     * @return Vector.elementAt(0)="name@jabber.ru"
     * Vector.elementAt(1)="resource"
     */
    /*
     public static final Vector SplitJid(final String jid) {
        Vector result=new Vector();
        int i=jid.lastIndexOf('/');
        if (i==-1){
            result.addElement(jid);
            result.addElement(null);
        } else {
            result.addElement(jid.substring(0,i));
            result.addElement(jid.substring(i+1));
        }
        return result;
    }
     */
    public final void purge() {
        msgs=new Vector();
        vcard=null;
        resetNewMsgCnt();
    }
    
    public final void setSortKey(String sortKey){
        key1=(sortKey==null)? "": sortKey.toLowerCase();
    }

    public String getTipString() {
        int nm=getNewMsgsCount();
        return (nm==0)? null:String.valueOf(nm);
    }

    public Group getGroup() { return group; }
    public int getGroupType() {  
        if (group==null) return 0; 
        return group.index;  
    }
    public boolean inGroup(Group ingroup) {  return group==ingroup;  }

    /*public void setGroupIndex(int groupIndex) {
        this.group = groupIndex;
    }*/
    public void setGroup(Group group) { this.group = group; }

    
    public final static void sort(Vector sortVector){
        synchronized (sortVector) {
            int f, i;
            Contact temp, temp2;
            
            for (f = 1; f < sortVector.size(); f++) {
                temp=(Contact)sortVector.elementAt(f);
                temp2=(Contact)sortVector.elementAt(f-1);
                if ( temp.compare(temp2) >=0 ) continue;
                i = f-1;
                while (i>=0){
                    temp2=(Contact)sortVector.elementAt(i);
                    if (temp2.compare(temp) <0) break;
                    sortVector.setElementAt(temp2,i+1);
                    i--;
                }
                sortVector.setElementAt(temp,i+1);
            }
        }
    }
    
}
/*
 * ContactEdit.java
 *
 * Created on 7 Май 2005 г., 2:15
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import Conference.MucContact;
import javax.microedition.lcdui.*;
import java.util.*;
import locale.SR;
import ui.ConstMIDP;

/**
 *
 * @author Evg_S
 */
public final class ContactEdit
        implements CommandListener, ItemStateListener 
//#if (!MIDP1)
        , ItemCommandListener
//#endif
{
    private Display display;
    public Displayable parentView;
    
    Form f;
    TextField tJid;
    TextField tNick;
    TextField tGroup;
    ChoiceGroup tGrpList;
    ChoiceGroup tTranspList;
    ChoiceGroup tAskSubscrCheckBox;
    
    int ngroups;
    
    Command cmdOk=new Command(SR.MS_ADD, Command.OK, 1);
    Command cmdSet=new Command("Set", Command.ITEM, 2);
    Command cmdCancel=new Command(SR.MS_CANCEL,Command.BACK,99);
    
    boolean newContact=true;
    Config cf;
    Roster roster;

    
    //StoreContact sC;
    
    public ContactEdit(Display display, Contact c) {
        this.display=display;
        parentView=display.getCurrent();
        
        StaticData sd=StaticData.getInstance();
        roster=sd.roster;
        
        Vector groups=sd.roster.groups.getRosterGroupNames();
        cf=Config.getInstance();
        
        f=new Form(SR.MS_ADD_CONTACT);
        
        tJid=new TextField(SR.MS_USER_JID, null, 64, TextField.EMAILADDR); 
        
        tNick=new TextField(SR.MS_NAME, null, 32, TextField.ANY); 
        tGroup=new TextField(SR.MS_GROUP ,null, 32, TextField.ANY);
        
        
        tGrpList=new ChoiceGroup(SR.MS_EXISTING_GROUPS , ConstMIDP.CHOICE_POPUP);
        tTranspList=new ChoiceGroup(SR.MS_TRANSPORT, ConstMIDP.CHOICE_POPUP);
        
        tAskSubscrCheckBox=new ChoiceGroup(SR.MS_SUBSCRIPTION, ChoiceGroup.MULTIPLE);
        tAskSubscrCheckBox.append(SR.MS_ASK_SUBSCRIPTION, null);
        
        
//#if (!MIDP1)
        //NOKIA FIX
        tGrpList.addCommand(cmdSet);
        tGrpList.setItemCommandListener(this);
        
        tTranspList.addCommand(cmdSet);
        tTranspList.setItemCommandListener(this);
//#endif
        
        // Transport droplist
        tTranspList.append(sd.account.getServer(), null);
        for (Enumeration e=sd.roster.getHContacts().elements(); e.hasMoreElements(); ){
            Contact ct=(Contact)e.nextElement();
            Jid transpJid=new Jid(ct.getJid()); //TODO: исправить этот хак (отрезание ресурса)
            if (transpJid.isTransport()) 
                tTranspList.append(transpJid.getBareJid(),null);
        }
        tTranspList.append(SR.MS_OTHER,null);
        
        try {
            String jid;
            if (c instanceof MucContact) {
                jid=Jid.getBareJid( ((MucContact)c).realJid );
            } else {
                jid=c.getBareJid();
            }
            // edit contact
            tJid.setString(jid);
            tNick.setString(c.nick);
            
            if (c instanceof MucContact) {
                c=null;
                throw new Exception();
            } 
            
            if (c.getGroupType()!=Groups.TYPE_NOT_IN_LIST  && c.getGroupType()!=Groups.TYPE_SEARCH_RESULT) {
                // edit contact
                f.setTitle(jid);
                cmdOk=new Command(SR.MS_UPDATE, Command.OK, 1);
                newContact=false;
            } else c=null; // adding not-in-list
        } catch (Exception e) {c=null;} // if MucContact does not contains realJid
        
        
        int sel=-1;
        ngroups=0;
        String grpName="";
        if (c!=null) grpName=c.getGroup().name;
        
        if (groups!=null) {
            ngroups=groups.size();
            for (int i=0;i<ngroups; i++) {
                String gn=(String)groups.elementAt(i);
                tGrpList.append(gn, null);
                
                if (gn.equals(grpName)) sel=i;
            }
        }
            
        //if (sel==-1) sel=groups.size()-1;
        if (sel<0) sel=0;
        tGroup.setString(group(sel));
        
        
        if (c==null){
            f.append(tJid);
            f.append(tTranspList);
        }
        updateChoise(tJid.getString(),tTranspList);
        f.append(tNick);
        f.append(tGroup);
        
        tGrpList.append(SR.MS_NEWGROUP,null);
        tGrpList.setSelectedIndex(sel, true);
        
        f.append(tGrpList);
        
        if (newContact) {
            f.append(tAskSubscrCheckBox);
            tAskSubscrCheckBox.setSelectedIndex(0, true);
        }
        
        f.addCommand(cmdOk);
        f.addCommand(cmdCancel);
        
        f.setCommandListener(this);
        f.setItemStateListener(this);
        
        display.setCurrent(f);
    }
    
    //public interface StoreContact {
    //    public void storeContact(String jid, String name, String group, boolean newContact);
    //}

    public void commandAction(Command c, Displayable d) {
        if (c==cmdOk) {
            String jid=getString(tJid);
            if (jid!=null) {
                String name=getString(tNick);
                String group=getString(tGroup);
                
                try {
                    int gSel=tGrpList.getSelectedIndex();
                    if (gSel!=tGrpList.size()-1)  {
                        group=(gSel>0)? tGrpList.getString(gSel) : null; // nokia fix
                    }
                } catch (Exception e) {} // nokia fix
                
                // сохранение контакта
                boolean ask[]=new boolean[1];
                tAskSubscrCheckBox.getSelectedFlags(ask);
                roster.storeContact(jid,name,group, ask[0]);
                destroyView();
                return;
            }
        }
        
        if (c==cmdCancel) destroyView();
    }
    
//#if (!MIDP1)
    public void commandAction(Command command, Item item) {
        itemStateChanged(item);
    }
//#endif

    private String getString(TextField t){
        if (t.size()==0) return null;
        String s=t.getString().trim();
        if (s.length()==0) return null;
        return s;
    }
    
    private String group(int index) {
        if (index==0) return null;
        if (index==tGrpList.size()-1) return null;
        return tGrpList.getString(index);
    }
    
    private void updateChoise(String str, ChoiceGroup grp) {
        int sz=grp.size();
        int set=sz-1;
        for (int i=0; i<sz; i++) {
            if (str.equals(grp.getString(i))) {
                set=i;
                break;
            }
        }
        if (grp.getSelectedIndex()!=set) 
            grp.setSelectedIndex(set, true);
    }
    
    public void itemStateChanged(Item item){
        if (item==tGrpList) {
            int index=tGrpList.getSelectedIndex();
            tGroup.setString(group(index));
        }
        if (item==tGroup) {
            updateChoise(tGroup.getString(), tGrpList);
        }
        if (item==tTranspList) {
            int index=tTranspList.getSelectedIndex();
            if (index==tTranspList.size()-1) return;
            
            String transport=tTranspList.getString(index);
            
            String jid=tJid.getString();
            StringBuffer jidBuf=new StringBuffer(jid);
            
            int at=jid.indexOf('@');
            if (at<0) at=tJid.size();
            
            jidBuf.setLength(at);
            jidBuf.append('@');
            jidBuf.append(transport);
            tJid.setString(jidBuf.toString());
        }
        if (item==tJid) {
            String s1=tJid.getString();
            int at=tJid.getString().indexOf('@');
            try {
                updateChoise(s1.substring(at+1), tTranspList);
            } catch (Exception e) {}
        }
    }
    
    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView/*roster*/);
    }

}
/*
 * ContactMessageList.java
 *
 * Created on 19 Февраль 2005 г., 23:54
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import Messages.MessageList;
import Messages.MessageParser;
import archive.MessageArchive;
import images.RosterIcons;
import images.SmilesIcons;
import locale.SR;
import vcard.VCard;
import ui.*;
import java.util.*;
import javax.microedition.lcdui.*;
/**
 *
 * @author Eugene Stahov
 */
public class ContactMessageList extends MessageList
{
    
    Contact contact;
    Command cmdSubscribe=new Command(SR.MS_SUBSCRIBE, Command.SCREEN, 1);
    Command cmdMessage=new Command(SR.MS_NEW_MESSAGE,Command.SCREEN,2);
    Command cmdResume=new Command(SR.MS_RESUME,Command.SCREEN,1);
    Command cmdQuote=new Command(SR.MS_QUOTE,Command.SCREEN,3);
    Command cmdArch=new Command(SR.MS_ADD_ARCHIVE,Command.SCREEN,4);
    Command cmdPurge=new Command(SR.MS_CLEAR_LIST, Command.SCREEN, 10);
    Command cmdContact=new Command(SR.MS_CONTACT,Command.SCREEN,11);
    Command cmdActive=new Command(SR.MS_ACTIVE_CONTACTS,Command.SCREEN,11);
    
    StaticData sd;
    
    /** Creates a new instance of MessageList */
    public ContactMessageList(Contact contact, Display display) {
        super(display);
        this.contact=contact;
        sd=StaticData.getInstance();
        
        Title title=new Title(contact);
        setTitleItem(title);
        
        title.addRAlign();
        title.addElement(null);
        title.addElement(null);
        //setTitleLine(title);

        cursor=0;//activate
        
        addCommand(cmdMessage);
        addCommand(cmdPurge);
        addCommand(cmdContact);
	addCommand(cmdActive);
        //if (getItemCount()>0) {
            addCommand(cmdQuote);
            addCommand(cmdArch);
	//}
        setCommandListener(this);
        moveCursorTo(contact.firstUnread(), true);
        //setRotator();
    }
    
    public void showNotify(){
        super.showNotify();
        if (cmdResume==null) return;
        if (contact.msgSuspended==null) removeCommand(cmdResume);
        else addCommand(cmdResume);
        
        if (cmdSubscribe==null) return;
        try {
            Msg msg=(Msg) contact.msgs.elementAt(cursor); 
            if (msg.messageType==Msg.MESSAGE_TYPE_AUTH) addCommand(cmdSubscribe);
            else removeCommand(cmdSubscribe);
        } catch (Exception e) {}
        
    }
    
    protected void beginPaint(){
        getTitleItem().setElementAt(sd.roster.messageIcon,2);
        //getTitleItem().setElementAt(contact.incomingComposing, 3);
    }
    
    public void markRead(int msgIndex) {
	if (msgIndex>=getItemCount()) return;
	//Msg msg=getMessage(msgIndex);
        //if (msg.unread) contact.resetNewMsgCnt();
        //msg.unread=false;
        if (msgIndex<contact.lastUnread) return;
        //if (contact.needsCount())
            sd.roster.countNewMsgs();
    }
    
    
    public int getItemCount(){ return contact.msgs.size(); }
    //public Element getItemRef(int Index){ return (Element) contact.msgs.elementAt(Index); }

    public Msg getMessage(int index) { 
	Msg msg=(Msg) contact.msgs.elementAt(index); 
	if (msg.unread) contact.resetNewMsgCnt();
	msg.unread=false;
	return msg;
    }
    
    public void focusedItem(int index){ 
        markRead(index); 
        /*try {
            Msg msg=(Msg) contact.msgs.elementAt(index); 
            if (msg.messageType==Msg.MESSAGE_TYPE_AUTH) addCommand(cmdSubscribe);
            else removeCommand(cmdSubscribe);
        } catch (Exception e) {}*/
    }
        
    public void commandAction(Command c, Displayable d){
        super.commandAction(c,d);
        /*if (c==cmdBack) {
            //contact.lastReaded=contact.msgs.size();
            //contact.resetNewMsgCnt();            
            destroyView();
            return;
        }*/
        if (c==cmdMessage) { 
            contact.msgSuspended=null; 
            keyGreen(); 
        }
        if (c==cmdResume) { keyGreen(); }
        if (c==cmdQuote) {
            try {
                new MessageEdit(display,contact,getMessage(cursor).toString());
            } catch (Exception e) {/*no messages*/}
        }
        if (c==cmdArch) {
            try {
                MessageArchive.store(getMessage(cursor));
            } catch (Exception e) {/*no messages*/}
        }
        if (c==cmdPurge) {
            clearMessageList();
        }
        if (c==cmdContact) {
            if (sd.roster.theStream!=null)
                new RosterItemActions(display, contact);
        }
	
	if (c==cmdActive) {
	    new ActiveContacts(display, contact);
	}
        
        if (c==cmdSubscribe) {
            if (contact.subscr==null) return;
            boolean subscribe = 
                    contact.subscr.startsWith("none") || 
                    contact.subscr.startsWith("from");
            if (contact.ask_subscribe) subscribe=false;

            boolean subscribed = 
                    contact.subscr.startsWith("none") || 
                    contact.subscr.startsWith("to");
                    //getMessage(cursor).messageType==Msg.MESSAGE_TYPE_AUTH;
            
            String to=contact.getBareJid();
            
            if (subscribed) sd.roster.sendPresence(to,"subscribed", null);
            if (subscribe) sd.roster.sendPresence(to,"subscribe", null);

        }
    }

    private void clearMessageList() {
        //TODO: fix scrollbar size
        moveCursorHome();
        contact.purge();
        messages=new Vector();
        System.gc();
        redraw();
    }
    
    public void keyGreen(){
        (new MessageEdit(display,contact,contact.msgSuspended)).setParentView(this);
        contact.msgSuspended=null;
    }
    
    public void keyRepeated(int keyCode) {
	if (keyCode==KEY_NUM3) new ActiveContacts(display, contact);
	else super.keyRepeated(keyCode);
    }

    public void userKeyPressed(int keyCode) {
        super.userKeyPressed(keyCode);
        if (keyCode==keyClear) {
            new YesNoAlert(display, this, SR.MS_CLEAR_LIST, SR.MS_SURE_CLEAR){
                public void yes() { clearMessageList(); }
            };
        }
    }
}
/*
 * ExtendedStatus.java
 *
 * Created on 27 Февраль 2005 г., 17:04
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import images.RosterIcons;
import java.util.Enumeration;
import java.io.*;
import java.util.Vector;
import ui.Colors;
import ui.IconTextElement;
import ui.ImageList;
import com.alsutton.jabber.datablocks.Presence;
/**
 *
 * @author Eugene Stahov
 */
public class ExtendedStatus extends IconTextElement{
    
    private String name;    // status name
    private String status="";
    private int priority;
    int index;
    
    /** Creates a new instance of ExtendedStatus */
    public ExtendedStatus(int index, String name) {
        super(RosterIcons.getInstance());
        this.index=index;
        this.name=name;
    }
    
    //public void onSelect(){}
    public String toString(){ 
        StringBuffer s=new StringBuffer(name);
        s.append(" (");
        s.append(priority);
        s.append(") ");
        if (status.length()>0) {
            s.append('"');
            s.append(status);
            s.append('"');
        }
        
        //return name+" ("+priority+") \""+status+"\""; 
        return s.toString();
    }
    public int getColor(){ return Colors.LIST_INK;}
    public int getImageIndex(){ return index;}

    public String getName() { return name; }
    public String getMessage() { return status; }
    public void setMessage(String s) { status=s; }

    public int getPriority() { return priority; }
    public void setPriority(int p) { priority=p; }

}
/*
 * Group.java
 *
 * Created on 8 пїЅпїЅпїЅ 2005 пїЅ., 0:36
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import images.RosterIcons;
import java.util.*;
import ui.*;


/**
 *
 * @author Evg_S
 */
public class Group extends IconTextElement {
    String name;
    int index; // group index
    protected int nContacts;
    protected int onlines;
    public int imageExpandedIndex=RosterIcons.ICON_EXPANDED_INDEX;
        
    public Vector contacts;
    
    // пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ
    private Vector tcontacts;
    public int tonlines;
    private int tncontacts;
    public int unreadMessages=0;
    
    boolean collapsed;
    
    public Group(String name /*, String label*/) {
        super(RosterIcons.getInstance());
        this.name=name;
        /*this.label=label;*/
        
    }
    public int getColor(){ return Colors.GROUP_INK; }
    public int getImageIndex() {
        return collapsed?
            RosterIcons.ICON_COLLAPSED_INDEX
            :imageExpandedIndex;
    }
    
    public String getName() { return name; }
    protected String title(String titleStart) {
	return titleStart+" ("+getOnlines()+'/'+getNContacts()+')';
    }
    public String toString(){ return title(name);  }

    public void onSelect(){
        collapsed=!collapsed;
    }

    public void setIndex(int index) {
	this.index = index;
        if (index==Groups.TYPE_SEARCH_RESULT) 
            imageExpandedIndex=RosterIcons.ICON_SEARCH_INDEX;
    }

    public void startCount(){
	//int size=(contacts==null)?10:contacts.size();
	tonlines=tncontacts=unreadMessages=0;
	//tcontacts=new Vector(size);
	contacts=new Vector();
    }

    public void addContact(Contact c) {
	tncontacts++;
	boolean online=c.status<5;
	if (online) {
	    tonlines++;
	}
	//int gindex=c.getGroupIndex();
	// hide offlines whithout new messages
        unreadMessages+=c.getNewMsgsCount();
        
	if (
	online
	|| Config.getInstance().showOfflineContacts
	|| c.getNewMsgsCount()>0
	//|| gindex==Groups.NIL_INDEX
	//|| gindex==Groups.TRANSP_INDEX
	|| index==Groups.TYPE_NOT_IN_LIST
	|| index==Groups.TYPE_TRANSP
	|| c.origin==Contact.ORIGIN_GROUPCHAT
	)
	    contacts.addElement(c);
	//grp.addContact(c);
    }
    void finishCount() {
	//contacts=tcontacts;
        onlines=tonlines;
        nContacts=tncontacts;
        tcontacts=null;
    }

    public int getNContacts() {
        return nContacts;
    }

    public int getOnlines() {
        return onlines;
    }

}
/*
 * Groups.java
 *
 * Created on 8 Май 2005 пїЅ., 0:36
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import images.RosterIcons;
import java.util.*;
import locale.SR;
import ui.ImageList;

/**
 *
 * @author Evg_S
 */
public class Groups{
    
    Vector groups;
    
    public final static int TYPE_TRANSP=0;
    public final static String TRANSP_GROUP=SR.MS_TRANSPORTS;
    public final static int TYPE_SELF=1;
    public final static String SELF_GROUP=SR.MS_SELF_CONTACT;
    public final static int TYPE_SEARCH_RESULT=2;
    public final static String SRC_RESULT_GROUP=SR.MS_SEARCH_RESULTS;
    public final static int TYPE_NOT_IN_LIST=3;
    public final static String NIL_GROUP=SR.MS_NOT_IN_LIST;
    public final static int TYPE_IGNORE=4;
    public final static String IGNORE_GROUP=SR.MS_IGNORE_LIST;
    public final static int TYPE_COMMON=5;
    public final static String COMMON_GROUP=SR.MS_GENERAL;
    
    public Groups(){
        groups=new Vector();
        addGroup(Groups.TRANSP_GROUP, false);
        addGroup(Groups.SELF_GROUP, false);
        addGroup(Groups.SRC_RESULT_GROUP, false);
        addGroup(Groups.NIL_GROUP, false);
        addGroup(Groups.IGNORE_GROUP, false);
        addGroup(Groups.COMMON_GROUP, false);
    }

    private int rosterContacts;
    private int rosterOnline;
    
    public void resetCounters(){
        for (Enumeration e=groups.elements();e.hasMoreElements();){
            Group grp=(Group)e.nextElement();
	    grp.startCount();
        }
	rosterContacts=rosterOnline=0;
    }
    
    public void addToVector(Vector d, int index){
        Group gr=getGroup(index);
        if (gr.contacts.size()>0){
            d.addElement(gr);
            if (!gr.collapsed) for (Enumeration e=gr.contacts.elements();e.hasMoreElements();){
                d.addElement(e.nextElement());
            }
        }
	gr.finishCount();
        
        if (index==Groups.TYPE_SEARCH_RESULT) return; ;//don't count this contacts
        if (index==Groups.TYPE_NOT_IN_LIST) return; ;//don't count this contacts
        
	rosterContacts+=gr.getNContacts();
	rosterOnline+=gr.getOnlines();
    }

    public Group getGroup(int Index) {
        return (Group)groups.elementAt(Index);
    }
    
    public Enumeration elements(){
        return groups.elements();
    }
    
    public Group getGroup(String name) {
        for (Enumeration e=groups.elements();e.hasMoreElements();){
            Group grp=(Group)e.nextElement();
            if (name.equals(grp.name)) return grp;
        }
        return null;
    }
    public Group addGroup(String name, boolean sort) {
        Group ng=new Group(name);
        int index=TYPE_COMMON+1;
        if (!sort) index=groups.size();
        String lName=name.toLowerCase();
        
        while (index<groups.size()) {
            String grpname=((Group)(groups.elementAt(index))).getName();
            int cmp=lName.compareTo( grpname.toLowerCase() );
            if (cmp<0) {
                ng.index=index;
                groups.insertElementAt(ng, index);
                return ng;
            }
            index++;
        }
        
        ng.index=index;
        groups.addElement(ng);
        return ng;
    }
    
    public Group addGroup(Group group) {
	group.index=groups.size();
        groups.addElement(group);
        return group;
    }

    public Vector getRosterGroupNames(){
        Vector s=new Vector();
        for (int i=Groups.TYPE_COMMON; i<groups.size(); i++) {
	    Group grp=(Group) groups.elementAt(i);
	    if (grp.imageExpandedIndex==RosterIcons.ICON_EXPANDED_INDEX)
            s.addElement(grp.name);
        }
        s.addElement(Groups.IGNORE_GROUP);
        return s;
    }
    public int getCount() {return groups.size();}

    public int getRosterContacts() { return rosterContacts; }
    public int getRosterOnline() { return rosterOnline; }

    void removeGroup(Group g) {
        groups.removeElement(g);
    }
    
}
/*
 * Jid.java
 *
 * Created on 4 Март 2005 г., 1:25
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

/**
 *
 * @author Eugene Stahov
 */
public class Jid {
    
    private String fullJid;
    private int resourcePos;
    
    /** Creates a new instance of Jid */
    public Jid(String s) {
        setJid(s);
    }
    
    public void setJid(String s){
        fullJid=s;
        resourcePos=fullJid.indexOf('/');
        if (resourcePos<0) resourcePos=fullJid.length();
    }
    /** Compares two Jids */
    public boolean equals(Jid j, boolean compareResource) {
        if (j==null) return false;
        
        String cj=j.fullJid;
        // игнорируем регистр jid,
        if (resourcePos!=j.resourcePos) return false;
        if (!fullJid.regionMatches(true,0,cj,0,resourcePos)) return false;
        if (!compareResource) return true;
        
        //учитываем регистр ресурсов и длину
        int compareLen=fullJid.length();
        if (compareLen!=j.fullJid.length()) return false;

        // сравнение только ресурсов
        compareLen-=resourcePos;
        return fullJid.regionMatches(false,resourcePos,cj,resourcePos,compareLen);
        //int compareLen=(compareResource)?(j.getJidFull().length()):resourcePos;
        //return fullJid.regionMatches(true,0,j.fullJid,0,compareLen);
    }
    
    
    /** проверка jid на "транспорт" */
    public boolean isTransport(){
        return fullJid.indexOf('@')==-1;
    }
    /** проверка наличия ресурса */
    public boolean hasResource(){
        return fullJid.length()!=resourcePos;
    }
    
    /** выделение транспорта */
    public String getTransport(){
        try {
            int beginIndex=fullJid.indexOf('@')+1;
            int endIndex=fullJid.indexOf('.',beginIndex);
            return fullJid.substring(beginIndex, endIndex);
        } catch (Exception e) {
            return "-";
        }
    }
    
    /** выделение ресурса со слэшем */
    public String getResource(){
        return fullJid.substring(resourcePos);
    }
    
    /** выделение username */
    /*public String getUser(){
        return substr(this,(char)0,'@');
    }*/
    
    /** выделение имени без ресурса */
    public String getBareJid(){
        return fullJid.substring(0,resourcePos);
    }
    
    /** выделение jid/resource */
    public String getJid(){
        return fullJid;
    }
    
    public static String getBareJid(String jid) {
        int rp=jid.indexOf('/');
        return (rp<0)? jid: jid.substring(0,rp);
    }
}
/*
 * MessageEdit.java
 *
 * Created on 20 Февраль 2005 пїЅ., 21:20
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import Conference.AppendNick;
import archive.ArchiveList;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.VirtualList;

/**
 *
 * @author Eugene Stahov
 */
public class MessageEdit 
        implements CommandListener, Runnable
{
    
    private Display display;
    private Displayable parentView;
    private TextBox t;
    private String body;
    private String subj;
    
    private Contact to;
    private Command cmdSuspend=new Command(SR.MS_SUSPEND, Command.BACK,90);
    private Command cmdCancel=new Command(SR.MS_CANCEL, Command.SCREEN,99);
    private Command cmdSend=new Command(SR.MS_SEND, Command.OK /*Command.SCREEN*/,1);
    private Command cmdSmile=new Command(SR.MS_ADD_SMILE, Command.SCREEN,2);
    private Command cmdInsNick=new Command(SR.MS_NICKNAMES,Command.SCREEN,3);
    private Command cmdInsMe=new Command(SR.MS_SLASHME, Command.SCREEN, 4); ; // /me
    private Command cmdSubj=new Command(SR.MS_SET_SUBJECT, Command.SCREEN, 10);
    private Command cmdPaste=new Command(SR.MS_ARCHIVE, Command.SCREEN, 5);
    private Command cmdABC=new Command("Abc", Command.SCREEN, 15);
    private Command cmdAbc=new Command("abc", Command.SCREEN, 15);
    
    private boolean composing=true;
    
    //private Command cmdSubject=new Command("Subject",Command.SCREEN,10);
    
    /** Creates a new instance of MessageEdit */
    public MessageEdit(Display display, Contact to, String body) {
        this.to=to;
        this.display=display;
        parentView=display.getCurrent();
        
        try {
            t=new TextBox(to.toString(),null,1024, TextField.ANY);
        } catch (Exception e) {
            t=new TextBox(to.toString(),null,500, TextField.ANY);
        }
        
        try {
            if (body!=null) t.setString(body);
        } catch (Exception e) {
            t.setString("<large text>");
        }
        t.addCommand(cmdSend);
        t.addCommand(cmdInsMe);
        t.addCommand(cmdSmile);
        if (to.origin>=Contact.ORIGIN_GROUPCHAT)
            t.addCommand(cmdInsNick);
	t.addCommand(cmdPaste);
        t.addCommand(cmdSuspend);
        t.addCommand(cmdCancel);
        t.setCommandListener(this);
        
        if (to.origin==Contact.ORIGIN_GROUPCHAT)
            t.addCommand(cmdSubj);
        
        //t.setInitialInputMode("MIDP_LOWERCASE_LATIN");
        new Thread(this).start() ; // composing
        
        setInitialCaps(Config.getInstance().capsState);
        
        display.setCurrent(t);
    }
    
    public void addText(String s) {
        //t.insert(s, t.getCaretPosition());
        if ( t.size()>0 )
        if ( !t.getString().endsWith(" ") ) append(" ");
        append(s);  // теперь вставка происходит всегда в конец строки
        append(" "); // хвостовой пробел    
    }
    
    private void append(String s) { t.insert(s, t.size()); }
    
    public void setParentView(Displayable parentView){
        this.parentView=parentView;
    }
    
    public void commandAction(Command c, Displayable d){
        body=t.getString();
        if (body.length()==0) body=null;
        
        if (c==cmdInsMe) { t.insert("/me ", 0); return; }
        if (c==cmdSmile) { new SmilePicker(display, this); return; }
        if (c==cmdInsNick) { new AppendNick(display, to); return; }
        if (c==cmdAbc) {setInitialCaps(false); return; }
        if (c==cmdABC) {setInitialCaps(true); return; }
	if (c==cmdPaste) { new ArchiveList(display, t); return; }
        
        if (c==cmdCancel) { 
            composing=false; 
            body=null; 
        }
        if (c==cmdSuspend) { 
            composing=false; 
            to.msgSuspended=body; 
            body=null;
        }
        if (c==cmdSend && body==null) return;
        if (c==cmdSubj) {
            if (body==null) return;
            subj=body;
            body="/me has set the topic to: "+subj;
        }
        // message/composing sending
        destroyView();
        new Thread(this).start();
        return; 
    }
    
    
    public void run(){
        Roster r=StaticData.getInstance().roster;
        int comp=0; // composing event off
        
        if (body!=null /*|| subj!=null*/ ) {
            String from=StaticData.getInstance().account.toString();
            Msg msg=new Msg(Msg.MESSAGE_TYPE_OUT,from,subj,body);
            // не добавляем в групчат свои сообщения
            // не шлём composing
            if (to.origin!=Contact.ORIGIN_GROUPCHAT) {
                to.addMessage(msg);
                comp=1; // composing event in message
            }
            
        } else if (to.acceptComposing) comp=(composing)? 1:2;
        
        if (!Config.getInstance().eventComposing) comp=0;
        
        try {
            if (body!=null /*|| subj!=null*/ || comp>0)
            r.sendMessage(to, body, subj, comp);
        } catch (Exception e) {
            e.printStackTrace();
        }
        ((VirtualList)parentView).redraw();
    }
    
    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView);
    }

    private void setInitialCaps(boolean state) {
//#if (!MIDP1)
        t.setConstraints(state? TextField.INITIAL_CAPS_SENTENCE: TextField.ANY);
        t.removeCommand(state? cmdABC: cmdAbc);
        t.addCommand(state? cmdAbc: cmdABC);
        Config.getInstance().capsState=state;
//#endif
    }

}
/*
 * msg.java
 *
 * Created on 6 Январь 2005 г., 19:20
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.*;
import javax.microedition.lcdui.Font;
import ui.Colors;
import ui.Time;
import Client.ContactMessageList;
import javax.microedition.lcdui.Image;

/**
 *
 * @author Eugene Stahov
 */
public class Msg //implements MessageList.Element
{
    // without signaling
    public final static int MESSAGE_TYPE_OUT=1;
    public final static int MESSAGE_TYPE_PRESENCE=2;
    public final static int MESSAGE_TYPE_HISTORY=3;
    // with signaling
    public final static int MESSAGE_TYPE_IN=10;
    public final static int MESSAGE_TYPE_HEADLINE=11;
    public final static int MESSAGE_TYPE_ERROR=11;
    public final static int MESSAGE_TYPE_AUTH=15;

    private boolean highlite;
    
    /** Creates a new instance of msg */
    public Msg(int messageType, String from, String subj, String body) {
        this.messageType=messageType;
        this.from=from;
        this.body=body;
        this.subject=subj;
        this.dateGmt=Time.localTime();
        if (messageType>=MESSAGE_TYPE_IN) unread=true;
        if (messageType==MESSAGE_TYPE_PRESENCE)
            itemCollapsed=true;
    }
    
    public void onSelect(){}
    public String getMsgHeader(){
        return getTime()+from; 
    }
    public String getTime(){
        return '['+Time.timeString(dateGmt)+"] "; 
    }
    public String getDayTime(){
        return '['+Time.dayString(dateGmt)+Time.timeString(dateGmt)+"] "; 
    }
    //private TimeZone tz(){ return StaticData.getInstance().config.tz;}
    
    public int getColor() {
        if (highlite) 
            if (Config.getInstance().ghostMotor) return Colors.MSG_HIGHLIGHT;
        switch (messageType) {
            case MESSAGE_TYPE_IN: return Colors.MESSAGE_IN;
            case MESSAGE_TYPE_OUT: return Colors.MESSAGE_OUT;
            case MESSAGE_TYPE_PRESENCE: return Colors.MESSAGE_PRESENCE;
            case MESSAGE_TYPE_AUTH: return Colors.MESSAGE_AUTH;
            case MESSAGE_TYPE_HISTORY: return Colors.MESSAGE_HISTORY;
        }
        return 0;
    }
    public String toString(){
        return (messageType==MESSAGE_TYPE_PRESENCE)?getTime()+body:body; 
    }
    
    public boolean isPresence() { return messageType==MESSAGE_TYPE_PRESENCE; }
    
    public int messageType;
    
    /** Отправитель сообщения */
    public String from;
    
    /** Тема сообщения */
    public String subject;

    /** Тело сообщения */
    private String body;

    /** Дата сообщения */
    public long dateGmt;
    
    public boolean unread = false;
    
    public boolean itemCollapsed;
    public int  itemHeight=14;
    
    public void serialize(DataOutputStream os) throws IOException {
	os.writeUTF(from);
	os.writeUTF(body);
	os.writeLong(dateGmt);
	if (subject!=null) os.writeUTF(subject);
    }
    public Msg (DataInputStream is) throws IOException {
	from=is.readUTF();
	body=is.readUTF();
	dateGmt=is.readLong();
	try { subject=is.readUTF(); } catch (Exception e) { subject=null; }
    }

    public String getBody() { return body; }

    void setHighlite(boolean state) { highlite=state; }

    public boolean isHighlited() { return highlite; }
}
/*
 * NvStorage.java
 *
 * Created on 22 Март 2005 г., 22:56
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import com.alsutton.jabber.JabberDataBlock;
import java.io.*;
import util.strconv;

//#if !(USE_SIEMENS_FILES)
import javax.microedition.rms.*;
//#else
//# import com.siemens.mp.io.File;
//#endif

/**
 *
 * @author Eugene Stahov
 */
public class NvStorage {
    
    private static final int PATH_CFG=0;
    private static final int PATH_MSG=1;
    
    /**
     * Opens RMS record from named store
     * and returns it as DataInputStream
     */
    static public DataInputStream ReadFileRecord(String name, int index){
        DataInputStream istream=null;
        
//#if !(USE_SIEMENS_FILES)
        RecordStore recordStore=null;
        try {
            
            recordStore = RecordStore.openRecordStore(name, false);
            byte[] b=recordStore.getRecord(index+1);
            
            if (b.length!=0)         
            istream=new DataInputStream( new ByteArrayInputStream(b) );
            
        } catch (Exception e) { }
        finally { 
            try { recordStore.closeRecordStore(); } catch (Exception e) {} }
//#else
//# 
//#         try {
//#         File f=new File();
//#         
//#         String n=getPath(name, PATH_CFG);
//#         System.out.println("Read "+n);
//#         int descriptor=f.open(n);
//#         if (descriptor<0) return null;
//#         int len=f.length(descriptor);
//#         if (len<1) return null; 
//#         
//#         byte[] b=new byte[len];
//#         f.read(descriptor, b, 0, len);
//#         f.close(descriptor);
//#         
//#         istream=new DataInputStream( new ByteArrayInputStream(b) );
//#         } catch (Exception e) { e.printStackTrace(); }
//#         
//#endif
        
        return istream;
    }
//#if USE_SIEMENS_FILES
//#     public static String getPath(String name, int path_index){
//#         
//#         String path=null;
//#         switch (path_index) {
//#             case PATH_CFG: path=Config.getInstance().siemensCfgPath; break;
//#             case PATH_MSG: path=Config.getInstance().msgPath; break;
//#         }
//#         //System.out.println("path="+path);
//#         //System.out.println("path="+path+name);
//#         // verification
//#         
//#         // временно заблокирована проверка валидности пути. для C55
//#         /*
//#         try {
//#             File f=new File();
//#             if (!f.isDirectory(path)) return name;
//#         } catch (Exception e) { 
//#             //e.printStackTrace(); 
//#             return name; 
//#         } 
//#          */
//#         return path+name;
//#     }
//#     
//#endif

    private static ByteArrayOutputStream baos;
    /** Creates DataOutputStream based on ByteOutputStream  */
    static public DataOutputStream CreateDataOutputStream(){
        if (baos!=null) return null;
        DataOutputStream ostream=new DataOutputStream( baos=new ByteArrayOutputStream());
        return ostream;
    }
    
    static public boolean writeFileRecord (
            DataOutputStream ostream, 
            String name, int index, 
            boolean rewrite)
    {
        ByteArrayOutputStream lbaos=baos;
        baos=null; // освободим для следующего
        byte[] b=lbaos.toByteArray();
        
//#if !(USE_SIEMENS_FILES)
        try {
            if (rewrite) RecordStore.deleteRecordStore(name);
        } catch (Exception e) {}

        RecordStore recordStore;
        try {
            recordStore = RecordStore.openRecordStore(name, true);
        } catch (Exception e) { return false;}
        
        try {
            try {
                recordStore.setRecord(index+1, b, 0, b.length);
            } catch (InvalidRecordIDException e) { recordStore.addRecord(b, 0, b.length); }
            recordStore.closeRecordStore();
            ostream.close();
        } catch (Exception e) { e.printStackTrace(); return false; }
//#else
//#         File f=new File();
//#         String n=getPath(name, PATH_CFG);
//#         System.out.println("Write "+n);
//# 
//#         try {
//#             if (rewrite) f.delete(n);
//#         } catch (Exception e) {}
//# 
//#         int descriptor;
//#         try {
//#             descriptor=f.open(n);
//#             f.write(descriptor, b, 0, b.length);
//#             f.close(descriptor);
//#         } catch (Exception e) { e.printStackTrace(); return false; }
//#endif
        return true;
    }
    
//#if USE_SIEMENS_FILES
//#     public final static boolean appendFile(String URL, String append_data){
//#         try{
//#             File file1 = new File();
//#             int fd = file1.open(
//#                     //getPath(strconv.convUnicodeToCp1251(URL+".txt"), PATH_MSG));
//#                     getPath(URL+".txt", PATH_MSG));
//#             byte abyte0[] = (strconv.convUnicodeToCp1251(append_data)).getBytes();
//#             file1.seek(fd, file1.length(fd));
//#             file1.write(fd, abyte0, 0, abyte0.length);
//#             file1.close(fd);
//# 
//#         } catch (Exception e) {
//#             e.printStackTrace();
//#             return false;   //облом
//#         }
//#         return true;
//#     }
//#endif
    
//#if USE_LOGGER
//--    public final static void log(String logMsg){
//--        if (StaticData.getInstance().config.logMsg) { 
//--            logS("MSG="); 
//--            logS(logMsg); 
//--            logCrLf(); 
//--        }
//--    }
//--    public final static void log(JabberDataBlock data, boolean incoming){
//--        if (StaticData.getInstance().config.logStream)
//--        {
//--            logS(incoming?"RECV=":"SENT=");
//--            logCrLf();
//--            data.formatOut("");
//--        }
//--    }
//--    public final static void log(Exception e, String location){
//--        if (StaticData.getInstance().config.logEx)
//--        {
//--            logS("EXCEPTION="+e.getMessage()+" @"+location);
//--            logCrLf();
//--        }
//--    }
//--    
//--    synchronized public final static void logS(String logMsg){
//--        appendFile("_syslog", logMsg);
//--    }
//--    public final static void logCrLf(){ logS("\n"); }
//#endif
}
/*
 * Roster.java
 *
 * Created on 6 Январь 2005 г., 19:16
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

//TODO: упростить обработку исключений для theStream.send

package Client;

import Conference.ConferenceGroup;
import Conference.MucContact;
import Conference.QueryConfigForm;
import Conference.affiliation.Affiliations;
import archive.ArchiveList;
import images.RosterIcons;
import locale.SR;
import login.LoginListener;
import login.NonSASLAuth;
import login.SASLAuth;
import midlet.Bombus;
import vcard.VCard;
import vcard.vCardForm;
import com.alsutton.jabber.*;
import com.alsutton.jabber.datablocks.*;
import java.io.*;
import java.util.*;
import javax.microedition.lcdui.*;
import javax.microedition.midlet.MIDlet;
//import javax.microedition.media.*;
//import Client.Contact.*;
import ui.*;
import ServiceDiscovery.ServiceDiscovery;
import Conference.ConferenceForm;
import PrivacyLists.PrivacySelect;
import Client.Config;

//import Client.msg.*;

/**
 *
 * @author Eugene Stahov
 */
//public class Roster implements JabberListener, VList.Callback{
public class Roster
        extends VirtualList
        implements
        JabberListener,
        CommandListener,
        Runnable,
        LoginListener
        //ContactEdit.StoreContact
        //Thread
{
    
    
    private Jid myJid;
    
    /**
     * The stream representing the connection to ther server
     */
    public JabberStream theStream ;
        
    int messageCount;
    
    public Object messageIcon;
   
    boolean reconnect=false;
    boolean querysign=false;
    
    boolean storepresence=true;
    
    public int myStatus=Presence.PRESENCE_OFFLINE;
    
    private Vector hContacts;
    private Vector vContacts;
    
    private Vector paintVContacts;  // для атомных операций.
    
    public Groups groups;
    
    public Vector bookmarks;

    
    private Command cmdActions=new Command(SR.MS_ITEM_ACTIONS, Command.SCREEN, 1);
    private Command cmdStatus=new Command(SR.MS_STATUS_MENU, Command.SCREEN, 2);
    private Command cmdActiveContact=new Command(SR.MS_ACTIVE_CONTACTS, Command.SCREEN, 3);
    private Command cmdAlert=new Command(SR.MS_ALERT_PROFILE_CMD, Command.SCREEN, 8);
    private Command cmdConference=new Command(SR.MS_CONFERENCE, Command.SCREEN, 10);
    private Command cmdArchive=new Command(SR.MS_ARCHIVE, Command.SCREEN, 10);
    private Command cmdAdd=new Command(SR.MS_ADD_CONTACT, Command.SCREEN, 12);
    private Command cmdTools=new Command(SR.MS_TOOLS, Command.SCREEN, 14);    
    private Command cmdAccount=new Command(SR.MS_ACCOUNT_, Command.SCREEN, 15);
    private Command cmdInfo=new Command(SR.MS_ABOUT, Command.SCREEN, 80);
    private Command cmdMinimize=new Command(SR.MS_APP_MINIMIZE, Command.SCREEN, 90);
    private Command cmdQuit=new Command(SR.MS_APP_QUIT, Command.SCREEN, 99);
    
    private Config cf;
    private StaticData sd=StaticData.getInstance();

//#if (MOTOROLA_BACKLIGHT)
    private int blState=Integer.MAX_VALUE;

//#endif

//#if SASL
    private String token;

//#endif
    
    private long lastMessageTime=Time.localTime();
    //public JabberBlockListener discoveryListener;
    
    /**
     * Creates a new instance of Roster
     * Sets up the stream to the server and adds this class as a listener
     */
    public Roster(Display display /*, boolean selAccount*/) {
        super();

	setProgress(24);
        //setTitleImages(StaticData.getInstance().rosterIcons);
                
        this.display=display;
        
        cf=Config.getInstance();
        
        //msgNotify=new EventNotify(display, Profile.getProfile(0) );
        Title title=new Title(4, null, null);
        setTitleItem(title);
        title.addRAlign();
        title.addElement(null);
        title.addElement(null);
        //displayStatus();
        
        //l.setTitleImgL(6); //connect
        hContacts=new Vector();
        groups=new Groups();
        
        vContacts=new Vector(); // just for displaying
        
        addCommand(cmdStatus);
        addCommand(cmdActions);
        addCommand(cmdActiveContact);
        addCommand(cmdAlert);
        addCommand(cmdAdd);
        //addCommand(cmdServiceDiscovery);
        addCommand(cmdConference);
        //addCommand(cmdPrivacy);
        addCommand(cmdTools);
        addCommand(cmdArchive);
        addCommand(cmdInfo);
        addCommand(cmdAccount);

        addCommand(cmdQuit);
        
        
        addOptionCommands();
        //moveCursorTo(0);
        setCommandListener(this);
        //resetStrCache();
        
        //if (visible) display.setCurrent(this);
        /*if (selAccount) {
            new AccountSelect(display);
        } else {
            // connect whithout account select
            Account.launchAccount();
        }*/
	//setRosterTitle("offline");
	updateTitle();
	
        SplashScreen.getInstance().setExit(display, this);
    }
    
    void addOptionCommands(){
        if (cf.allowMinimize) addCommand(cmdMinimize);
        //Config cf=StaticData.getInstance().config;
        //        if (cf.showOfflineContacts) {
        //            addCommand(cmdHideOfflines);
        //            removeCommand(cmdShowOfflines);
        //        } else {
        //            addCommand(cmdShowOfflines);
        //            removeCommand(cmdHideOfflines);
        //        }
    }
    public void setProgress(String pgs,int percent){
        SplashScreen.getInstance().setProgress(pgs, percent);
        setRosterTitle(pgs);
        redraw();
    }
    public void setProgress(int percent){
        SplashScreen.getInstance().setProgress(percent);
        //redraw();
    }
    
    private void setRosterTitle(String s){
        getTitleItem().setElementAt(s, 3);
    }
    
    private int rscaler;
    private int rpercent;
    
    public void rosterItemNotify(){
        rscaler++;
        if (rscaler<4) return;
        rscaler=0;
        rpercent++;
        if (rpercent==100) rpercent=60;
        SplashScreen.getInstance().setProgress(rpercent);
    }
    
    // establishing connection process
    public void run(){
        Iq.setXmlLang(SR.MS_XMLLANG);
        setQuerySign(true);
        setProgress(25);
	if (!reconnect) {
	    resetRoster();
	};
        setProgress(26);
        
        //logoff();
        try {
            Account a=sd.account;
//#if SASL_XGOOGLETOKEN
            if (a.isSASL() && a.getServer().startsWith("gmail")) {
                setProgress(SR.MS_TOKEN, 30);
                token=new SASLAuth(a, null, this, null).responseXGoogleToken();
                if (token==null) throw new Exception("Can't get Google token");
            }
//#endif
            setProgress(SR.MS_CONNECT_TO+a.getServer(), 30);
            SR.loaded();
            theStream= a.openJabberStream();
            setProgress(SR.MS_OPENING_STREAM, 40);
            theStream.setJabberListener( this );
        } catch( Exception e ) {
            setProgress(SR.MS_FAILED, 0);
            reconnect=false;
            myStatus=Presence.PRESENCE_OFFLINE;
            e.printStackTrace();
            String error=e.getClass().getName()+"\n"+e.getMessage();
            errorLog( error );
            setQuerySign(false);
            redraw();
            //l.setTitleImgL(0);//offline
        }
        //l.setCallback(this);
    }

    public void resetRoster() {
	synchronized (hContacts) {
	    hContacts=new Vector();
	    groups=new Groups();
	    vContacts=new Vector(); // just for displaying
	    bookmarks=null;
	}
	myJid=new Jid(sd.account.getJid());
	updateContact(sd.account.getNickName(), myJid.getBareJid(), Groups.SELF_GROUP, "self", false);
	
	System.gc();
    }
    
    public void errorLog(String s){
        if (s==null) return;
        if (s.length()==0) return;
        Alert error=new Alert(SR.MS_ERROR_, s, null, null);
        //error.setTimeout(30000);
        display.setCurrent(error, display.getCurrent());
        Msg m=new Msg(Msg.MESSAGE_TYPE_OUT, myJid.getJid(), "Error", s);
        messageStore(m);
    }
    
    public void beginPaint() {
        paintVContacts=vContacts;
    }
    
    public VirtualElement getItemRef(int Index){
        return (VirtualElement) paintVContacts.elementAt(Index);
    }
    
    public int getItemCount(){
        return paintVContacts.size();
    };
    
    private void updateTitle(){
        int s=querysign?RosterIcons.ICON_PROGRESS_INDEX:myStatus;
        int profile=cf.profile;//StaticData.getInstance().config.profile;
        Object en=(profile>1)? new Integer(profile+RosterIcons.ICON_PROFILE_INDEX):null;
        Title title=(Title) getTitleItem();
        title.setElementAt(new Integer(s), 2);
        title.setElementAt(en, 5);
        if (messageCount==0) {
            messageIcon=null;
            title.setElementAt(null,1);
        } else {
            messageIcon=new Integer(RosterIcons.ICON_MESSAGE_INDEX);
            title.setElementAt(" "+messageCount+" ",1);
        }
        title.setElementAt(messageIcon, 0);
    }
    
    boolean countNewMsgs() {
        int m=0;
        synchronized (hContacts) {
            for (Enumeration e=hContacts.elements();e.hasMoreElements();){
                Contact c=(Contact)e.nextElement();
                m+=c.getNewMsgsCount();
            }
        }
        messageCount=m;
//#if USE_LED_PATTERN
//--                int pattern=cf.m55LedPattern;
//--                if (pattern>0) EventNotify.leds(pattern-1, m>0);
//#endif
        updateTitle();
        return (m>0);
    }
    
    public void cleanupSearch(){
        int index=0;
        synchronized (hContacts) {
            while (index<hContacts.size()) {
                if ( ((Contact) hContacts.elementAt(index)).getGroupType()==Groups.TYPE_SEARCH_RESULT )
                    hContacts.removeElementAt(index);
                else index++;
            }
        }
        reEnumRoster();
    }
    
    public void cleanupGroup(){
        Group g=(Group)getFocusedObject();
        if (g==null) return;
        if (!g.collapsed) return;
        
        if (g instanceof ConferenceGroup) {
            ConferenceGroup cg= (ConferenceGroup) g;
            if (cg.getSelfContact().status==Presence.PRESENCE_OFFLINE)
                cg.getConference().status=Presence.PRESENCE_OFFLINE;
        }
        //int gi=g.index;

        int index=0;

        int onlineContacts=0;
        
        synchronized (hContacts) {
            while (index<hContacts.size()) {
                Contact contact=(Contact)hContacts.elementAt(index);
                if (contact.inGroup(g)) {
                    if ( contact.origin>Contact.ORIGIN_ROSTERRES
                         && contact.status==Presence.PRESENCE_OFFLINE
                         && contact.getNewMsgsCount()==0 )
                        hContacts.removeElementAt(index);
                    else { 
                        index++;
                        onlineContacts++;
                    } 
                }
                else index++; 
            }
            if (onlineContacts==0) {
                if (g.index>Groups.TYPE_COMMON) groups.removeGroup(g);
            }
        }
    }
    
    ReEnumerator reEnumerator=null;
    
    public void reEnumRoster(){
        if (reEnumerator==null) reEnumerator=new ReEnumerator();
        reEnumerator.queueEnum();
    }
    
    
    public Vector getHContacts() {return hContacts;}
    
    public final void updateContact(final String nick, final String jid, final String grpName, String subscr, boolean ask) {
        // called only on roster read
        int status=Presence.PRESENCE_OFFLINE;
        if (subscr.equals("none")) status=Presence.PRESENCE_UNKNOWN;
        if (ask) status=Presence.PRESENCE_ASK;
        //if (subscr.equals("remove")) status=Presence.PRESENCE_TRASH;
        if (subscr.equals("remove")) status=-1;
        
        Jid J=new Jid(jid);
        Contact c=findContact(J,false); // пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅ bare jid
        if (c==null) {
            c=new Contact(nick, jid, Presence.PRESENCE_OFFLINE, null);
            addContact(c);
        }
        for (Enumeration e=hContacts.elements();e.hasMoreElements();) {
            c=(Contact)e.nextElement();
            if (c.jid.equals(J,false)) {
                Group group= (c.jid.isTransport())? 
                    groups.getGroup(Groups.TYPE_TRANSP) :
                    groups.getGroup(grpName);
                if (group==null) {
                    group=groups.addGroup(grpName, true);
                }
                c.nick=nick;
                c.setGroup(group);
                c.subscr=subscr;
                c.offline_type=status;
                c.ask_subscribe=ask;
                //if (status==Presence.PRESENCE_TRASH) c.status=status;
                //if (status!=Presence.PRESENCE_OFFLINE) c.status=status;
                c.setSortKey((nick==null)? jid:nick);
            }
        }
        if (status<0) removeTrash();
    }
    
    private final void removeTrash(){
        int index=0;
        synchronized (hContacts) {
            while (index<hContacts.size()) {
                Contact c=(Contact)hContacts.elementAt(index);
                if (c.offline_type<0) {
                    hContacts.removeElementAt(index);
                } else index++;
            }
            countNewMsgs();
        }
    }

    private MucContact findMucContact(Jid jid) {
        Contact contact=findContact(jid, true);
        try {
            return (MucContact) contact;
        } catch (Exception e) {
            // drop buggy bookmark in roster
            hContacts.removeElement(contact);
            return null;
        }
    }
    
    public final ConferenceGroup initMuc(String from, String joinPassword){
        // muc message
        int ri=from.indexOf('@');
        int rp=from.indexOf('/');
        String room=from.substring(0,ri);
        String roomJid=from.substring(0,rp).toLowerCase();
        
        
        ConferenceGroup grp=(ConferenceGroup)groups.getGroup(roomJid);
        
        
        // creating room
        
        if (grp==null) // we hasn't joined this room yet
            groups.addGroup(grp=new ConferenceGroup(roomJid, room) );
        grp.password=joinPassword;
        
        MucContact c=findMucContact( new Jid(from.substring(0, rp)) );
        
        if (c==null) {
            c=new MucContact(room, roomJid);
            addContact(c);
        }
        c.status=Presence.PRESENCE_ONLINE;
        c.transport=RosterIcons.ICON_GROUPCHAT_INDEX; //FIXME: убрать хардкод
        c.bareJid=from;
        c.origin=Contact.ORIGIN_GROUPCHAT;
        //c.priority=99;
        //c.key1=0;
        grp.conferenceJoinTime=Time.localTime();
        grp.setConference(c);
        c.setGroup(grp);
        
        // creating self-contact
        String nick=from.substring(rp+1);
        c=grp.getSelfContact();
        if (c==null)
            c=findMucContact( new Jid(from) );

        if (c!=null) if (c.status==Presence.PRESENCE_OFFLINE) { 
            c.nick=nick;
            c.jid.setJid(from);
            c.bareJid=from;
        }
        
        if (c==null) {
            c=new MucContact(nick, from);
            addContact(c);
        }
        
        
        grp.setSelfContact(c);
        c.setGroup(grp);
        c.origin=Contact.ORIGIN_GC_MYSELF;
        
        Contact.sort(hContacts);
        return grp;
    }
    
    public final MucContact mucContact(String from){
        // muc message
        int ri=from.indexOf('@');
        int rp=from.indexOf('/');
        String room=from.substring(0,ri);
        String roomJid=from.substring(0,rp).toLowerCase();
        

        ConferenceGroup grp=(ConferenceGroup)groups.getGroup(roomJid);
	

        
        if (grp==null) return null; // we are not joined this room
        
        MucContact c=findMucContact( new Jid(from) );
        
        if (c==null) {
            c=new MucContact(from.substring(rp+1), from);
            addContact(c);
            c.origin=Contact.ORIGIN_GC_MEMBER;
        }
        
        c.setGroup(grp);
        Contact.sort(hContacts);
        return c;
    }
    
    public final Contact getContact(final String jid, boolean createInNIL) {
        
        Jid J=new Jid(jid);

        // проверим наличие по полной строке
        Contact c=findContact(J, true); 
        if (c!=null) 
            return c;

        // проверим наличие без ресурсов
        c=findContact(J, false);
        if (c==null) {
            if (!createInNIL) return null;
            c=new Contact(null, jid, Presence.PRESENCE_OFFLINE, "not-in-list");
	    c.bareJid=J.getBareJid();
            c.origin=Contact.ORIGIN_PRESENCE;
            c.setGroup(groups.getGroup(Groups.TYPE_NOT_IN_LIST));
            addContact(c);
        } else {
            // здесь jid с новым ресурсом
            if (c.origin==Contact.ORIGIN_ROSTER) {
                c.origin=Contact.ORIGIN_ROSTERRES;
                c.status=Presence.PRESENCE_OFFLINE;
                c.jid=J;
                //System.out.println("add resource");
            } else {
                c=c.clone(J, Presence.PRESENCE_OFFLINE);
                addContact(c);
                //System.out.println("cloned");
            }
        }
        Contact.sort(hContacts);
        return c;
    }
    
    public void addContact(Contact c) {
        synchronized (hContacts) { hContacts.addElement(c); }
    }
    

    public final Contact findContact(final Jid j, final boolean compareResources) {
        synchronized (hContacts) {
            for (Enumeration e=hContacts.elements();e.hasMoreElements();){
                Contact c=(Contact)e.nextElement();
                if (c.jid.equals(j,compareResources)) return c;
            }
        }
        return null;
    }
    
    /**
     * Method to inform the server we are now online
     */
    
    public void sendPresence(int status) {
        myStatus=status;
        setQuerySign(false);
        if (myStatus==Presence.PRESENCE_OFFLINE) {
            synchronized(hContacts) {
                for (Enumeration e=hContacts.elements(); e.hasMoreElements();){
                    Contact c=(Contact)e.nextElement();
                    //if (c.status<Presence.PRESENCE_UNKNOWN)
                        c.status=Presence.PRESENCE_OFFLINE; // keep error & unknown
                }
            }
        }
        //Vector v=sd.statusList;//StaticData.getInstance().statusList;
        //ExtendedStatus es=null;
        
        // reconnect if disconnected        
        if (myStatus!=Presence.PRESENCE_OFFLINE && theStream==null ) {
            reconnect=(hContacts.size()>1);
            redraw();
            
            new Thread(this).start();
            return;
        }
        
        // send presence
        ExtendedStatus es= StatusList.getInstance().getStatus(myStatus);
        Presence presence = new Presence(myStatus, es.getPriority(), es.getMessage());
        if (theStream!=null) {
            if (!StaticData.getInstance().account.isMucOnly() )
		theStream.send( presence );
            
            sendConferencePresence();

            // disconnect
            if (status==Presence.PRESENCE_OFFLINE) {
                try {
                    theStream.close();
                } catch (Exception e) { e.printStackTrace(); }
                theStream=null;
                System.gc();
            }
        }
        Contact c=selfContact();
        c.status=myStatus;
        Contact.sort(hContacts);
        
        reEnumRoster();
    }
    
    public Contact selfContact() {
	return getContact(myJid.getJid(), true);
    }
    
    public void sendConferencePresence() {
        ExtendedStatus es= StatusList.getInstance().getStatus(myStatus);
        for (Enumeration e=hContacts.elements(); e.hasMoreElements();) {
            Contact c=(Contact) e.nextElement();
            if (c.origin!=Contact.ORIGIN_GROUPCHAT) continue;
            if (c.status==Presence.PRESENCE_OFFLINE) continue;
            Presence presence = new Presence(myStatus, es.getPriority(), es.getMessage());
            presence.setAttribute("to", c.getJid());
            theStream.send(presence);
        }
    }
    
    public void sendPresence(String to, String type, JabberDataBlock child) {
        JabberDataBlock presence=new Presence(to, type);
        if (child!=null) presence.addChild(child);
        theStream.send(presence);
    }
    /**
     * Method to send a message to the specified recipient
     */
    
    public void sendMessage(Contact to, final String body, final String subject , int composingState) {
        boolean groupchat=to.origin==Contact.ORIGIN_GROUPCHAT;
        Message message = new Message( 
                to.getJid(), 
                body, 
                subject, 
                groupchat 
        );
        if (groupchat && body==null /*&& subject==null*/) return;
        if (composingState>0) {
            JabberDataBlock event=new JabberDataBlock("x", null,null);
            event.setNameSpace("jabber:x:event");
            if (body==null) event.addChild(new JabberDataBlock("id",null, null));
            if (composingState==1) {
                event.addChild("composing", null);
            }
            message.addChild(event);
        }
        //System.out.println(simpleMessage.toString());
        theStream.send( message );
        lastMessageTime=Time.localTime();
    }
    
    private Vector vCardQueue;
    public void resolveNicknames(int transportIndex){
	vCardQueue=new Vector();
	for (Enumeration e=hContacts.elements(); e.hasMoreElements();){
	    Contact k=(Contact) e.nextElement();
	    if (k.jid.isTransport()) continue;
	    if (k.transport==transportIndex && k.nick==null && k.getGroupType()>=Groups.TYPE_COMMON) {
		vCardQueue.addElement(VCard.getVCardReq(k.getJid(), "nickvc"+k.bareJid));
	    }
	}
	setQuerySign(true);
	sendVCardReq();
	
    }
    private void sendVCardReq(){
        querysign=false; 
        if (vCardQueue!=null) if (!vCardQueue.isEmpty()) {
            JabberDataBlock req=(JabberDataBlock) vCardQueue.lastElement();
            vCardQueue.removeElement(req);
            //System.out.println(k.nick);
            theStream.send(req);
            querysign=true;
        }
        updateTitle();
    }
    /**
     * Method to handle an incomming datablock.
     *
     * @param data The incomming data
     */

    public void loginFailed(String error){
        myStatus=Presence.PRESENCE_OFFLINE;
        setProgress(SR.MS_LOGIN_FAILED, 0);
        
        errorLog(error);
        
        reconnect=false;
        setQuerySign(false);
        redraw();
    }
    
    public void loginSuccess() {
        // залогинились. теперь, если был реконнект, то просто пошлём статус
        if (reconnect) {
            querysign=reconnect=false;
            sendPresence(myStatus);
            return;
        }
        
        // иначе будем читать ростер
        theStream.enableRosterNotify(true);
        rpercent=60;
        if (StaticData.getInstance().account.isMucOnly()) {
            setProgress(SR.MS_CONNECTED,100);
            try {
                reEnumRoster();
            } catch (Exception e) { e.printStackTrace(); }
            querysign=reconnect=false;
            SplashScreen.getInstance().close(); // display.setCurrent(this);
        } else {
            JabberDataBlock qr=new IqQueryRoster();
            setProgress(SR.MS_ROSTER_REQUEST, 60);
            theStream.send( qr );
        }
    }
    
    public void blockArrived( JabberDataBlock data ) {
        try {
            
            if( data instanceof Iq ) {
                String type = (String) data.getTypeAttribute();
                String id=(String) data.getAttribute("id");
                
                if (id!=null) {
                    if (id.startsWith("nickvc")) {
                        VCard vc=new VCard(data);//.getNickName();
                        String from=vc.getJid();
                        String nick=vc.getNickName();
                        
                        Contact c=findContact(new Jid(from), false);
                        
                        String group=(c.getGroupType()==Groups.TYPE_COMMON)?
                            null: c.getGroup().name;
                        if (nick!=null)  storeContact(from,nick,group, false);
                        //updateContact( nick, c.rosterJid, group, c.subscr, c.ask_subscribe);
                        sendVCardReq();
                    }
                    
                    if (id.startsWith("getvc")) {
                        setQuerySign(false);
                        VCard vcard=new VCard(data);
                        Contact c=getContact(vcard.getJid(), true);
                        if (c!=null) {
                            c.vcard=vcard;
                            new vCardForm(display, vcard, c.getGroupType()==Groups.TYPE_SELF);
                        }
                    }
                    
                    if (id.equals("getver")) {
                        String from=data.getAttribute("from");
                        String body=null;
                        if (type.equals("error")) {
                            body=SR.MS_NO_VERSION_AVAILABLE;
                            querysign=false;
                        } else if (type.equals("result")) {
                            JabberDataBlock vc=data.getChildBlock("query");
                            if (vc!=null) {
                                body=IqVersionReply.dispatchVersion(vc);
                            }
                            querysign=false;
                        }
                        
                        Msg m=new Msg(Msg.MESSAGE_TYPE_IN, from, SR.MS_CLIENT_INFO, body);
                        if (body!=null) { 
                            messageStore(m);
                            redraw();
                        }
                    }
                    
                } // id!=null
                if ( type.equals( "result" ) ) {
                    if (id.equals("getros")) {
                        // а вот и ростер подошёл :)
                        theStream.enableRosterNotify(false);

                        processRoster(data);
                        
                        setProgress(SR.MS_CONNECTED,100);
                        reEnumRoster();
                        // теперь пошлём присутствие
                        querysign=reconnect=false;
                        sendPresence(myStatus);
                        //sendPresence(Presence.PRESENCE_INVISIBLE);
                        
                        SplashScreen.getInstance().close(); // display.setCurrent(this);
                        
                    } 
                    
                } else if (type.equals("get")){
                    JabberDataBlock query=data.getChildBlock("query");
                    if (query!=null){
                        // проверяем на запрос версии клиента
                        if (query.isJabberNameSpace("jabber:iq:version"))
                            theStream.send(new IqVersionReply(data));
                        // проверяем на запрос локального времени клиента
                        else if (query.isJabberNameSpace("jabber:iq:time"))
                            theStream.send(new IqTimeReply(data));
                        // проверяем на запрос idle
                        else if (query.isJabberNameSpace("jabber:iq:last"))
                            theStream.send(new IqLast(data, lastMessageTime));
                        else replyError(data);
                    }
                } else if (type.equals("set")) {
                    processRoster(data);
                    reEnumRoster();
                }
            }
            
            // If we've received a message
            
            else if( data instanceof Message ) {
                querysign=false;
                Message message = (Message) data;
                
                String from=message.getFrom();
                String body=message.getBody().trim();    
                String oob=message.getOOB();
                if (oob!=null) body+=oob;
                if (body.length()==0) body=null; 
                String subj=message.getSubject().trim(); if (subj.length()==0) subj=null;
                String tStamp=message.getTimeStamp();
		
                int start_me=-1;    //  не добавлять ник
                String name=null;
                boolean groupchat=false;
                
                try { // type=null
		    String type=message.getTypeAttribute();
                    if (type.equals("groupchat")) {
                        groupchat=true;
                        start_me=0; // добавить ник в начало
                        int rp=from.indexOf('/');
                        
                        name=from.substring(rp+1);
                        
                        if (rp>0) from=from.substring(0, rp);
                        
                        // subject
                        if (subj!=null) {
                            if (body==null) body=subj;
                            subj=null;
                            start_me=-1; // не добавлять /me к subj
                        }
                    }
                    if (type.equals("error")) {
                        
                        String errCode=message.getChildBlock("error").getAttribute("code");
                        
                        switch (Integer.parseInt(errCode)) {
                            case 403: body=SR.MS_VIZITORS_FORBIDDEN; break;
                            case 503: break;
                            default: body=SR.MS_ERROR_+message.getChildBlock("error")+"\n"+body;
                        }
                    }
                } catch (Exception e) {}
                
                try {
                    //TODO: invitations
                    JabberDataBlock xmlns=message.findNamespace("http://jabber.org/protocol/muc#user");
                    String password=xmlns.getChildBlockText("password");
                    
                    JabberDataBlock invite=xmlns.getChildBlock("invite");
                    String inviteFrom=invite.getAttribute("from");
                    String inviteReason=invite.getChildBlockText("reason");
                            
                    String room=from+'/'+sd.account.getNickName();
                    initMuc(room, password);
                    
                    body=inviteFrom+SR.MS_IS_INVITING_YOU+from+" ("+inviteReason+')';
                    
                } catch (Exception e) {}
                
                Contact c=getContact(from, true);

                if (name==null) name=c.getName();
                // /me

                if (body!=null) {
                    if (body.startsWith("/me ")) start_me=3;
                    if (start_me>=0) {
                        StringBuffer b=new StringBuffer(name);
                        if (start_me==0) b.append("> ");
                        b.append(body.substring(start_me));
                        body=b.toString();
                    }
                }
                
                boolean compose=false;
                JabberDataBlock x=message.getChildBlock("x");
                //if (body.length()==0) body=null; 
                
                if (x!=null) {
                    compose=(x.getChildBlock("composing")!=null);
                    if (compose) c.acceptComposing=true;
                    if (body!=null) compose=false;
                    c.setComposing(compose);
                }
                redraw();

                if (body==null) return;
                
                Msg m=new Msg(Msg.MESSAGE_TYPE_IN, from, subj, body);
                if (tStamp!=null) 
                    m.dateGmt=Time.dateIso8601(tStamp);
                if (groupchat) {
                    if (c.bareJid.equals(message.getFrom())) {
                        m.messageType=Msg.MESSAGE_TYPE_OUT;
                        m.unread=false;
                    } else {
                        ConferenceGroup mucGrp=(ConferenceGroup)c.getGroup();
                        if (m.dateGmt<= ((ConferenceGroup)c.getGroup()).conferenceJoinTime) m.messageType=Msg.MESSAGE_TYPE_HISTORY;
                        // highliting messages with myNick substring
                        String myNick=mucGrp.getSelfContact().getName();
                        if (body.indexOf(myNick)>-1)   {  m.setHighlite(true);  }
                        //TODO: custom highliting dictionary
                    } 
                }
                messageStore(m);
                //Contact c=getContact(from);
                //c.msgs.addElement(m);
                //countNewMsgs();
                //setFocusTo(c);
                //redraw();
            }
            // присутствие

            else if( data instanceof Presence ) {
                if (myStatus==Presence.PRESENCE_OFFLINE) return;
                Presence pr= (Presence) data;
                
                String from=pr.getFrom();
                pr.dispathch();
                int ti=pr.getTypeIndex();
                //PresenceContact(from, ti);
                Msg m=new Msg(
                        (ti==Presence.PRESENCE_AUTH)?
                            Msg.MESSAGE_TYPE_AUTH:Msg.MESSAGE_TYPE_PRESENCE,
                        from,
                        null,
                        pr.getPresenceTxt());
                
                JabberDataBlock xmuc=pr.findNamespace("http://jabber.org/protocol/muc");
                if (xmuc!=null) try {
                    MucContact c = mucContact(from);
                    
//toon
//                   String statusText=status.getChildBlockText("status"); 
//toon                    
                    
                    //System.out.println(b.toString());


                    //c.nick=nick;
                    
                    from=from.substring(0, from.indexOf('/'));
                    Msg chatPresence=new Msg(
                           Msg.MESSAGE_TYPE_PRESENCE,
                           from,
                           null,
                           c.processPresence(xmuc, pr) );
                    if (cf.storeConfPresence) {
                        messageStore(chatPresence);
                    }
                    
                    c.addMessage(m);
                    c.priority=pr.getPriority();
                    if (ti>=0) c.status=ti;
                    
                } /* if (muc) */ catch (Exception e) { /*e.printStackTrace();*/ }
                else {
                    Contact c=getContact(m.from, false); 
                    if (c==null) return; // drop presence
                    messageStore(c, m);
                    c.priority=pr.getPriority();
                    if (ti>=0) c.status=ti;
                    if (ti==Presence.PRESENCE_OFFLINE) c.acceptComposing=false;
                }
		Contact.sort(hContacts);
                reEnumRoster();
            }
        } catch( Exception e ) {
            e.printStackTrace();
        }
    }
    
    void replyError (JabberDataBlock stanza) {
        stanza.setAttribute("to", stanza.getAttribute("from"));
        stanza.setAttribute("from", null);
        stanza.setTypeAttribute("error");
        JabberDataBlock error=stanza.addChild("error", null);
        error.setTypeAttribute("cancel");
        error.addChild("feature-not-implemented",null);
        theStream.send(stanza);
    }
    
    void processRoster(JabberDataBlock data){
        JabberDataBlock q=data.getChildBlock("query");
        if (!q.isJabberNameSpace("jabber:iq:roster")) return;
        int type=0;
        
        Vector cont=(q!=null)?q.getChildBlocks():null;
        
        if (cont!=null)
            for (Enumeration e=cont.elements(); e.hasMoreElements();){
                JabberDataBlock i=(JabberDataBlock)e.nextElement();
                if (i.getTagName().equals("item")) {
                    String name=i.getAttribute("name");
                    String jid=i.getAttribute("jid");
                    String subscr=i.getAttribute("subscription");
                    boolean ask= (i.getAttribute("ask")!=null);

                    // найдём группу
                    String group=i.getChildBlockText("group");
                    if (group.length()==0) group=Groups.COMMON_GROUP;

                    // так можно проверить, когда пришёл jabber:iq:roster,
                    // на запрос ростера или при обновлении

                    //String iqType=data.getTypeAttribute();
                    //if (iqType.equals("set")) type=1;

                    updateContact(name,jid,group, subscr, ask);
                    Contact.sort(hContacts);
                }
            
            }
    }
    
    
    void messageStore(Contact c, Msg message) {
        if (c==null) return;  
        c.addMessage(message);
        
        if (cf.ghostMotor) System.gc(); 

        if (!message.unread) return;
        //TODO: clear unread flag if not-in-list IS HIDDEN
        
        if (countNewMsgs()) reEnumRoster();
        
        if (c.getGroupType()==Groups.TYPE_IGNORE) return;    // no signalling/focus on ignore
        
	if (cf.popupFromMinimized)
	    Bombus.getInstance().hideApp(false);
	
        if (cf.autoFocus) focusToContact(c, false);

        if (message.messageType!=Msg.MESSAGE_TYPE_HISTORY) 
            AlertProfile.playNotify(display, 0);
    }
    
    Contact messageStore(Msg message){
        Contact c=getContact(message.from, true);
        if (c.getGroupType()==Groups.TYPE_NOT_IN_LIST) 
            if (!cf.notInList) return c;

        messageStore(c, message);
        return c;
    }

    private void focusToContact(final Contact c, boolean force) {
	
	Group g=c.getGroup();
	if (g.collapsed) {
	    g.collapsed=false;
	    reEnumerator.queueEnum(c, force);
	    //reEnumRoster();
	} else {
	    
	    int index=vContacts.indexOf(c);
	    if (index>=0) moveCursorTo(index, force);
	}
    }
    
    
    /**
     * Method to begin talking to the server (i.e. send a login message)
     */
    
    public void beginConversation(String SessionId) {
        //try {
        //setProgress(SR.MS_LOGINPGS, 42);
        
//#if SASL
        if (sd.account.isSASL()) {
            new SASLAuth(sd.account, SessionId, this, theStream)
  //#if SASL_XGOOGLETOKEN
            .setToken(token)
  //#endif
            ;
   
        } else {
            new NonSASLAuth(sd.account, SessionId, this, theStream);
        }
//#else
//#         new NonSASLAuth(sd.account, SessionId, this, theStream);
//#endif
    }
    
    /**
     * If the connection is terminated then print a message
     *
     * @e The exception that caused the connection to be terminated, Note that
     *  receiving a SocketException is normal when the client closes the stream.
     */
    public void connectionTerminated( Exception e ) {
        //l.setTitleImgL(0);
        //System.out.println( "Connection terminated" );
        if( e != null ) {
            String error=e.getClass().getName()+"\n"+e.getMessage();
            errorLog(error);
            e.printStackTrace();
        }
        setProgress(SR.MS_DISCONNECTED, 0);
        try {
            sendPresence(Presence.PRESENCE_OFFLINE);
        } catch (Exception e2) {
            e2.printStackTrace();
        }
        redraw();
    }
    
    //private VList l;
    //private IconTextList l;
    
    public void eventOk(){
        super.eventOk();
        if (createMsgList()==null) {
            cleanupGroup();
            reEnumRoster();
        }
    }
    
    
    private Displayable createMsgList(){
        Object e=getFocusedObject();
        if (e instanceof Contact) {
            return new ContactMessageList((Contact)e,display);
        }
        return null;
    }
    protected void keyGreen(){
        Displayable pview=createMsgList();
        if (pview!=null) {
            Contact c=(Contact)getFocusedObject();
            ( new MessageEdit(display, c, c.msgSuspended) ).setParentView(pview);
            c.msgSuspended=null;
        }
        //reEnumRoster();
    }

    protected void keyPressed(int keyCode) {
        super.keyPressed(keyCode);
//#if (MOTOROLA_BACKLIGHT)
        if (cf.ghostMotor) {
            // backlight management
            if (keyCode=='*') blState=(blState==1)? Integer.MAX_VALUE : 1;
            else blState=Integer.MAX_VALUE;
            
            display.flashBacklight(blState);
        }
//#endif
    }
    

    public void userKeyPressed(int keyCode){
        if (keyCode==KEY_NUM0 /* || keyCode==MOTOE680_REALPLAYER  CONFLICT WITH ALCATEL. (platform=J2ME)*/) {
            if (messageCount==0) return;
            Object atcursor=getFocusedObject();
            Contact c=null;
            if (atcursor instanceof Contact) c=(Contact)atcursor;
            // а если курсор на группе, то искать с самого начала.
            else c=(Contact)hContacts.firstElement();
            
            Enumeration i=hContacts.elements();
            
            int pass=0; // 0=ищем курсор, 1=ищем
            while (pass<2) {
                if (!i.hasMoreElements()) i=hContacts.elements();
                Contact p=(Contact)i.nextElement();
                if (pass==1) if (p.getNewMsgsCount()>0) { 
		    focusToContact(p, true);
                    setRotator();
                    break; 
                }
                if (p==c) pass++; // полный круг пройден
            }
        }

        if (keyCode=='3') searchGroup(-1);
	if (keyCode=='9') searchGroup(1);
        
    }
    
    public void logoff(){
        if (theStream!=null)
        try {
             sendPresence(Presence.PRESENCE_OFFLINE);
        } catch (Exception e) { 
            e.printStackTrace(); 
        }
    };

   
    public void commandAction(Command c, Displayable d){
        if (c==cmdQuit) {
            destroyView();
            logoff();
            //StaticData sd=StaticData.getInstance();
            //cf.saveToStorage();
	    Bombus.getInstance().notifyDestroyed();
            return;
        }
        if (c==cmdMinimize) { Bombus.getInstance().hideApp(true);  }
        
        if (c==cmdActiveContact) { new ActiveContacts(display, null); }
        
        if (c==cmdAccount){ new AccountSelect(display, false); }
        if (c==cmdStatus) { new StatusSelect(display); }
        if (c==cmdAlert) { new AlertProfile(display); }
        if (c==cmdArchive) { new ArchiveList(display, null); }
        if (c==cmdInfo) { new Info.InfoWindow(display); }
        
        if (c==cmdTools) { new RosterToolsMenu(display); }
        // stream-sensitive commands
        // check for closed socket
        if (StaticData.getInstance().roster.theStream==null) return;
        
        if (c==cmdConference) { new ConferenceForm(display); }
        if (c==cmdActions) try { 
            new RosterItemActions(display, getFocusedObject()); 
        } catch (Exception e) { /* NullPointerException */ }
        
        if (c==cmdAdd) {
            //new MIDPTextBox(display,"Add to roster", null, new AddContact());
            Object o=getFocusedObject();
            Contact cn=null;
            if (o instanceof Contact) {
                cn=(Contact)o;
                if (cn.getGroupType()!=Groups.TYPE_NOT_IN_LIST && cn.getGroupType()!=Groups.TYPE_SEARCH_RESULT) cn=null;
            }
            if (o instanceof MucContact) { cn=(Contact)o; }
            new ContactEdit(display, cn);
        }
    }
    

    public void reEnterRoom(Group group) {
	ConferenceGroup confGroup=(ConferenceGroup)group;
        String confJid=confGroup.getSelfContact().getJid();
        int roomEnd=confJid.indexOf('@');
        String room=confJid.substring(0, roomEnd);
        int serverEnd=confJid.indexOf('/');
        String server=confJid.substring(roomEnd+1,serverEnd);
        String nick=confJid.substring(serverEnd+1);
        
        new ConferenceForm(display, room, server, nick, confGroup.password);
        //sendPresence(confGroup.getSelfContact().getJid(), null, null);

	//confGroup.getConference().status=Presence.PRESENCE_ONLINE;
    }
    public void leaveRoom(int index, Group group){
	//Group group=groups.getGroup(index);
	ConferenceGroup confGroup=(ConferenceGroup)group;
	Contact myself=confGroup.getSelfContact();
        sendPresence(myself.getJid(), "unavailable", null);
	
        for (Enumeration e=hContacts.elements(); e.hasMoreElements();) {
            Contact contact=(Contact)e.nextElement();
            if (contact.inGroup(group)) contact.status=Presence.PRESENCE_OFFLINE; 
        }

    }
    
    protected void showNotify() { super.showNotify(); countNewMsgs(); }
    
    
    protected void keyRepeated(int keyCode) {
        super.keyRepeated(keyCode);
        if (kHold==keyCode) return;
        //kHold=keyCode;
        kHold=keyCode;
        
        if (keyCode==cf.keyLock) 
            new KeyBlock(display, getTitleItem(), cf.keyLock, cf.ghostMotor); 

        if (keyCode==cf.keyVibra || keyCode==MOTOE680_FMRADIO /* TODO: redefine keyVibra*/) {
            // swap profiles
            int profile=cf.profile;
            cf.profile=(profile==AlertProfile.VIBRA)? 
                cf.lastProfile : AlertProfile.VIBRA;
            cf.lastProfile=profile;
            
            updateTitle();
            redraw();
        }
        
        if (keyCode==cf.keyOfflines /* || keyCode==MOTOE680_REALPLAYER CONFLICT WITH ALCATEL. (platform=J2ME) 
         TODO: redifine keyOfflines*/) {
            cf.showOfflineContacts=!cf.showOfflineContacts;
            reEnumRoster();
        }

       	if (keyCode==KEY_NUM3) new ActiveContacts(display, null);

        if (keyCode==cf.keyHide && cf.allowMinimize) {
            Bombus.getInstance().hideApp(true);
        }
    }

    private void searchGroup(int direction){
	synchronized (vContacts) {
	    int size=vContacts.size();
	    int pos=cursor;
	    int count=size;
	    try {
		while (count>0) {
		    pos+=direction;
		    if (pos<0) pos=size-1;
		    if (pos>=size) pos=0;
		    if (vContacts.elementAt(pos) instanceof Group) break;
		}
		moveCursorTo(pos, true);
	    } catch (Exception e) { }
	}
    }

    public void deleteContact(Contact c) {
	for (Enumeration e=hContacts.elements();e.hasMoreElements();) {
	    Contact c2=(Contact)e. nextElement();
	    if (c.jid.equals(c2. jid,false)) {
		c2.status=c2.offline_type=Presence.PRESENCE_TRASH;
	    }
	}
	
	if (c.getGroupType()==Groups.TYPE_NOT_IN_LIST) {
	    hContacts.removeElement(c);
            countNewMsgs();
	    reEnumRoster();
	} else
	    theStream.send(new IqQueryRoster(c.getBareJid(),null,null,"remove"));
    }
   
    
    public void setQuerySign(boolean requestState) {
        querysign=requestState;
        updateTitle();
    }
    void setMucMod(Contact contact, Hashtable itemAttributes){
        JabberDataBlock iq=new Iq(contact.jid.getBareJid(), Iq.TYPE_SET, "itemmuc");
        JabberDataBlock query=iq.addChild("query", null);
        query.setNameSpace("http://jabber.org/protocol/muc#admin");
        JabberDataBlock item=new JabberDataBlock("item", null, itemAttributes);
        query.addChild(item);
        //System.out.println(iq);
        theStream.send(iq);
    }
    /**
     * store cotnact on server
     */
    public void storeContact(String jid, String name, String group, boolean askSubscribe){
        
        theStream.send(new IqQueryRoster(jid, name, group, null));
        if (askSubscribe) theStream.send(new Presence(jid,"subscribe"));
    }

    public void loginMessage(String msg) {
        setProgress(msg, 42);
    }

    private class ReEnumerator implements Runnable{

        Thread thread;
        int pendingRepaints=0;
	boolean force;
	
	Object desiredFocus;
        
        public void queueEnum(Object focusTo, boolean force) {
	    desiredFocus=focusTo;
	    this.force=force;
	    queueEnum();
        }
	
        synchronized public void queueEnum() {
            pendingRepaints++;
            if (thread==null) (thread=new Thread(this)).start();
        }
        
        public void run(){
            try {
                while (pendingRepaints>0) {
                    //System.out.println(pendingRepaints);
                    pendingRepaints=0;
                    
                    int locCursor=cursor;
                    Object focused=(desiredFocus==null)?getFocusedObject():desiredFocus;
		    desiredFocus=null;
                    
                    Vector tContacts=new Vector(vContacts.size());
                    //boolean offlines=cf.showOfflineContacts;//StaticData.getInstance().config.showOfflineContacts;
                    
                    Enumeration e;
                    int i;
                    groups.resetCounters();
                    
                    synchronized (hContacts) {
                        for (e=hContacts.elements();e.hasMoreElements();){
                            Contact c=(Contact)e.nextElement();
                            boolean online=c.status<5;
                            // group counters
                            Group grp=c.getGroup();
			    grp.addContact(c);
                        }
                    }
                    // self-contact group
                    Group selfContactGroup=groups.getGroup(Groups.TYPE_SELF);
                    if (cf.selfContact || selfContactGroup.tonlines>1 || selfContactGroup.unreadMessages>0 )
                        groups.addToVector(tContacts, Groups.TYPE_SELF);
                    // adding groups
                    for (i=Groups.TYPE_COMMON;i<groups.getCount();i++)
                        groups.addToVector(tContacts,i);
                    // hiddens
                    if (cf.ignore) groups.addToVector(tContacts,Groups.TYPE_IGNORE);
                    // not-in-list
                    if (cf.notInList) groups.addToVector(tContacts,Groups.TYPE_NOT_IN_LIST);

                    // transports
                    Group transpGroup=groups.getGroup(Groups.TYPE_TRANSP);
                    if (cf.showTransports || transpGroup.unreadMessages>0)
                        groups.addToVector(tContacts,Groups.TYPE_TRANSP);
                    
                    // search result
                    //if (groups.getGroup(Groups.SRC_RESULT_INDEX).tncontacts>0)
                    groups.addToVector(tContacts, Groups.TYPE_SEARCH_RESULT);
                    
                    vContacts=tContacts;
                    
                    setRosterTitle("("+groups.getRosterOnline()+"/"+groups.getRosterContacts()+")");
                    
                    //resetStrCache();
                    if (cursor<0) cursor=0;
                    
                    // вернём курсор на прежний элемент
                    if ( locCursor==cursor && focused!=null ) {
                        int c=vContacts.indexOf(focused);
                        if (c>=0) moveCursorTo(c, force);
			force=false;
                    }
                    //if (cursor>=vContacts.size()) cursor=vContacts.size()-1; //moveCursorEnd(); // вернём курсор из нирваны
                    
                    focusedItem(cursor);
                    redraw();
                }
            } catch (Exception e) {e.printStackTrace();}
            thread=null;
        }
    }
}

/*
 * RosterItemActions.java
 *
 * Created on 11 Декабрь 2005 г., 19:05
 *
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import Conference.ConferenceForm;
import Conference.ConferenceGroup;
import Conference.InviteForm;
import Conference.MucContact;
import Conference.QueryConfigForm;
import Conference.affiliation.Affiliations;
import ServiceDiscovery.ServiceDiscovery;
import com.alsutton.jabber.datablocks.IqVersionReply;
import com.alsutton.jabber.datablocks.Presence;
import java.util.Enumeration;
import java.util.Hashtable;
import javax.microedition.lcdui.Display;
import locale.SR;
import ui.IconTextElement;
import ui.Menu;
import ui.MenuItem;
import ui.YesNoAlert;
import vcard.VCard;
import vcard.vCardForm;

/**
 *
 * @author EvgS
 */
public class RosterItemActions extends Menu{
    
    Object item;
    
    /** Creates a new instance of RosterItemActions */
    public RosterItemActions(Display display, Object item) {
	super(item.toString());
	this.item=item;
	
        if (item==null) return;
        boolean isContact=( item instanceof Contact );

	if (isContact) {
	    Contact contact=(Contact)item;
	    if (contact.getGroupType()==Groups.TYPE_TRANSP) {
		addItem(SR.MS_LOGON,5);
		addItem(SR.MS_LOGOFF,6);
		addItem(SR.MS_RESOLVE_NICKNAMES, 7);
	    }
	    //if (contact.group==Groups.SELF_INDEX) addItem("Commands",30);
	    
	    addItem(SR.MS_VCARD,1);
	    addItem(SR.MS_CLIENT_INFO,0);
	    addItem(SR.MS_COMMANDS,30);
	    
	    if (contact.getGroupType()!=Groups.TYPE_SELF && contact.getGroupType()!=Groups.TYPE_SEARCH_RESULT && contact.origin<Contact.ORIGIN_GROUPCHAT) {
		if (contact.getGroupType()!=Groups.TYPE_TRANSP)
		    addItem(SR.MS_EDIT,2);
		addItem(SR.MS_SUBSCRIPTION,3);
		addItem(SR.MS_DELETE,4);
	    }
            
	    if (contact.origin==Contact.ORIGIN_GROUPCHAT) return; //TODO: подключить тот же список, что и для ConferenceGroup
            
            if (contact instanceof MucContact) {
                MucContact selfContact= ((ConferenceGroup) contact.getGroup()).getSelfContact();
                MucContact mc=(MucContact) contact;
                
                int myAffiliation=selfContact.affiliationCode;
                if (myAffiliation==MucContact.AFFILIATION_OWNER) myAffiliation++; // allow owner to change owner's affiliation

                
                if (selfContact.roleCode==MucContact.ROLE_MODERATOR) {
                    addItem(SR.MS_KICK,8);
                    
                    if (myAffiliation>=MucContact.AFFILIATION_ADMIN && mc.affiliationCode<myAffiliation)
                        addItem(SR.MS_BAN,9);
                    
                    if (mc.affiliationCode<MucContact.AFFILIATION_ADMIN) 
                        /* 5.1.1 *** A moderator MUST NOT be able to revoke voice privileges from an admin or owner. */ 
                    if (mc.roleCode==MucContact.ROLE_VISITOR) addItem(SR.MS_GRANT_VOICE,31);
                    else addItem(SR.MS_REVOKE_VOICE,32);
                }
                
                if (myAffiliation>=MucContact.AFFILIATION_ADMIN) {
                    // admin use cases
                    
                    //roles
                    if (mc.affiliationCode<MucContact.AFFILIATION_ADMIN) 
                        /* 5.2.1 ** An admin or owner MUST NOT be able to revoke moderation privileges from another admin or owner. */ 
                    if (mc.roleCode==MucContact.ROLE_MODERATOR) addItem(SR.MS_REVOKE_MODERATOR,31);
                    else addItem(SR.MS_GRANT_MODERATOR,33);
                    
                    //affiliations
                    if (mc.affiliationCode<myAffiliation) {
                        if (mc.affiliationCode!=MucContact.AFFILIATION_NONE) addItem(SR.MS_UNAFFILIATE,36);
                        /* 5.2.2 */
                        if (mc.affiliationCode!=MucContact.AFFILIATION_MEMBER) addItem(SR.MS_GRANT_MEMBERSHIP,35);
                    }
                    
                    
//--toon               //m.addItem(new MenuItem("Set Affiliation",15));
                }
                if (myAffiliation>=MucContact.AFFILIATION_OWNER) {
                    // owner use cases
                    //if (mc.affiliationCode<=selfContact.affiliationCode) /* 5.2.2 */
                    if (mc.affiliationCode!=MucContact.AFFILIATION_ADMIN) addItem(SR.MS_GRANT_ADMIN,37);
                    //else addItem(SR.MS_REVOKE_ADMIN,35);
                    
                    if (mc.affiliationCode!=MucContact.AFFILIATION_OWNER) addItem(SR.MS_GRANT_OWNERSHIP,38);
                    //else addItem(SR.MS_REVOKE_OWNERSHIP,37);
                }
            } else if (contact.getGroupType()!=Groups.TYPE_TRANSP) {
                // usual contact - invite item check
                boolean onlineConferences=false;
                for (Enumeration c=StaticData.getInstance().roster.getHContacts().elements(); c.hasMoreElements(); ) {
                    try {
                        MucContact mc=(MucContact)c.nextElement();
                        if (mc.origin==Contact.ORIGIN_GROUPCHAT && mc.status==Presence.PRESENCE_ONLINE)
                            onlineConferences=true;
                    } catch (Exception e) {}
                }
                if (onlineConferences) addItem(SR.MS_INVITE,40);
            }
	} else {
	    Group group=(Group)item;
	    if (group.index==Groups.TYPE_SEARCH_RESULT)
		addItem(SR.MS_DISCARD,21);
	    if (group instanceof ConferenceGroup) {
		MucContact self=((ConferenceGroup)group).getSelfContact();
		if (self.status>=Presence.PRESENCE_OFFLINE) // offline or error
		    addItem(SR.MS_REENTER,23);
		else {
		    addItem(SR.MS_LEAVE_ROOM,22);
		    if (self.affiliationCode>=MucContact.AFFILIATION_OWNER) {
			addItem(SR.MS_CONFIG_ROOM,10);
                    }
		    if (self.affiliationCode>=MucContact.AFFILIATION_ADMIN) {
			addItem(SR.MS_OWNERS,11);
			addItem(SR.MS_ADMINS,12);
			addItem(SR.MS_MEMBERS,13);
			addItem(SR.MS_BANNED,14);
		    }
		}
	    }
	    //m.addItem(new MenuItem("Cleanup offlines"))
	}
	if (getItemCount()>0) attachDisplay(display);
	
    }
    
    public void eventOk(){
        try {
            final Roster roster=StaticData.getInstance().roster;
            boolean isContact=( item instanceof Contact );
            Contact c = null;
            Group g = null;
            if (isContact) c=(Contact)item; else g=(Group) item;
            
            MenuItem me=(MenuItem) getFocusedObject();
            if (me==null) {
                destroyView(); return;
            }
            int index=me.index;
            String to=null;
            if (isContact) to=(index<3)? c.getJid() : c.getBareJid();
            destroyView();
            switch (index) {
                case 0: // info
                    roster.setQuerySign(true);
                    roster.theStream.send(new IqVersionReply(to));
                    break;
                case 1: // vCard
                    if (c.vcard!=null) {
                        new vCardForm(display, c.vcard, c.getGroupType()==Groups.TYPE_SELF);
                        return;
                    }
                    VCard.request(c.getJid());
                    break;
                    
                case 2:
                    (new ContactEdit(display, c )).parentView=roster;
                    return; //break;
                    
                case 3: //subscription
                    new SubscriptionEdit(display, c);
                    return; //break;
                case 4:
                    new YesNoAlert(display, roster, SR.MS_DELETE_ASK, c.getNickJid()){
                        public void yes() {
                            roster.deleteContact((Contact)item);
                        };
                    };
                    return;
                    //new DeleteContact(display,c);
                    //break;
                case 6: // logoff
                {
                    //querysign=true; displayStatus();
                    Presence presence = new Presence(
                            Presence.PRESENCE_OFFLINE, -1, "");
                    presence.setTo(c.getJid());
                    roster.theStream.send( presence );
                    break;
                }
                case 5: // logon
                {
                    //querysign=true; displayStatus();
                    Presence presence = new Presence(roster.myStatus, 0, "");
                    presence.setTo(c.getJid());
                    roster.theStream.send( presence );
                    break;
                }
                case 7: // Nick resolver
                {
                    roster.resolveNicknames(c.transport);
                    break;
                }
                
                case 21:
                {
                    roster.cleanupSearch();
                    break;
                }
                case 30:
                {
                    new ServiceDiscovery(display, c.getJid(), "http://jabber.org/protocol/commands");
                    return;
                }
                
                case 40: //invite
                {
                    new InviteForm(c, display);
                    return;
                }
                
            }
            
            if (c instanceof MucContact || g instanceof ConferenceGroup) {
                MucContact mc=(MucContact) c;
                switch (index) { // muc contact actions
                    case 10: // room config
                    {
                        String roomJid=((ConferenceGroup)g).getConference().getJid();
                        new QueryConfigForm(display, roomJid);
                        break;
                    }
                    case 11: // owners
                    case 12: // admins
                    case 13: // members
                        
                    case 14: // outcasts
                    {
                        String roomJid=((ConferenceGroup)g).getConference().getJid();
                        new Affiliations(display, roomJid, index-10);
                        return;
                    }
                    /*case 15: // affiliation
                    {
                        String roomJid=conferenceRoomContact(g.index).getJid();
                        new AffiliationModify(display, roomJid, c.realJid, affiliation)(display, roomJid, index-10);
                    }
                     */
                    case 22:
                    {
                        roster.leaveRoom( 0, g);
                        break;
                    }
                    case 23:
                    {
                        roster.reEnterRoom( g );
                        return; //break;
                    }
                    
                    case 8: // kick
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("role", "none");
                        attrs.put("nick", mc.nick);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    case 9: // ban
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("affiliation", "outcast");
                        attrs.put("jid", mc.realJid);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    case 31: //grant voice and revoke moderator
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("role", "participant");
                        attrs.put("nick", mc.nick);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    case 32: //revoke voice
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("role", "visitor");
                        attrs.put("nick", mc.nick);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    
                    case 33: //grant moderator
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("role", "moderator");
                        attrs.put("nick", mc.nick);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    
            /*case 34: //reserved
            {
             
            }*/
                    
                    case 35: //grant membership and revoke admin
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("affiliation", "member");
                        attrs.put("jid", mc.realJid);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    
                    case 36: //revoke membership
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("affiliation", "none");
                        attrs.put("jid", mc.realJid);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    
                    case 37: //grant admin and revoke owner
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("affiliation", "admin");
                        attrs.put("jid", mc.realJid);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    
                    case 38: //grant owner
                    {
                        Hashtable attrs=new Hashtable();
                        attrs.put("affiliation", "owner");
                        attrs.put("jid", mc.realJid);
                        roster.setMucMod(mc, attrs);
                        break;
                    }
                    
                }
            }
            destroyView();
        } catch (Exception e) { e.printStackTrace();  }
    }
        
}
/*
 * RosterToolsMenu.java
 *
 * Created on 11 Декабрь 2005 г., 20:43
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import PrivacyLists.PrivacySelect;
import ServiceDiscovery.ServiceDiscovery;
import javax.microedition.lcdui.Display;
import locale.SR;
import ui.Menu;
import ui.MenuItem;
import vcard.VCard;
import vcard.vCardForm;

/**
 *
 * @author EvgS
 */
public class RosterToolsMenu
        extends Menu {
    
    /** Creates a new instance of RosterToolsMenu */
    public RosterToolsMenu(Display display) {
        super(SR.MS_JABBER_TOOLS);
        addItem(SR.MS_DISCO, 0);
        addItem(SR.MS_PRIVACY_LISTS, 1);
        addItem(SR.MS_MY_VCARD, 2);
        addItem(SR.MS_OPTIONS, 3);
        /*if (m.getItemCount()>0)*/
        
//#if (FILE_IO)
        addItem("root",4);
//#endif
        
        attachDisplay(display);
    }
    public void eventOk(){
        destroyView();
        boolean connected= ( StaticData.getInstance().roster.theStream != null );
        MenuItem me=(MenuItem) getFocusedObject();
        if (me==null)  return;
        int index=me.index;
        switch (index) {
            case 0: // Service Discovery
                if (connected) new ServiceDiscovery(display, null, null);
                break;
            case 1: // Privacy Lists
                if (connected) new PrivacySelect(display);
                break;
            case 2: {
                if (! connected) break;
                Contact c=StaticData.getInstance().roster.selfContact();
                if (c.vcard!=null) {
                    new vCardForm(display, c.vcard, true);
                    return;
                }
                VCard.request(c.getJid());
                return;
            }
            case 3:
                new ConfigForm(display);
                return;
//#if (FILE_IO)
            case 4:
                new io.file.browse.Browser(display, null, false);
                return;
//#endif
        }
    }
}/*
 * SmilePicker.java
 *
 * Created on 6 Март 2005 г., 11:50
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import Messages.MessageParser;
import images.SmilesIcons;
import locale.SR;
import ui.*;
import javax.microedition.lcdui.*;
import java.util.Vector;
import ui.controls.Balloon;

/**
 *
 * @author Eugene Stahov
 */
    
/**
 *
 * @author Eugene Stahov
 */
public class SmilePicker extends VirtualList implements CommandListener, VirtualElement{

    private final static int CURSOR_HOFFSET=2;

//#if MIDP1
//#     private final static int CURSOR_VOFFSET=1;
//#else
    private final static int CURSOR_VOFFSET=2;
//#endif
    
    private int imgCnt;
    private int xCnt;
    private int xLastCnt;
    private int xCursor;
    private int lines;

    private int lineHeight;
    private int imgWidth;
    
    private ImageList il;
    
    private MessageEdit me;
    
    Command cmdBack=new Command(SR.MS_CANCEL,Command.BACK,99);
    Command cmdOK=new Command(SR.MS_SELECT,Command.OK,1);
    
    private Vector smileTable;

    /** Creates a new instance of SmilePicker */
    public SmilePicker(Display display, MessageEdit me) {
        super(display);
        this.me=me;
        
        il = SmilesIcons.getInstance();
        
        smileTable=MessageParser.getInstance().getSmileTable();
        
        imgCnt=smileTable.size();
        //il.getCount();
        
        imgWidth=il.getWidth()+2*CURSOR_HOFFSET;
        lineHeight = il.getHeight()+2*CURSOR_VOFFSET;

        xCnt= getWidth() / imgWidth;
        
        lines=imgCnt/xCnt;
        xLastCnt=imgCnt-lines*xCnt;
        if (xLastCnt>0) lines++; else xLastCnt=xCnt;
        
        addCommand(cmdOK);
        addCommand(cmdBack);
        setCommandListener(this);
      
    }
    
    int smileIndex;
    //SmileItem si=new SmileItem();
    
    public int getItemCount(){ return lines; }
    public VirtualElement getItemRef(int index){ smileIndex=index; return this;}
    
    //private class SmileItem implements VirtualElement {
    public int getVWidth(){ return 0; }
    public int getVHeight() { return lineHeight; }
    public int getColor(){ return Colors.LIST_INK; }
    public int getColorBGnd(){ return Colors.LIST_BGND; }
    public void onSelect(){
        try {
            me.addText( getTipString() );
        } catch (Exception e) { /*e.printStackTrace();*/  }
        destroyView();
    };
    
        
    public void drawItem(Graphics g, int ofs, boolean selected){
        //int max=(smileIndex==lines-1)? xLastCnt:xCnt;
        for (int i=0;i<xCnt;i++) {
            il.drawImage(g, smileIndex*xCnt + i, i*imgWidth+CURSOR_HOFFSET, CURSOR_VOFFSET);
        }
    };
    
    //}
    public void drawCursor (Graphics g, int width, int height){
        int x=xCursor*imgWidth;
        g.setColor(Colors.LIST_BGND);
        g.fillRect(0,0,width, height);
        g.translate(x,0);
        super.drawCursor(g, imgWidth, lineHeight);
        g.translate(-x,0);
    } 
    
    public void keyLeft(){ 
        if (xCursor>0) xCursor--; 
        else {
            if (cursor==0) return;
            xCursor=xCnt-1;
            keyUp();
            setRotator();
        }
    }
    public void keyRight(){ 
        if ( xCursor < ( (cursor<lines-1)?(xCnt-1):(xLastCnt-1) ) ) {
            xCursor++;
            setRotator();
        }
        else {
            if (cursor==lines-1) return;
            xCursor=0;
            keyDwn();
        }
    }
    public void keyDwn(){
        super.keyDwn();
        if (cursor!=lines-1) return;
        if (xCursor >= xLastCnt) xCursor=xLastCnt-1;
    }
    
    public void commandAction(Command c, Displayable d){
        if (c==cmdBack) {
            destroyView();
            return;
        }
        if (c==cmdOK) { eventOk(); }
    }

    public void moveCursorEnd() {
        super.moveCursorEnd();
        xCursor=xLastCnt-1;
    }

    public void moveCursorHome() {
        super.moveCursorHome();
        xCursor=0;
    }

    public String getTipString() {
        return (String) smileTable.elementAt(cursor*xCnt+xCursor);
    }

    protected void drawBalloon(final Graphics g, int balloon, final String text) {
        if (cursor==0) balloon+=lineHeight+Balloon.getHeight();
        int x=xCursor*imgWidth;
        g.translate(x, balloon);
        Balloon.draw(g, text);
    }

    protected void pointerPressed(int x, int y) { 
        super.pointerPressed(x,y);
        if (x>=xCnt*imgWidth) return;
        xCursor=x/imgWidth;
        setRotator();
        if (cursor!=lines-1) return;
        if (xCursor >= xLastCnt) xCursor=xLastCnt-1;
    }
}
/*
 * StaticData.java
 *
 * Created on 20 Февраль 2005 г., 17:10
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import java.util.Hashtable;
import ui.ImageList;
import java.util.Vector;
/**
 *
 * @author Eugene Stahov
 */
public class StaticData {
    
    private static StaticData sd;
    
    public Roster roster;
    
    public Account account;
    
    public int account_index;
    
    /** Creates a new instance of StaticData */
    private StaticData() { }
    
    public static StaticData getInstance(){
        if (sd==null) sd=new StaticData();
        return sd;
    }

}
/*
 * StatusList.java
 *
 * Created on 3 Декабрь 2005 г., 17:33
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import com.alsutton.jabber.datablocks.Presence;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.util.Enumeration;
import java.util.Vector;

/**
 *
 * @author EvgS
 */
public class StatusList {
    
    // Singleton implementation
    private static StatusList instance;
    public static StatusList getInstance() {
	if (instance==null) instance=new StatusList();
	return instance;
    }

    public Vector statusList;

    /** Creates a new instance of StatusList */
    private StatusList() {
        statusList=new Vector(7);
	try {
	    DataInputStream inputStream=NvStorage.ReadFileRecord("status", 0);
	    
	    createFromStream(Presence.PRESENCE_ONLINE, Presence.PRS_ONLINE, inputStream);
	    createFromStream(Presence.PRESENCE_CHAT, Presence.PRS_CHAT, inputStream);
	    createFromStream(Presence.PRESENCE_AWAY, Presence.PRS_AWAY, inputStream);
	    createFromStream(Presence.PRESENCE_XA, Presence.PRS_XA, inputStream);
	    createFromStream(Presence.PRESENCE_DND, Presence.PRS_DND, inputStream);
	    createFromStream(Presence.PRESENCE_INVISIBLE, Presence.PRS_INVISIBLE, inputStream);
	    createFromStream(Presence.PRESENCE_OFFLINE, "offline", inputStream);
	    
	    inputStream.close();
        } catch (Exception e) { e.printStackTrace(); }

    }
    
    private void createFromStream(int presenceIndex, String presenceName, DataInputStream dataInputStream) {
	ExtendedStatus status=new ExtendedStatus(presenceIndex, presenceName);
        try {
	    status.setPriority(dataInputStream.readInt());
            status.setMessage(dataInputStream.readUTF());
        } catch (Exception e) { /*on stream errors*/ }
	statusList.addElement(status);
    }
    
    public void saveStatusToStorage(){
        DataOutputStream outputStream=NvStorage.CreateDataOutputStream();

        try {
            for (int i=0;i<statusList.size();i++) {
                ExtendedStatus e=(ExtendedStatus)statusList.elementAt(i);
                outputStream.writeInt(e.getPriority());
                outputStream.writeUTF(e.getMessage());
            }
        } catch (Exception e) { e.printStackTrace(); }

        NvStorage.writeFileRecord(outputStream, "status", 0, true);
    }
    
    public ExtendedStatus getStatus(final int status) {
	ExtendedStatus es=null;
	for (Enumeration e=statusList.elements(); e.hasMoreElements(); ){
	    es=(ExtendedStatus)e.nextElement();
	    if (status==es.getImageIndex()) break;
	}
	
	return es;
    }

}
/*
 * SelectStatus.java
 *
 * Created on 27 Февраль 2005 г., 16:43
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import images.RosterIcons;
import java.util.*;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.*;
import ui.controls.NumberField;

/**
 *
 * @author Eugene Stahov
 */
public class StatusSelect extends VirtualList implements CommandListener, Runnable{
    
    private Command cmdOk=new Command(SR.MS_SELECT,Command.OK,1);
    private Command cmdEdit=new Command(SR.MS_EDIT,Command.SCREEN,2);
    private Command cmdCancel=new Command(SR.MS_CANCEL,Command.BACK,99);
    /** Creates a new instance of SelectStatus */
    private Vector statusList=StatusList.getInstance().statusList;
    
    public StatusSelect(Display d) {
        super();
        setTitleItem(new Title(SR.MS_STATUS));
        
        addCommand(cmdOk);
        addCommand(cmdEdit);
        //addCommand(cmdPriority);
        //addCommand(cmdAll);
        addCommand(cmdCancel);
        setCommandListener(this);
        
        /*
        int status=StaticData.getInstance().roster.myStatus;
        int i;
        for (i=0;i<statusList.size(); i++) {
            if (status==((ExtendedStatus)getItemRef(i)).getImageIndex()) break;
        }
        moveCursorTo(i);
        */
        attachDisplay(d);
    }
    public VirtualElement getItemRef(int Index){
        return (VirtualElement)statusList.elementAt(Index);
    }
    
    private ExtendedStatus getSel(){ return (ExtendedStatus)getFocusedObject();}
    
    public void commandAction(Command c, Displayable d){
        if (c==cmdOk) eventOk(); 
        if (c==cmdEdit) {
            new StatusForm( display, getSel() );
        };
        if (c==cmdCancel) destroyView();
    }
    
    public void eventOk(){
        destroyView();
        new Thread(this).start();
    }
    
    public void run(){
        int status=getSel().getImageIndex();
        try {
            StaticData.getInstance().roster.sendPresence(status);
        } catch (Exception e) { e.printStackTrace(); }
    }
    
    public int getItemCount(){   return StatusList.getInstance().statusList.size(); }
    
    private void save(){
        StatusList.getInstance().saveStatusToStorage();
    }

    class StatusForm implements CommandListener{
        private Display display;
        public Displayable parentView;
        
        private Form f;
        private NumberField tfPriority;
        private TextField tfMessage;
        
        private ChoiceGroup chPriorityAll;
        
        private ExtendedStatus status;
        
        private Command cmdOk=new Command(SR.MS_OK,Command.OK,1);
        private Command cmdCancel=new Command(SR.MS_CANCEL,Command.BACK,99);
        
        public StatusForm(Display display, ExtendedStatus status){
            this.display=display;
            parentView=display.getCurrent();
            this.status=status;
            
            f=new Form(status.getName());
            
            tfPriority=new NumberField(SR.MS_PRIORITY, status.getPriority(), -128, 128);
            f.append(tfPriority);

            chPriorityAll=new ChoiceGroup(null, ChoiceGroup.MULTIPLE);
            chPriorityAll.append(SR.MS_ALL_STATUSES, null);
            f.append(chPriorityAll);
            
            tfMessage=new TextField(SR.MS_MESSAGE, status.getMessage(), 100, 0);
            f.append(tfMessage);
            
            f.addCommand(cmdOk);
            f.addCommand(cmdCancel);
            
            f.setCommandListener(this);
            display.setCurrent(f);
        }
        
        public void commandAction(Command c, Displayable d){
            if (c==cmdOk) {
                status.setMessage(tfMessage.getString());
                
		int priority=tfPriority.getValue();
                status.setPriority(priority);
                
                boolean flags[]=new boolean[1];
                chPriorityAll.getSelectedFlags(flags);
                if (flags[0]) {
                    for (Enumeration e=StatusList.getInstance().statusList.elements(); e.hasMoreElements();) {
                        ((ExtendedStatus)e.nextElement()).setPriority(priority);
                    }
                }
                
                save();
                destroyView();
            }
            if (c==cmdCancel) {  destroyView();  }
        }
        
        public void destroyView(){
            if (display!=null)   display.setCurrent(parentView);
        }
    }
}
/*
 * SubscriptionEdit.java
 *
 * Created on 10 Май 2005 г., 19:09
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;
import javax.microedition.lcdui.*;
import locale.SR;

/**
 *
 * @author Evg_S
 */
public class SubscriptionEdit extends Form implements CommandListener{
    
    private Display display;
      
    Command cmdAskSubscr=new Command(SR.MS_ASK_SUBSCRIPTION, Command.SCREEN, 1);
    Command cmdGrantSubscr=new Command(SR.MS_GRANT_SUBSCRIPTION, Command.SCREEN, 2);
    Command cmdSubscrDel=new Command(SR.MS_SUBSCR_REMOVE, Command.SCREEN, 3);
    Command cmdBack=new Command(SR.MS_CANCEL, Command.BACK, 99);
    
    Roster r=StaticData.getInstance().roster;
    String to;
    /** Creates a new instance of YesNoAlert */
    public SubscriptionEdit(Display display, Contact c) {
        super(SR.MS_SUBSCRIPTION);
        to=c.getBareJid();
        StringBuffer s=new StringBuffer(c.getNickJid());
        s.append('\n');
        s.append("subscr:");
        s.append(c.subscr);
        if (c.ask_subscribe) s.append(",ask");
        
//#if !(MIDP1)
        append("\n");
//#endif
        append(s.toString());
        //setString(s.toString());

        addCommand(cmdGrantSubscr);
        addCommand(cmdAskSubscr);
        addCommand(cmdSubscrDel);
        addCommand(cmdBack);
        
        setCommandListener(this);

        this.display=display;
        display.setCurrent(this);
    }
    public void commandAction(Command c, Displayable d ){
        String presence=null;
        if (c==cmdAskSubscr) { presence="subscribe"; }
        if (c==cmdGrantSubscr) { presence="subscribed"; }
        if (c==cmdSubscrDel) { presence="unsubscribed"; }
        
        if (presence!=null) r.sendPresence(to,presence, null);
        
        destroyView();
    }

    public void destroyView(){
        if (display!=null)   display.setCurrent(r);
    }

}
/*
 * Title.java
 *
 * Created on 29 Январь 2006 г., 1:00
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Client;

import images.RosterIcons;
import ui.ComplexString;
import ui.FontCache;

/**
 *
 * @author Evg_S
 */
public class Title extends ComplexString{
    
    /** Creates a new instance of Title
     * @param size число полей создаваемого ComplexString
     * @param first первое поле ComplexString
     * @param second второе поле ComplexString
     * @return созданный объект ComplexString, присоединённый в качестве заголовка
     */
    public Title(int size, Object first, Object second) {
        this (size);
        font=FontCache.getRosterNormalFont();
        if (first!=null) setElementAt(first,0);
        if (second!=null) setElementAt(second,1);
    }
    
    public Title(Object obj) {
        this(1, obj, null);
    }
    
    public Title(int size) {
        super (RosterIcons.getInstance());
        setSize(size);
    }
}
/*
 * ServiceDiscoveryListener.java
 *
 * Created on 4 Июнь 2005 г., 21:51
 */

package com.alsutton.jabber;

/**
 *
 * @author Evg_S
 */
public interface JabberBlockListener {
   public final static int BLOCK_REJECTED=0;
   public final static int BLOCK_PROCESSED=1;
   public final static int NO_MORE_BLOCKS=2;
  /**
   * Method to handle an incomming block.
   *
   * @parameter data The incomming block
   */

  public int blockArrived(JabberDataBlock data);
    
}
/*
  Copyright (c) 2000, Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.jabber;
import Client.NvStorage;
import java.util.*;

/**
 * Title:        JabberDataBlock.java
 * Description:  The base class for Jabber datablocks objects in the datablock sub package
 */

public class JabberDataBlock
{
    private final static int MAX_CHILDS=400;
  /**
   * The name of this tag
   */

  private String tagName;

  /**
   * The list of child blocks inside this block
   */

  protected Vector childBlocks;

  /**
   * A string representing all the text within the data block
   */

  protected String textData = null;

  /**
   * This blocks' parent
   */

  protected JabberDataBlock parent;

  /**
   * The list of attributes in this tag
   */

  protected Hashtable attributes;

  /**
   * Constructor
   */

  public JabberDataBlock( )
  {
    this( "unknown", null, null );
  }

  /**
   * Constructor
   *
   * @param parent The parent of this data block
   */

  //public JabberDataBlock( JabberDataBlock _parent )
  //{
  //  this( "unknown", _parent, null );
  //}

  /**
   * Constructor including an Attribute list
   *
   * @param _parent The parent of this datablock
   * @param _attributes The list of element attributes
   */

  public JabberDataBlock( JabberDataBlock _parent, Hashtable _attributes )
  {
    this( "unknown", _parent, _attributes );
  }

  /**
   * Constructor including an Attribute list
   *
   * @param _tagName The name of the block
   * @param _parent The parent of this datablock
   * @param _attributes The list of element attributes
   */

  public JabberDataBlock( String _tagName, JabberDataBlock _parent, Hashtable _attributes )
  {
    parent = _parent;
    attributes = _attributes;
    tagName = _tagName;
  }

  public JabberDataBlock( JabberDataBlock _parent, String _tagName, String _body  )
  {
    this( _tagName, _parent, null );
    setText(_body);
  }
  /**
   * Method to add a child to the list of child blocks
   *
   * @param newData The child block to add
   */

  public void addChild( Object newData ) {
      if( childBlocks == null )
	  childBlocks = new Vector();
      if (childBlocks.size()<MAX_CHILDS)
	  childBlocks.addElement( newData );
  }
  
  /**
   * Method to add a simple child to the list of child blocks
   *
   * @param name The child block name to add
   * @param text The child block text body to add
   */
  public JabberDataBlock addChild(String name, String text){
      JabberDataBlock child=new JabberDataBlock(name,this,null);
      if (text!=null) child.setText(text);
      addChild(child);
      return child;
  }


  /**
   * Method to add some text to the text buffer for this block
   *
   * @param text The text to add
   */

  public void setText( String text ) { textData=text; }

  /**
   * Method to get the parent of this block
   *
   * @return This blocks parent
   */

  public JabberDataBlock getParent() { return parent; }


  /**
   * Method to return the data as a byte stream ready to send over
   * the wire
   *
   * @return The data to send as a byte array
   */

  public byte[] getBytes()
  {
    String data = toString();
    return data.getBytes();
  }

  /**
   * Method to get the text element of this block
   *
   * @return The text contained in this block
   */

  public String getText()
  {
    return (textData==null)?"":textData.toString();
  }

  /**
   * Method to get an attribute
   *
   * @param attributeName The name of the attribute to get
   * @return The value of the attribute
   */

  public String getAttribute( String attributeName )
  {
    if (attributes==null) return null;
    return (String) attributes.get( attributeName );
  }
  
  public String getTypeAttribute(){
      return getAttribute("type");
  }
  
  public boolean isJabberNameSpace(String xmlns){
      String xmlnsatr=getAttribute("xmlns");
      if (xmlnsatr==null) return false;
      return xmlnsatr.startsWith(xmlns);
  } 

  public JabberDataBlock findNamespace(String xmlns) {
      if (childBlocks==null) return null;
      for (Enumeration e=childBlocks.elements(); e.hasMoreElements();){
          JabberDataBlock d=(JabberDataBlock)e.nextElement();
          if (d.isJabberNameSpace(xmlns)) return d;
      }
      return null;
  }
  
  public void setNameSpace(String xmlns){
      setAttribute("xmlns", xmlns);
  }
  /**
   * Method to set an attribute value
   *
   * @param attributeName The name of the attribute to set
   * @param value The value of the attribute
   */

  public void setAttribute( String attributeName, String value )
  {
    if( attributeName == null )
      return;

    if( attributes == null )
      attributes = new Hashtable();

    if (value!=null) attributes.put( attributeName, value );
    else attributes.remove(attributeName);
  }

  public void setTypeAttribute( String value ) {
      setAttribute("type",value);
  }
  
  /**
   * Returns a vector holding all of the children of this block
   *
   * @param Vector holding all the children
   */

  public Vector getChildBlocks()
  {
    return (Vector) childBlocks;
  }

  /**
   * Returns a child block by  the tagName
   *
   */

  public JabberDataBlock getChildBlock(String byTagName)
  {
    if (childBlocks==null) return null;
    for (Enumeration e=childBlocks.elements(); e.hasMoreElements();){
        JabberDataBlock d=(JabberDataBlock)e.nextElement();
        if (d.getTagName().equals(byTagName)) return d;
    }
    return null;
  }

  /**
   * Returns a child block by text
   *
   */

  public JabberDataBlock getChildBlockByText(String text)
  {
    if (childBlocks==null) return null;
    for (Enumeration e=childBlocks.elements(); e.hasMoreElements();){
        JabberDataBlock d=(JabberDataBlock)e.nextElement();
        if (text.equals(d.getText()) ) return d;
    }
    return null;
  }

  /**
   * Method to return the text for a given child block
   */

  public String getChildBlockText( String blockname )
  {
      try {
        JabberDataBlock child=getChildBlock(blockname);
        return child.getText();
      } catch (Exception e) {}
      return "";
  }
  
      private void appendXML(StringBuffer dest, String src){
        if (src==null) return;
        int len=src.length();
        for (int i=0;i<len;i++){
            char ch=src.charAt(i);
            switch (ch) {
                case '&':   dest.append("&amp;"); break;
                case '"':   dest.append("&quot;"); break;
                case '<':   dest.append("&lt;"); break;
                case '>':   dest.append("&gt;"); break;
                case '\'':  dest.append("&apos;"); break;
                default: dest.append(ch);
            }
        }
    }

  /**
   * Method to convert this into a String
   *
   * @return The element as an XML string
   */

  public String toString()
  {
    StringBuffer data = new StringBuffer();
    constructXML(data);
    return data.toString();
  }

  public void constructXML(StringBuffer data) {
      data.append('<');
      data.append( getTagName() );
      if( attributes != null )
          addAttributeToStringBuffer( data );
      
      // short xml
      if (textData==null && childBlocks ==null ) {
          data.append("/>");
          return;
      }
      
      data.append( '>' );
      
      
      appendXML(data, textData);
      
      if( childBlocks != null ) {
          Enumeration e = childBlocks.elements();
          while( e.hasMoreElements() ) {
              JabberDataBlock thisBlock = (JabberDataBlock) e.nextElement();
              thisBlock.constructXML(data);
          }
      }
      
      // end tag
      data.append( "</" );
      data.append( getTagName() );
      data.append( '>' );
  }
  
  /**
   * Method to add all the attributes to a string buffer
   *
   * @param buffer The string buffer to which all the attributes will be added
   */

  protected void addAttributeToStringBuffer( StringBuffer buffer )
  {
    Enumeration e = attributes.keys();
    while( e.hasMoreElements() )
    {
      String nextKey = (String) e.nextElement();
      String nextValue = (String) attributes.get( nextKey );

      buffer.append( ' ' );
      buffer.append( nextKey );
      buffer.append( "=\"" );
      appendXML(buffer, nextValue);
      //buffer.append( nextValue );
      buffer.append( '\"' );
    }
  }

  /**
   * Method to return the start of tag string as a string
   *
   * @return The start tag string
   */

  public StringBuffer getTagStart()
  {
    StringBuffer tagStart = new StringBuffer( "<" );
    tagStart.append( getTagName() );
    if( attributes != null )
      addAttributeToStringBuffer( tagStart );
    tagStart.append( '>' );

    return tagStart;
  }

  /**
   * Method to return the tag name
   *
   * @return The tag name
   */

  public String getTagName()
  {
    return tagName;
  }
}
/*
  Copyright (c) 2000,2001 Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.jabber;
import java.io.*;
import java.util.*;

/**
 * The dispatcher for blocks that have arrived. Adds new blocks to the
 * dispatch queue, and then dispatches waiting blocks in their own thread to
 * avoid holding up the stream reader.
 */

public class JabberDataBlockDispatcher extends Thread
{
  /**
   * The recipient waiting on this stream
   */

  private JabberListener listener = null;
  
  private Vector blockListeners=new Vector();

  /**
   * The list of messages waiting to be dispatched
   */

  private Vector waitingQueue = new Vector();

  /**
   * Flag to watch the dispatching loop
   */

  private boolean dispatcherActive;

  /**
   * Constructor to start the dispatcher in a thread.
   */

  public JabberDataBlockDispatcher()
  {
    start();
  }

  /**
   * Set the listener that we are dispatching to. Allows for switching
   * of clients in mid stream.
   *
   * @param _listener The listener to dispatch to.
   */

  public void setJabberListener( JabberListener _listener )
  {
    listener = _listener;
  }

  public void addBlockListener(JabberBlockListener listener) {
      synchronized (blockListeners) { blockListeners.addElement(listener); }
  }
  public void cancelBlockListener(JabberBlockListener listener) {
      synchronized (blockListeners) { 
          try { blockListeners.removeElement(listener); }
          catch (Exception e) {e.printStackTrace(); }
      }
  }
  
  public void cancelBlockListenerByClass(Class removeClass){
      synchronized (blockListeners) {
          int index=0;
          while (index<blockListeners.size()) {
              Object listener=blockListeners.elementAt(index);
              if (listener.getClass().equals(removeClass)) blockListeners.removeElementAt(index); 
              else index++;
          }
      }
  }
  
  
  /**
   * Method to add a datablock to the dispatch queue
   *
   * @param datablock The block to add
   */

  public void broadcastJabberDataBlock( JabberDataBlock dataBlock )
  {
    waitingQueue.addElement( dataBlock );
  }

  /**
   * The thread loop that handles dispatching any waiting datablocks
   */

  public void run()
  {
    dispatcherActive = true;
    while( dispatcherActive )
    {
      while( waitingQueue.size() == 0 )
      {
        try
        {
          Thread.sleep( 100L );
        }
        catch( InterruptedException e )
        {
        }
      }

      JabberDataBlock dataBlock = (JabberDataBlock) waitingQueue.elementAt(0);
      waitingQueue.removeElementAt( 0 );
      int i=0;
      try {
      synchronized (blockListeners) {
          while (i<blockListeners.size()) {
              int processResult=((JabberBlockListener)blockListeners.elementAt(i)).blockArrived(dataBlock);
              if (processResult==JabberBlockListener.BLOCK_PROCESSED) break;
              if (processResult==JabberBlockListener.NO_MORE_BLOCKS) { 
                  blockListeners.removeElementAt(i); break; 
              }
              i++;
          }
      }
      if( listener != null )
        listener.blockArrived( dataBlock );
      } catch (Exception e) {e.printStackTrace();}
    }
  }

  public void rosterNotify(){
    listener.rosterItemNotify();
  }

  /**
   * Method to stop the dispatcher
   */
  
  public void halt()
  {
    dispatcherActive = false;
  }

  /**
   * Method to tell the listener the connection has been terminated
   *
   * @param exception The exception that caused the termination. This may be
   * null for the situtations where the connection has terminated without an
   * exception.
   */

  public void broadcastTerminatedConnection( Exception exception )
  {
    halt();
    if( listener != null )
      listener.connectionTerminated( exception );
  }

  /**
   * Method to tell the listener the stream is ready for talking to.
   */

  public void broadcastBeginConversation( String SessionId )
  {
    if( listener != null )
      listener.beginConversation(SessionId);
  }
}
/*
  Copyright (c) 2000,2001 Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.jabber;

/**
 * The interface classes that listen for jabber messages should implement
 */

public interface JabberListener
{
  /**
   * Method called once the stream has been set up
   */

  public void beginConversation(String SessionId);

  /**
   * Method to handle an incomming block.
   *
   * @parameter data The incomming block
   */

  public void blockArrived( JabberDataBlock data );

  /**
   * Method called when the stream is terminated for some reason
   *
   * @param exception The exception that caused the termination. May be
   *  null if the connection was terminated normally.
   */
  
  public void rosterItemNotify();

  public void connectionTerminated( Exception e );
}
/*
  Copyright (c) 2000,2001 Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:
 
  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.
 
  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.
 
  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.alsutton.jabber;
import Client.Config;
import Client.NvStorage;
import io.Utf8IOStream;
import java.io.*;
import java.util.*;
import javax.microedition.io.*;
import com.alsutton.jabber.datablocks.*;
import com.alsutton.xmlparser.*;
import util.StringLoader;



/**
 * The stream to a jabber server.
 */

public class JabberStream implements XMLEventListener, Runnable {
    
    private Utf8IOStream iostream;
    
    /**
     * The dispatcher thread.
     */
    
    private JabberDataBlockDispatcher dispatcher;
    
    //private Vector sendQueue;
    
    private boolean rosterNotify;
    
    private String server; // for ping
    
    public void enableRosterNotify(boolean en){ rosterNotify=en; }
    
    /**
     * Constructor. Connects to the server and sends the jabber welcome message.
     *
     */
    
    public JabberStream( String server, String hostAddr, boolean xmppV1, String proxy, JabberListener theListener )
    throws IOException {
        this.server=server;
        boolean waiting=Config.getInstance().istreamWaiting;
        if (proxy==null) {
            StreamConnection connection = (StreamConnection) Connector.open(hostAddr);
            iostream=new Utf8IOStream(connection);
            iostream.setStreamWaiting(waiting);
        } else {
            StreamConnection connection = (StreamConnection) Connector.open(proxy);
            iostream=new Utf8IOStream(connection);
            iostream.setStreamWaiting(waiting);
            
            send( "CONNECT " + hostAddr + " HTTP/1.0 \r\n"
                + "HOST " + hostAddr + "\r\n" 
                + "Pragma: no-cache\r\n" + "\r\n");
            
            String inpLine=iostream.readLine();
            if (inpLine.indexOf("200",0)<=0) throw new IOException(inpLine);
            while (inpLine.length()>0) {
                inpLine=iostream.readLine();
            }
        }

        
        dispatcher = new JabberDataBlockDispatcher();
        if( theListener != null ) {
            setJabberListener( theListener );
        }
        
     
        new Thread( this ). start();
        
        initiateStream(server, xmppV1);
        
        keepAlive=new TimerTaskKeepAlive(Config.getInstance().keepAlive);
    }

    public void initiateStream(final String server, final boolean xmppV1) throws IOException {
        
        //sendQueue=new Vector();
        
        StringBuffer header=new StringBuffer("<stream:stream to='" );
        header.append( server );
        header.append( "' xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams'" );
        if (xmppV1) header.append(" version='1.0'");
        header.append( '>' );
        send(header.toString());
    }
    
    
    /**
     * The threads run method. Handles the parsing of incomming data in its
     * own thread.
     */
    
    public void run() {
        try {
            XMLParser parser = new XMLParser( this );
            parser.parse( iostream );
            //dispatcher.broadcastTerminatedConnection( null );
        } catch( Exception e ) {
            System.out.println("Exception in parser:");
            e.printStackTrace();
            dispatcher.broadcastTerminatedConnection(e);
        }
    }
    
    /**
     * Method to close the connection to the server and tell the listener
     * that the connection has been terminated.
     */
    
    public void close() {
        keepAlive.destroyTask();
        
        dispatcher.setJabberListener( null );
        try {
            send( "</stream:stream>" );
            try {  Thread.sleep(500); } catch (Exception e) {};
            //connection.close();
        } catch( IOException e ) {
            // Ignore an IO Exceptions because they mean that the stream is
            // unavailable, which is irrelevant.
        } finally {
	    iostream.close();
            dispatcher.halt();
        }
    }
    
    /**
     * Method of sending data to the server.
     *
     * @param data The data to send.
     */
    
 /* public void send( byte[] data ) throws IOException
  {
    outStream.write( data );
    outStream.flush();
  }
  */
    
    /**
     * Method of sending data to the server.
     *
     * @param The data to send to the server.
     */
    public void sendKeepAlive() throws IOException {
        switch (Config.getInstance().keepAliveType){
            case 2:
                ping();
                break;
            case 1:
                send("<iq/>");
                break;
            default:
                send(" ");
        }
    }
    
    public void send( String data ) throws IOException {
	iostream.send(new StringBuffer(data));
        //System.out.println(data);
    }
    
    public void sendBuf( StringBuffer data ) throws IOException {
	iostream.send(data);
        //System.out.println(data);
    }
    
    /**
     * Method of sending a Jabber datablock to the server.
     *
     * @param block The data block to send to the server.
     */
    
    public void send( JabberDataBlock block )  { new SendJabberDataBlock(block); }
    
    /**
     * Set the listener to this stream.
     */
    
    public void addBlockListener(JabberBlockListener listener) { 
        dispatcher.addBlockListener(listener);
    }
    public void cancelBlockListener(JabberBlockListener listener) { 
        dispatcher.cancelBlockListener(listener);
    }
    
    public void cancelBlockListenerByClass(Class removeClass) {
        dispatcher.cancelBlockListenerByClass(removeClass);
    }
    
    public void setJabberListener( JabberListener listener ) {
        dispatcher.setJabberListener( listener );
    }
    
    /**
     * The current class being constructed.
     */
    
    private JabberDataBlock currentBlock;
    
    /**
     * Method called when an XML tag is started in the stream comming from the
     * server.
     *
     * @param name Tag name.
     * @param attributes The tags attributes.
     */
    
    public boolean tagStarted( String name, Hashtable attributes ) {
        if (currentBlock!=null){
            
            currentBlock = new JabberDataBlock( name, currentBlock, attributes );
            // TODO: remove stub
            // M55 STUB
//#if !(MIDP1)
            // photo reading
            if ( name.equals("BINVAL") ){
                return true;
            }
//#endif
            
            if (rosterNotify) if (name.equals("item")) dispatcher.rosterNotify();
            
        } else if ( name.equals( "stream:stream" ) ) {
            String SessionId=(String)attributes.get("id");
            dispatcher.broadcastBeginConversation(SessionId);
        } else if ( name.equals( "message" ) )
            currentBlock = new Message( currentBlock, attributes );
        else if ( name.equals("iq") )
            currentBlock = new Iq( currentBlock, attributes );
        else if ( name.equals("presence") )
            currentBlock = new Presence( currentBlock, attributes );
        else currentBlock = new JabberDataBlock(name, null, null);
        return false;
    }
    
    /**
     * Method called when some plain text is encountered in the XML stream
     * comming from the server.
     *
     * @param text The plain text in question
     */
    
    public void plaintextEncountered( String text ) {
        if( currentBlock != null ) {
            currentBlock.setText( text );
        }
    }
    
    public void binValueEncountered( byte binVaule[] ) {
        if( currentBlock != null ) {
            //currentBlock.addText( text );
            currentBlock.addChild(binVaule);
        }
    }
    
    /**
     * The method called when a tag is ended in the stream comming from the
     * server.
     *
     * @param name The name of the tag that has just ended.
     */
    
    public void tagEnded( String name ) {
        if( currentBlock == null )
            return;
        
        JabberDataBlock parent = currentBlock.getParent();
        if( parent == null ) {
            dispatcher.broadcastJabberDataBlock( currentBlock );
            //System.out.println(currentBlock.toString());
        } else
            parent.addChild( currentBlock );
        currentBlock = parent;
    }

    private void ping() {
        JabberDataBlock ping=new Iq(null, Iq.TYPE_SET, "ping");
        ping.addChild("query", null).setNameSpace("jabber:iq:version");
        send(ping);
    }

//#if ZLIB
    public void setZlibCompression() {
        iostream.setStreamCompression();
    }

    public String getStreamStats() {
        return iostream.getStreamStats();
    }
//#endif
    
    private class TimerTaskKeepAlive extends TimerTask{
        private Timer t;
        public TimerTaskKeepAlive(int periodSeconds){
            t=new Timer();
            long period=periodSeconds*1000; // milliseconds
            t.schedule(this, period, period);
        }
        public void run() {
            try {
                System.out.println("Keep-Alive");
                sendKeepAlive();
            } catch (Exception e) { e.printStackTrace(); }
        }
	
        public void destroyTask(){
            if (t!=null){
                this.cancel();
                t.cancel();
                t=null;
            }
        }
    }
    
    private TimerTaskKeepAlive keepAlive;
    
    private class SendJabberDataBlock implements Runnable {
        private JabberDataBlock data;
        public SendJabberDataBlock(JabberDataBlock data) {
            this.data=data;
            new Thread(this).start();
        }
        public void run(){
            try {
                StringBuffer buf=new StringBuffer();
                data.constructXML(buf);
                sendBuf( buf );
            } catch (Exception e) {e.printStackTrace(); }
        }
    }
}
/*
  Copyright (c) 2000,2001 Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.jabber.datablocks;
import com.alsutton.jabber.*;
import java.util.*;

/**
 * Class representing the iq message block
 */

public class Iq extends JabberDataBlock
{
    public final static int TYPE_SET=0;
    public final static int TYPE_GET=1;
    public final static int TYPE_RESULT=2;
    public final static int TYPE_ERROR=3;
    
  /**
   * Constructor including an Attribute list
   *
   * @param _parent The parent of this datablock
   * @param _attributes The list of element attributes
   */

    private static String xmlLang=null;
    
    public static void setXmlLang(String lang){
        xmlLang=lang;
    }
    
  public Iq( JabberDataBlock _parent, Hashtable _attributes )
  {
    super( _parent, _attributes );
  }
  
  public Iq( String to, int typeSet, String id) {
      super();
      setAttribute("xml:lang", xmlLang);
      setAttribute("to", to);
      String type;
      switch (typeSet) {
          case TYPE_SET: type="set"; break;
          case TYPE_GET: type="get"; break;
          case TYPE_ERROR: type="error";
          default: type="result";
      }
      setAttribute("type", type);
      setAttribute("id", id);
  }


  /**
   * Method to return the tag name
   *
   * @return Always the string "iq".
   */
  public String getTagName()
  {
    return "iq";
  }
}
/*
 * IqGetVCard.java
 *
 * Created on 4 Май 2005 г., 22:48
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package com.alsutton.jabber.datablocks;

import com.alsutton.jabber.*;
import java.util.*;
import javax.microedition.lcdui.Image;

/**
 * Class representing the iq message block
 */

public class IqGetVCard extends Iq
{
    public IqGetVCard(String to, String id ) {
        super(to, Iq.TYPE_GET, id );
        addChild("vCard", null).setNameSpace( "vcard-temp" );
    }
    
}
/*
 * IqLast.java
 *
 * Created on 25 Июль 2006 г., 19:14
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package com.alsutton.jabber.datablocks;

import com.alsutton.jabber.JabberDataBlock;
import ui.Time;

/**
 *
 * @author EvgS
 */
public class IqLast extends Iq{
    
    /** Creates a new instance of IqLast */
    public IqLast(JabberDataBlock request, long lastMessageTime) {
        super(request.getAttribute("from"),
              Iq.TYPE_RESULT,
              request.getAttribute("id") );
        JabberDataBlock query=addChild("query",null);
        query.setNameSpace("jabber:iq:last");
        long last=(Time.localTime()-lastMessageTime)/1000;
        query.setAttribute("seconds", String.valueOf(last));
    }
}
/*
 * IqQueryRoster.java
 *
 * Created on 12 Январь 2005 г., 0:17
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
*/

package com.alsutton.jabber.datablocks;

import com.alsutton.jabber.*;
import java.util.*;

/**
 * Class representing the iq message block
 */

public class IqQueryRoster extends Iq
{
  /**
   * Constructor including an Attribute list
   *
   * @param _parent The parent of this datablock
   * @param _attributes The list of element attributes
   */

  /*public IqQueryRoster( JabberDataBlock _parent, Hashtable _attributes )
  {
    super( _parent, _attributes );
  }
   */

  public IqQueryRoster() {
    super(null, Iq.TYPE_GET, "getros" );

    addChild("query", null).setNameSpace( "jabber:iq:roster" );
  }
  
  /** add to roster*/
  public IqQueryRoster(String jid, String name, String group, String subscription) {
    super(null, Iq.TYPE_SET, "addros");

    JabberDataBlock qB = addChild("query", null );
    qB.setNameSpace( "jabber:iq:roster" );
        JabberDataBlock item= qB.addChild("item",null);
        item.setAttribute("jid", jid);
        item.setAttribute("name", name);
        item.setAttribute("subscription", subscription);
        if (group!=null) {
            item.addChild("group",group);
        }
  }
}
/*
 * IqRegister.java
 *
 * Created on 24 Апрель 2005 г., 3:00
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package com.alsutton.jabber.datablocks;

import com.alsutton.jabber.*;
import java.util.*;


/**
 *
 * @author Evg_S
 */
public class IqRegister extends Iq
{
    
    /** Creates a new instance of IqRegister */
    public IqRegister(String username, String password, String id) {
        super(null, Iq.TYPE_SET, id );
        
        JabberDataBlock qB = addChild("query", null );
        qB.setNameSpace( "jabber:iq:register" );
        qB.addChild("username",username);
        qB.addChild("password",password);
        
    }
}
/*
 * IqTimeReply.java
 *
 * Created on 10 Сентябрь 2005 г., 23:15
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package com.alsutton.jabber.datablocks;

import com.alsutton.jabber.JabberDataBlock;

/**
 *
 * @author EvgS
 */
public class IqTimeReply extends Iq{
    
    /** Creates a new instance of IqTimeReply */
    public IqTimeReply(JabberDataBlock request) {
        super(request.getAttribute("from"),
              Iq.TYPE_RESULT,
              request.getAttribute("id") );
        JabberDataBlock query=addChild("query",null);
        query.setNameSpace("jabber:iq:time");
        query.addChild("utc",ui.Time.utcLocalTime());
        query.addChild("display", ui.Time.dispLocalTime());
    }
}
/*
 * IqVersionReply.java
 *
 * Created on 27 Февраль 2005 г., 18:31
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
*
 */

package com.alsutton.jabber.datablocks;

import Info.Version;
import com.alsutton.jabber.*;
import java.util.*;
import Client.*;

/**
 *
 * @author Eugene Stahov
 */
public class IqVersionReply extends Iq{
    
    /** Creates a new instance of IqVersionReply */
    public IqVersionReply(JabberDataBlock request) {
        super(request.getAttribute("from"), Iq.TYPE_RESULT, request.getAttribute("id") );
        JabberDataBlock query=addChild("query",null);
        query.setNameSpace("jabber:iq:version");
        query.addChild("name","Bombus");
        query.addChild("version",Version.getVersionLang());
        String os=Version.getOs();
                //+" Locale="
                //+System.getProperty("microedition.locale");
        query.addChild("os",os);
    }
    
    // constructs version request
    public IqVersionReply(String to) {
        super(to, Iq.TYPE_GET, "getver");
        addChild("query",null).setNameSpace("jabber:iq:version");
    }
    
    ///public static boolean 
    private final static String TOPFIELDS []={ "name",  "version",  "os"  }; 

  
    public static String dispatchVersion(JabberDataBlock data) {
        if (!data.isJabberNameSpace("jabber:iq:version")) return "unknown version namespace";
        StringBuffer vc=new StringBuffer();
        //vc.append((char)0x01);
        for (int i=0; i<TOPFIELDS.length; i++){
            String field=data.getChildBlockText(TOPFIELDS[i]);
            if (field.length()>0) {
                vc.append(TOPFIELDS[i]);
                vc.append((char)0xa0);
                vc.append(field);
                vc.append((char)'\n');
            }
        }
        return vc.toString();
    }
}
/*
  Copyright (c) 2000, Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.jabber.datablocks;
import com.alsutton.jabber.*;
import java.util.*;

/**
 * Title:        Message.java
 * Description:  The class representing a Jabber message object
 */

public class Message extends JabberDataBlock
{
  /**
   * Constructor. Prepares the message destination and body
   *
   * @param to The destination of the message
   * @param message The message text
   */

  public Message( String to, String message , String subject, boolean groupchat)
  {
    super();

    setAttribute( "to", to );
    if( message != null )
      setBodyText( message );
    if (subject!=null) 
        setSubject(subject);
    setTypeAttribute((groupchat)?"groupchat":"chat");
  }

  /**
   * Constructor. Prepares the message destination
   *
   * @param to The destination of the message
   */

  public Message( String to )
  {
      super();
    setAttribute( "to", to );
  }

  /**
   * Default Constructor. Alls for construction of an empty message template.
   */

  public Message()
  {
    this( null );
  }

  /**
   * Constructor for incomming messages
   *
   * @param _parent The parent of this datablock
   * @param _attributes The list of element attributes
   */

  public Message( JabberDataBlock _parent, Hashtable _attributes )
  {
    super( _parent, _attributes );
  }

  /**
   * Method to set the body text. Creates a block with body as it's tag name
   * and inserts the text into it.
   *
   * @param bodyText The string to go in the message body
   */

  public void setBodyText( String text )
  {
    addChild( "body", text );
  }

  /**
   * Method to set the body text written in HTML. Creates a block with html as
   * it's tag name in the xhtml name space and inserts the html into it.
   *
   * @param html The html to go in the message body
   */

  /*
  public void setHTMLBodyText( String html )
  {
    JabberDataBlock body = new JabberDataBlock( "html", null, null );
    body.setNameSpace( "http://www.w3.org/1999/xhtml" );
    body.addText( html );
    addChild( body );
  }
   */

  /**
   * Method to set the message thread. Creates a block with thread as it's tag
   * name and inserts the thread name into it.
   *
   * @param threadName The string to go in the thread block
   */

  /*public void setThread( String text )
  {
    JabberDataBlock thread = new JabberDataBlock( "thread", null, null );
    thread.addText( text );
    addChild( thread );
  }*/

  /**
   * Method to set the subject text. Creates a subject block and inserts the text into it.
   *
   * @param text The string to go in the message subject
   */

  public void setSubject( String text ) { addChild( "subject", text ); }


  /**
   * Method to get the message subject
   *
   * @return A string representing the message subject
   */

  public String getSubject() {  return getChildBlockText( "subject" );  }

  /**
   * Method to get the message body
   *
   * @return The message body as a string
   */

  public String getBody() { return getChildBlockText( "body" ); }
  
  
  public String getOOB() {
      JabberDataBlock oobData=findNamespace("jabber:x:oob");
      StringBuffer oob=new StringBuffer();
      try {
          oob.append("\n");
          oob.append(oobData.getChildBlockText("desc"));
          if (oob.length()>1) oob.append(" ");
          oob.append("( ");
          oob.append(oobData.getChildBlockText("url"));
          oob.append(" )");
      } catch (Exception ex) { return null; }
  
      return oob.toString();
  }

  public String getTimeStamp(){
      JabberDataBlock stamp=findNamespace("jabber:x:delay");
      return (stamp!=null)? stamp.getAttribute("stamp") :null;
  }
  /**
   * Construct a reply message
   *
   * @return A message object destined for the sender of this message with no subject or body
   */

   /*
  public Message constructReply()
  {
    if( attributes == null )
      return null;

    String to = (String) attributes.get( "from" );
    if( to == null )
      return null;

    Message reply = new Message( to );

    String from = (String) attributes.get( "to" );
    if( from != null )
      reply.setAttribute( "from", from );

    String messageType = getAttribute( "type" );
    reply.setAttribute( "type", messageType );

    String thread = getTextForChildBlock( "thread" );
    if( thread != null && thread.length() > 0 )
    {
      setThread( thread );
    }

    String id = getAttribute( "id" );
    if( id != null && id.length() > 0 )
    {
      setAttribute( "id", id );
    }

    return reply;
  }
    */

  /**
   * Get the tag start marker
   *
   * @return The block start tag
   */

  public String getTagName()
  {
    return "message";
  }

  /**
     * Method to get the message from field
     * @return <B>from</B> field as a string
     */
    public String getFrom() {
	//try {
	//    // jep-0146
	//    JabberDataBlock fwd=findNamespace("jabber:x:forward");
	//    JabberDataBlock from=fwd.getChildBlock("from");
	//    return from.getAttribute("jid");
	//} catch (Exception ex) { /* normal case if not forwarded message */ };
	
	try {
	    // jep-0033 extended stanza addressing from psi
	    JabberDataBlock addresses=getChildBlock("addresses");
	    for (Enumeration e=addresses.getChildBlocks().elements(); e.hasMoreElements(); ) {
		JabberDataBlock adr=(JabberDataBlock) e.nextElement();
		if (adr.getTypeAttribute().equals("ofrom")) return adr.getAttribute("jid");
	    }
	} catch (Exception e) { /* normal case if not forwarded message */ };
	
        return (String) attributes.get( "from" );
    }
}
/*
  Copyright (c) 2000, Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.jabber.datablocks;
import com.alsutton.jabber.*;
import images.RosterIcons;

import java.util.*;

/**
 * Class representing the presence message block.
 */

public class Presence extends JabberDataBlock
{
  /**
   * Constructor.
   *
   * @param _parent The parent of this datablock
   * @param _attributes The list of element attributes
   */

  public Presence( JabberDataBlock _parent, Hashtable _attributes )
  {
    super( _parent, _attributes );
  }

  /**
   * Default constructor for outgoing presence messages.
   */

  public Presence(String to, String type){
      super(null,null);
      setAttribute("to",to);
      setAttribute("type",type);
  };
  

  public Presence(int status, int priority, String message)
  {
    super( null, null );
    switch (status){
        case PRESENCE_OFFLINE: setType(PRS_OFFLINE); break;
        case PRESENCE_INVISIBLE: setType(PRS_INVISIBLE); break;
        case PRESENCE_CHAT: setShow(PRS_CHAT);break;
        case PRESENCE_AWAY: setShow(PRS_AWAY);break;
        case PRESENCE_XA: setShow(PRS_XA);break;
        case PRESENCE_DND: setShow(PRS_DND);break;
    }
    if (priority>=0) addChild("priority",String.valueOf(priority));
    if (message!=null) 
        if (message.length()>0) addChild("status",message);
  }

  private StringBuffer text;
  private int presenceCode;
  
  public void dispathch(){
      String show;
      String errText=null;
      text=new StringBuffer();
      String type=getTypeAttribute();
      presenceCode=PRESENCE_AUTH;
      if (type!=null) {
          if (type.equals(PRS_OFFLINE)) { 
              presenceCode=PRESENCE_OFFLINE;
              text.append("offline");
          };
          if (type.equals("subscribe")) text.append(SUBSCRIBE); 
          if (type.equals("subscribed")) text.append(SUBSCRIBED);
          if (type.equals("unsubscribed")) text.append(UNSUBSCRIBED);
          
          if (type.equals(PRS_ERROR)) {
              presenceCode=PRESENCE_ERROR;
              text.append(PRS_ERROR);
              errText=getChildBlock("error").toString();
          }
      } else {
          // online-kinds
          show=getShow(); text.append(show);
          presenceCode=PRESENCE_ONLINE;
          if (show.equals(PRS_CHAT)) presenceCode=PRESENCE_CHAT;
          if (show.equals(PRS_AWAY)) presenceCode=PRESENCE_AWAY;
          if (show.equals(PRS_XA)) presenceCode=PRESENCE_XA;
          if (show.equals(PRS_DND)) presenceCode=PRESENCE_DND;
      }
          
      show=(errText==null)? getChildBlockText("status"):errText;
      if (show.length()>0) {
          text.append('(');
          text.append( show );
          text.append(')');
      }
      
      // priority
      int priority=getPriority();
      if (priority>=0) {
          text.append(" [");
          text.append(getPriority());
          text.append(']');
      }
          
      
  }

  /**
   * Method to set the presence type
   */

  public void setType( String type )
  {
    setAttribute("type", type);
  }
  
  public void setTo(String jid){
      setAttribute("to", jid);
  }

  public int getPriority(){
      try {
          return Integer.parseInt(getChildBlockText("priority"));
      } catch (Exception e) {return -1;}
  }
  
  public void setShow(String text){ addChild("show", text); }
  
  /**
   * Method to get the name of the tag
   */

  public String getTagName()
  {
    return "presence";
  }

  
  public int getTypeIndex() { return presenceCode;}

  public String getPresenceTxt(){ return text.toString(); }
  
  private String getShow(){
      String show=getChildBlockText("show");
      return (show.length()==0)? PRS_ONLINE: getChildBlockText("show");
  }

  /**
     * Method to get the presence <B>from</B> field
     * @return <B>from</B> field as a string
     */
  public String getFrom() {
      return getAttribute("from");
  }
  public final static int PRESENCE_ONLINE=0;
  public final static int PRESENCE_CHAT=1;
  public final static int PRESENCE_AWAY=2;
  public final static int PRESENCE_XA=3;
  public final static int PRESENCE_DND=4;
  public final static int PRESENCE_OFFLINE=5;
  public final static int PRESENCE_ASK=6;
  public final static int PRESENCE_UNKNOWN=7;
  public final static int PRESENCE_INVISIBLE=RosterIcons.ICON_INVISIBLE_INDEX;
  public final static int PRESENCE_ERROR=RosterIcons.ICON_ERROR_INDEX;
  public final static int PRESENCE_TRASH=RosterIcons.ICON_ERROR_INDEX+1;
  public final static int PRESENCE_AUTH=-1;
  
  public final static String PRS_OFFLINE="unavailable";
  public final static String PRS_ERROR="error";
  public final static String PRS_CHAT="chat";
  public final static String PRS_AWAY="away";
  public final static String PRS_XA="xa";
  public final static String PRS_DND="dnd";
  public final static String PRS_ONLINE="online";
  public final static String PRS_INVISIBLE="invisible";

  public final static String SUBSCRIBE="This user wants to subscribe to your presence.";
  public final static String SUBSCRIBED="You are now authorized";
  public final static String UNSUBSCRIBED="Your authorization has been removed!";
  
}
/*
  Copyright (c) 2000,2001 Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of AlSutton.com nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.xmlparser;

/**
 * Exception thrown when the end of a XML stream is reached.
 */

public class EndOfXMLException extends Exception
{
    public String getMessage() {
        return "Unexcepted end of XML stream";
    }
}
/*
  Copyright (c) 2000,2001 Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.xmlparser;

/**
 * Interface for classes wishing to listen to events generated by the parser.
 */

import java.util.*;

public interface XMLEventListener
{
  /**
   * Method called when an tag start is encountered.
   *
   * @param name Tag name.
   * @param attributes The tags attributes.
   */

  public boolean tagStarted( String name, Hashtable attributes );

  /**
   * Method called when some plain text between two tags is encountered.
   *
   * @param text The plain text in question.
   */

  public void plaintextEncountered( String text );

  public void binValueEncountered( byte binvalue[] );

  /**
   * The method called when a tag end is encountered.
   *
   * @param name The name of the tag that has just ended.
   */

  public void tagEnded( String name );
}
/*
  Copyright (c) 2000,2001 Al Sutton (al@alsutton.com)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided with
  the distribution.

  Neither the name of Al Sutton nor the names of its contributors may be used to endorse or promote
  products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.alsutton.xmlparser;

/**
 * The main XML Parser class.
 */

import io.Utf8IOStream;
import java.io.*;

import java.util.*;

public class XMLParser
{
  /** The reader from which the stream is being read  */
    Utf8IOStream iostream;

  /** The handler for XML Events. */

  private XMLEventListener eventHandler;

  /** The root tag for the document. */

  private String rootTag = null;
  
  private static final int MAX_BLOCK_SIZE=4096-3; //max array for m55=4096?

  private final static int MAX_BIN_DATASIZE=100*1024; //100 KB - experimental

  /** Constructor, Used to override default dispatcher.
   *
   * @param _eventHandler The event handle to dispatch events through.
   */

  public XMLParser( XMLEventListener _eventHandler )
  {
    eventHandler = _eventHandler;
  }

  private StringBuffer streamData = new StringBuffer(16);
  /**
   * Method to read until an end condition.
   *
   * @param checker The class used to check if the end condition has occurred.
   * @return A string representation of the data read.
   */
  
  private String readUntilEnd( int tagBracket )
    throws IOException, EndOfXMLException
  {
    //StringBuffer streamData = new StringBuffer(16);
    streamData.setLength(0);
    StringBuffer xmlChar = null;
    int inQuote = 0;    // 0 or " or '
    boolean inXMLchar=false;

    int nextChar = iostream.getNextCharacter();
    if( nextChar == -1 )
      throw new EndOfXMLException();
    while( nextChar != -1)
            //&& (inQuote == true || checker.shouldStop( nextChar ) == false) )
    {
        if (nextChar==tagBracket)
            if (inQuote==0) break;
        
        if (nextChar==' ')
            if (inQuote==0 && tagBracket=='>') break;
        
        switch (nextChar) {
            case '\'': // '
            case '\"': // "
		if (tagBracket=='<') break;
                inQuote=( inQuote==0 )? nextChar: 0;
                break;
            case '&':
                inXMLchar=true;
                xmlChar=new StringBuffer(6);
                break;
            case ';':
                if (inXMLchar) {
                    inXMLchar=false;
                    String s=xmlChar.toString();
                    if (s.equals("amp")) nextChar='&'; else
                    if (s.equals("apos")) nextChar='\''; else
                    if (s.equals("quot")) nextChar='\"'; else
                    if (s.equals("gt")) nextChar='>'; else
                    if (s.equals("lt")) nextChar='<'; else
                    if (xmlChar.charAt(0)=='#') 
                        try {
                            xmlChar.deleteCharAt(0);
                            nextChar=Integer.parseInt(xmlChar.toString());
                        } catch (Exception e) {
                            nextChar=' ';
                        }
                }
            default:
                if (!inXMLchar) {
                    if (streamData.length()<MAX_BLOCK_SIZE) 
                        streamData.append( (char) nextChar );
                    else if (streamData.length()==MAX_BLOCK_SIZE)
                        streamData.append("...");
                } else xmlChar.append( (char) nextChar );
        }
        nextChar = iostream.getNextCharacter();
    }
    
    if( nextChar != '<' && nextChar != '>')
      streamData.append( (char) '\n' );

    String returnData = streamData.toString();
    return returnData;
  }

  
  /**
   * Method to handle the reading and dispatch of tag data.
   */

  private boolean handleTag()
    throws IOException, EndOfXMLException
  {
    boolean startTag = true,
            emptyTag = false,
            hasMoreData = true;
    String tagName = null;
    Hashtable attributes = null;

    do
    {
      String data = readUntilEnd ( '>' );
      int substringStart = 0,
          substringEnd = data.length();

      if( data.startsWith( "/" )  )
      {
        startTag = false;
        substringStart++;
      }

      if( data.endsWith( "/" ) )
      {
        emptyTag = true;
        substringEnd--;
      }

      hasMoreData = data.endsWith( "\n" );
      if( hasMoreData )
        substringEnd--;

      data = data.substring( substringStart, substringEnd );

      if( tagName == null )
      {
        tagName = data;//.toLowerCase();
        continue;
      }

      if( attributes == null )
        attributes = new Hashtable();

      int stringLength = data.length();
      int equalitySign = data.indexOf( '=' );
      if( equalitySign == -1 )
      {
        if( hasMoreData )
          continue;
        else
          break;
      }

      String attributeName = data.substring(0, equalitySign);
      int valueStart = equalitySign+1;
      if( valueStart >= data.length() )
      {
        attributes.put( attributeName, "" );
        continue;
      }

      //substringStart = valueStart;
      //char startChar = data.charAt( substringStart );
      //if( startChar  == '\"' || startChar  == '\'' )
      //  substringStart++;

      //substringEnd = stringLength;
      //char endChar = data.charAt( substringEnd-1 );
      //if( substringEnd > substringStart && endChar  == '\"' || endChar  == '\'' )
      //  substringEnd--;

      attributes.put( attributeName, data.substring( valueStart, stringLength ) );
    } while( hasMoreData );

    if( tagName.startsWith( "?") )
      return false;

    //tagName = tagName;//.toLowerCase();
    
    boolean binflag=false;
    if( startTag )
    {
      if( rootTag == null )
        rootTag = tagName;
      binflag=eventHandler.tagStarted( tagName, attributes);
    }

    if( emptyTag || !startTag )
    {
      eventHandler.tagEnded( tagName );
      if( rootTag != null && tagName.equals( rootTag ) )
        throw new EndOfXMLException();
    }
    
    return binflag;
  }

  /**
   * Method to handle the reading in and dispatching of events for plain text.
   */

  private void handlePlainText()
    throws IOException, EndOfXMLException
  {
    String data = readUntilEnd ( '<' );
    eventHandler.plaintextEncountered( data );
  }

  private void handleBinValue() 
    throws IOException, EndOfXMLException
  {
      int len=0;
      int ibuf=1;
      ByteArrayOutputStream baos=new ByteArrayOutputStream(2048);
      while (true) {
          int nextChar = iostream.getNextCharacter();
          if( nextChar == -1 )
              throw new EndOfXMLException();
          int base64=-1;
          if (nextChar>'A'-1 && nextChar<'Z'+1) base64=nextChar-'A';
          else if (nextChar>'a'-1 && nextChar<'z'+1) base64=nextChar+26-'a';
          else if (nextChar>'0'-1 && nextChar<'9'+1) base64=nextChar+52-'0';
          else if (nextChar=='+') base64=62;
          else if (nextChar=='/') base64=63;
          else if (nextChar=='=') {base64=0; len++;}
          else if (nextChar=='<') break;
          if (base64>=0) ibuf=(ibuf<<6)+base64;
          if (baos.size()<MAX_BIN_DATASIZE)
          if (ibuf>=0x01000000){
              baos.write((ibuf>>16) &0xff);
              if (len==0) baos.write((ibuf>>8) &0xff);
              if (len<2) baos.write(ibuf &0xff);
              //len+=3;
              ibuf=1;
          }
      }
      baos.close();
      //System.out.println(ibuf);
      //System.out.println(baos.size());
      eventHandler.binValueEncountered( baos.toByteArray() );
  }
  /**
   * The main parsing loop.
   *
   * @param _inputReader The reader for the XML stream.
   */

  public void  parse ( Utf8IOStream iostream )
    throws IOException, EndOfXMLException
  {
    this.iostream=iostream;
    boolean binval=false;
    
    //try {
        while( true ) {
            if (binval)
                handleBinValue();
            else
                handlePlainText();
            binval=handleTag();
        }
    //} catch( EndOfXMLException x ) {
        // The EndOfXMLException is purely used to drop out of the
        // continuous loop.
    //} catch ( Exception e ) {
    //    e.printStackTrace();
    //}
 }
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

final class Adler32{

  // largest prime smaller than 65536
  static final private int BASE=65521; 
  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
  static final private int NMAX=5552;

  long adler32(long adler, byte[] buf, int index, int len){
    if(buf == null){ return 1L; }

    long s1=adler&0xffff;
    long s2=(adler>>16)&0xffff;
    int k;

    while(len > 0) {
      k=len<NMAX?len:NMAX;
      len-=k;
      while(k>=16){
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        k-=16;
      }
      if(k!=0){
        do{
          s1+=buf[index++]&0xff; s2+=s1;
        }
        while(--k!=0);
      }
      s1%=BASE;
      s2%=BASE;
    }
    return (s2<<16)|s1;
  }

  /*
  private java.util.zip.Adler32 adler=new java.util.zip.Adler32();
  long adler32(long value, byte[] buf, int index, int len){
    if(value==1) {adler.reset();}
    if(buf==null) {adler.reset();}
    else{adler.update(buf, index, len);}
    return adler.getValue();
  }
  */
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

public 
final class Deflate{

  static final private int MAX_MEM_LEVEL=9;

  static final private int Z_DEFAULT_COMPRESSION=-1;

  static final private int MAX_WBITS=15;            // 32K LZ77 window
  static final private int DEF_MEM_LEVEL=8;

  static class Config{
    int good_length; // reduce lazy search above this match length
    int max_lazy;    // do not perform lazy search above this match length
    int nice_length; // quit search above this match length
    int max_chain;
    int func;
    Config(int good_length, int max_lazy, 
	   int nice_length, int max_chain, int func){
      this.good_length=good_length;
      this.max_lazy=max_lazy;
      this.nice_length=nice_length;
      this.max_chain=max_chain;
      this.func=func;
    }
  }
  
  static final private int STORED=0;
  static final private int FAST=1;
  static final private int SLOW=2;
  static final private Config[] config_table;    
  static{
    config_table=new Config[10];
    //                         good  lazy  nice  chain
    config_table[0]=new Config(0,    0,    0,    0, STORED);
    config_table[1]=new Config(4,    4,    8,    4, FAST);
    config_table[2]=new Config(4,    5,   16,    8, FAST);
    config_table[3]=new Config(4,    6,   32,   32, FAST);

    config_table[4]=new Config(4,    4,   16,   16, SLOW);
    config_table[5]=new Config(8,   16,   32,   32, SLOW);
    config_table[6]=new Config(8,   16,  128,  128, SLOW);
    config_table[7]=new Config(8,   32,  128,  256, SLOW);
    config_table[8]=new Config(32, 128,  258, 1024, SLOW);
    config_table[9]=new Config(32, 258,  258, 4096, SLOW);
  }

  static final private String[] z_errmsg = {
    "need dictionary",     // Z_NEED_DICT       2
    "stream end",          // Z_STREAM_END      1
    "",                    // Z_OK              0
    "file error",          // Z_ERRNO         (-1)
    "stream error",        // Z_STREAM_ERROR  (-2)
    "data error",          // Z_DATA_ERROR    (-3)
    "insufficient memory", // Z_MEM_ERROR     (-4)
    "buffer error",        // Z_BUF_ERROR     (-5)
    "incompatible version",// Z_VERSION_ERROR (-6)
    ""
  };

  // block not completed, need more input or more output
  static final private int NeedMore=0; 

  // block flush performed
  static final private int BlockDone=1; 

  // finish started, need only more output at next deflate
  static final private int FinishStarted=2;

  // finish done, accept no more input or output
  static final private int FinishDone=3;

  // preset dictionary flag in zlib header
  static final private int PRESET_DICT=0x20;

  static final private int Z_FILTERED=1;
  static final private int Z_HUFFMAN_ONLY=2;
  static final private int Z_DEFAULT_STRATEGY=0;

  static final private int Z_NO_FLUSH=0;
  static final private int Z_PARTIAL_FLUSH=1;
  static final private int Z_SYNC_FLUSH=2;
  static final private int Z_FULL_FLUSH=3;
  static final private int Z_FINISH=4;

  static final private int Z_OK=0;
  static final private int Z_STREAM_END=1;
  static final private int Z_NEED_DICT=2;
  static final private int Z_ERRNO=-1;
  static final private int Z_STREAM_ERROR=-2;
  static final private int Z_DATA_ERROR=-3;
  static final private int Z_MEM_ERROR=-4;
  static final private int Z_BUF_ERROR=-5;
  static final private int Z_VERSION_ERROR=-6;

  static final private int INIT_STATE=42;
  static final private int BUSY_STATE=113;
  static final private int FINISH_STATE=666;

  // The deflate compression method
  static final private int Z_DEFLATED=8;

  static final private int STORED_BLOCK=0;
  static final private int STATIC_TREES=1;
  static final private int DYN_TREES=2;

  // The three kinds of block type
  static final private int Z_BINARY=0;
  static final private int Z_ASCII=1;
  static final private int Z_UNKNOWN=2;

  static final private int Buf_size=8*2;

  // repeat previous bit length 3-6 times (2 bits of repeat count)
  static final private int REP_3_6=16; 

  // repeat a zero length 3-10 times  (3 bits of repeat count)
  static final private int REPZ_3_10=17; 

  // repeat a zero length 11-138 times  (7 bits of repeat count)
  static final private int REPZ_11_138=18; 

  static final private int MIN_MATCH=3;
  static final private int MAX_MATCH=258;
  static final private int MIN_LOOKAHEAD=(MAX_MATCH+MIN_MATCH+1);

  static final private int MAX_BITS=15;
  static final private int D_CODES=30;
  static final private int BL_CODES=19;
  static final private int LENGTH_CODES=29;
  static final private int LITERALS=256;
  static final private int L_CODES=(LITERALS+1+LENGTH_CODES);
  static final private int HEAP_SIZE=(2*L_CODES+1);

  static final private int END_BLOCK=256;

  ZStream strm;         // pointer back to this zlib stream
  int status;           // as the name implies
  byte[] pending_buf;   // output still pending
  int pending_buf_size; // size of pending_buf
  int pending_out;      // next pending byte to output to the stream
  int pending;          // nb of bytes in the pending buffer
  int noheader;         // suppress zlib header and adler32
  byte data_type;       // UNKNOWN, BINARY or ASCII
  byte method;          // STORED (for zip only) or DEFLATED
  int last_flush;       // value of flush param for previous deflate call

  int w_size;           // LZ77 window size (32K by default)
  int w_bits;           // log2(w_size)  (8..16)
  int w_mask;           // w_size - 1

  byte[] window;
  // Sliding window. Input bytes are read into the second half of the window,
  // and move to the first half later to keep a dictionary of at least wSize
  // bytes. With this organization, matches are limited to a distance of
  // wSize-MAX_MATCH bytes, but this ensures that IO is always
  // performed with a length multiple of the block size. Also, it limits
  // the window size to 64K, which is quite useful on MSDOS.
  // To do: use the user input buffer as sliding window.

  int window_size;
  // Actual size of window: 2*wSize, except when the user input buffer
  // is directly used as sliding window.

  short[] prev;
  // Link to older string with same hash index. To limit the size of this
  // array to 64K, this link is maintained only for the last 32K strings.
  // An index in this array is thus a window index modulo 32K.

  short[] head; // Heads of the hash chains or NIL.

  int ins_h;          // hash index of string to be inserted
  int hash_size;      // number of elements in hash table
  int hash_bits;      // log2(hash_size)
  int hash_mask;      // hash_size-1

  // Number of bits by which ins_h must be shifted at each input
  // step. It must be such that after MIN_MATCH steps, the oldest
  // byte no longer takes part in the hash key, that is:
  // hash_shift * MIN_MATCH >= hash_bits
  int hash_shift;

  // Window position at the beginning of the current output block. Gets
  // negative when the window is moved backwards.

  int block_start;

  int match_length;           // length of best match
  int prev_match;             // previous match
  int match_available;        // set if previous match exists
  int strstart;               // start of string to insert
  int match_start;            // start of matching string
  int lookahead;              // number of valid bytes ahead in window

  // Length of the best match at previous step. Matches not greater than this
  // are discarded. This is used in the lazy match evaluation.
  int prev_length;

  // To speed up deflation, hash chains are never searched beyond this
  // length.  A higher limit improves compression ratio but degrades the speed.
  int max_chain_length;

  // Attempt to find a better match only when the current match is strictly
  // smaller than this value. This mechanism is used only for compression
  // levels >= 4.
  int max_lazy_match;

  // Insert new strings in the hash table only if the match length is not
  // greater than this length. This saves time but degrades compression.
  // max_insert_length is used only for compression levels <= 3.

  int level;    // compression level (1..9)
  int strategy; // favor or force Huffman coding

  // Use a faster search when the previous match is longer than this
  int good_match;

  // Stop searching when current match exceeds this
  int nice_match;

  short[] dyn_ltree;       // literal and length tree
  short[] dyn_dtree;       // distance tree
  short[] bl_tree;         // Huffman tree for bit lengths

  Tree l_desc=new Tree();  // desc for literal tree
  Tree d_desc=new Tree();  // desc for distance tree
  Tree bl_desc=new Tree(); // desc for bit length tree

  // number of codes at each bit length for an optimal tree
  short[] bl_count=new short[MAX_BITS+1];

  // heap used to build the Huffman trees
  int[] heap=new int[2*L_CODES+1];

  int heap_len;               // number of elements in the heap
  int heap_max;               // element of largest frequency
  // The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
  // The same heap array is used to build all trees.

  // Depth of each subtree used as tie breaker for trees of equal frequency
  byte[] depth=new byte[2*L_CODES+1];

  int l_buf;               // index for literals or lengths */

  // Size of match buffer for literals/lengths.  There are 4 reasons for
  // limiting lit_bufsize to 64K:
  //   - frequencies can be kept in 16 bit counters
  //   - if compression is not successful for the first block, all input
  //     data is still in the window so we can still emit a stored block even
  //     when input comes from standard input.  (This can also be done for
  //     all blocks if lit_bufsize is not greater than 32K.)
  //   - if compression is not successful for a file smaller than 64K, we can
  //     even emit a stored file instead of a stored block (saving 5 bytes).
  //     This is applicable only for zip (not gzip or zlib).
  //   - creating new Huffman trees less frequently may not provide fast
  //     adaptation to changes in the input data statistics. (Take for
  //     example a binary file with poorly compressible code followed by
  //     a highly compressible string table.) Smaller buffer sizes give
  //     fast adaptation but have of course the overhead of transmitting
  //     trees more frequently.
  //   - I can't count above 4
  int lit_bufsize;

  int last_lit;      // running index in l_buf

  // Buffer for distances. To simplify the code, d_buf and l_buf have
  // the same number of elements. To use different lengths, an extra flag
  // array would be necessary.

  int d_buf;         // index of pendig_buf

  int opt_len;        // bit length of current block with optimal trees
  int static_len;     // bit length of current block with static trees
  int matches;        // number of string matches in current block
  int last_eob_len;   // bit length of EOB code for last block

  // Output buffer. bits are inserted starting at the bottom (least
  // significant bits).
  short bi_buf;

  // Number of valid bits in bi_buf.  All bits above the last valid bit
  // are always zero.
  int bi_valid;

  Deflate(){
    dyn_ltree=new short[HEAP_SIZE*2];
    dyn_dtree=new short[(2*D_CODES+1)*2]; // distance tree
    bl_tree=new short[(2*BL_CODES+1)*2];  // Huffman tree for bit lengths
  }

  void lm_init() {
    window_size=2*w_size;

    head[hash_size-1]=0;
    for(int i=0; i<hash_size-1; i++){
      head[i]=0;
    }

    // Set the default configuration parameters:
    max_lazy_match   = Deflate.config_table[level].max_lazy;
    good_match       = Deflate.config_table[level].good_length;
    nice_match       = Deflate.config_table[level].nice_length;
    max_chain_length = Deflate.config_table[level].max_chain;

    strstart = 0;
    block_start = 0;
    lookahead = 0;
    match_length = prev_length = MIN_MATCH-1;
    match_available = 0;
    ins_h = 0;
  }

  // Initialize the tree data structures for a new zlib stream.
  void tr_init(){

    l_desc.dyn_tree = dyn_ltree;
    l_desc.stat_desc = StaticTree.static_l_desc;

    d_desc.dyn_tree = dyn_dtree;
    d_desc.stat_desc = StaticTree.static_d_desc;

    bl_desc.dyn_tree = bl_tree;
    bl_desc.stat_desc = StaticTree.static_bl_desc;

    bi_buf = 0;
    bi_valid = 0;
    last_eob_len = 8; // enough lookahead for inflate

    // Initialize the first block of the first file:
    init_block();
  }

  void init_block(){
    // Initialize the trees.
    for(int i = 0; i < L_CODES; i++) dyn_ltree[i*2] = 0;
    for(int i= 0; i < D_CODES; i++) dyn_dtree[i*2] = 0;
    for(int i= 0; i < BL_CODES; i++) bl_tree[i*2] = 0;

    dyn_ltree[END_BLOCK*2] = 1;
    opt_len = static_len = 0;
    last_lit = matches = 0;
  }

  // Restore the heap property by moving down the tree starting at node k,
  // exchanging a node with the smallest of its two sons if necessary, stopping
  // when the heap property is re-established (each father smaller than its
  // two sons).
  void pqdownheap(short[] tree,  // the tree to restore
		  int k          // node to move down
		  ){
    int v = heap[k];
    int j = k << 1;  // left son of k
    while (j <= heap_len) {
      // Set j to the smallest of the two sons:
      if (j < heap_len &&
	  smaller(tree, heap[j+1], heap[j], depth)){
	j++;
      }
      // Exit if v is smaller than both sons
      if(smaller(tree, v, heap[j], depth)) break;

      // Exchange v with the smallest son
      heap[k]=heap[j];  k = j;
      // And continue down the tree, setting j to the left son of k
      j <<= 1;
    }
    heap[k] = v;
  }

  static boolean smaller(short[] tree, int n, int m, byte[] depth){
    short tn2=tree[n*2];
    short tm2=tree[m*2];
    return (tn2<tm2 ||
	    (tn2==tm2 && depth[n] <= depth[m]));
  }

  // Scan a literal or distance tree to determine the frequencies of the codes
  // in the bit length tree.
  void scan_tree (short[] tree,// the tree to be scanned
		  int max_code // and its largest code of non zero frequency
		  ){
    int n;                     // iterates over all tree elements
    int prevlen = -1;          // last emitted length
    int curlen;                // length of current code
    int nextlen = tree[0*2+1]; // length of next code
    int count = 0;             // repeat count of the current code
    int max_count = 7;         // max repeat count
    int min_count = 4;         // min repeat count

    if (nextlen == 0){ max_count = 138; min_count = 3; }
    tree[(max_code+1)*2+1] = (short)0xffff; // guard

    for(n = 0; n <= max_code; n++) {
      curlen = nextlen; nextlen = tree[(n+1)*2+1];
      if(++count < max_count && curlen == nextlen) {
	continue;
      }
      else if(count < min_count) {
	bl_tree[curlen*2] += count;
      }
      else if(curlen != 0) {
	if(curlen != prevlen) bl_tree[curlen*2]++;
	bl_tree[REP_3_6*2]++;
      }
      else if(count <= 10) {
	bl_tree[REPZ_3_10*2]++;
      }
      else{
	bl_tree[REPZ_11_138*2]++;
      }
      count = 0; prevlen = curlen;
      if(nextlen == 0) {
	max_count = 138; min_count = 3;
      }
      else if(curlen == nextlen) {
	max_count = 6; min_count = 3;
      }
      else{
	max_count = 7; min_count = 4;
      }
    }
  }

  // Construct the Huffman tree for the bit lengths and return the index in
  // bl_order of the last bit length code to send.
  int build_bl_tree(){
    int max_blindex;  // index of last bit length code of non zero freq

    // Determine the bit length frequencies for literal and distance trees
    scan_tree(dyn_ltree, l_desc.max_code);
    scan_tree(dyn_dtree, d_desc.max_code);

    // Build the bit length tree:
    bl_desc.build_tree(this);
    // opt_len now includes the length of the tree representations, except
    // the lengths of the bit lengths codes and the 5+5+4 bits for the counts.

    // Determine the number of bit length codes to send. The pkzip format
    // requires that at least 4 bit length codes be sent. (appnote.txt says
    // 3 but the actual value used is 4.)
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
      if (bl_tree[Tree.bl_order[max_blindex]*2+1] != 0) break;
    }
    // Update opt_len to include the bit length tree and counts
    opt_len += 3*(max_blindex+1) + 5+5+4;

    return max_blindex;
  }


  // Send the header for a block using dynamic Huffman trees: the counts, the
  // lengths of the bit length codes, the literal tree and the distance tree.
  // IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
  void send_all_trees(int lcodes, int dcodes, int blcodes){
    int rank;                    // index in bl_order

    send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt
    send_bits(dcodes-1,   5);
    send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(bl_tree[Tree.bl_order[rank]*2+1], 3);
    }
    send_tree(dyn_ltree, lcodes-1); // literal tree
    send_tree(dyn_dtree, dcodes-1); // distance tree
  }

  // Send a literal or distance tree in compressed form, using the codes in
  // bl_tree.
  void send_tree (short[] tree,// the tree to be sent
		  int max_code // and its largest code of non zero frequency
		  ){
    int n;                     // iterates over all tree elements
    int prevlen = -1;          // last emitted length
    int curlen;                // length of current code
    int nextlen = tree[0*2+1]; // length of next code
    int count = 0;             // repeat count of the current code
    int max_count = 7;         // max repeat count
    int min_count = 4;         // min repeat count

    if (nextlen == 0){ max_count = 138; min_count = 3; }

    for (n = 0; n <= max_code; n++) {
      curlen = nextlen; nextlen = tree[(n+1)*2+1];
      if(++count < max_count && curlen == nextlen) {
	continue;
      }
      else if(count < min_count) {
	do { send_code(curlen, bl_tree); } while (--count != 0);
      }
      else if(curlen != 0){
	if(curlen != prevlen){
	  send_code(curlen, bl_tree); count--;
	}
	send_code(REP_3_6, bl_tree); 
	send_bits(count-3, 2);
      }
      else if(count <= 10){
	send_code(REPZ_3_10, bl_tree); 
	send_bits(count-3, 3);
      }
      else{
	send_code(REPZ_11_138, bl_tree);
	send_bits(count-11, 7);
      }
      count = 0; prevlen = curlen;
      if(nextlen == 0){
	max_count = 138; min_count = 3;
      }
      else if(curlen == nextlen){
	max_count = 6; min_count = 3;
      }
      else{
	max_count = 7; min_count = 4;
      }
    }
  }

  // Output a byte on the stream.
  // IN assertion: there is enough room in pending_buf.
  final void put_byte(byte[] p, int start, int len){
    System.arraycopy(p, start, pending_buf, pending, len);
    pending+=len;
  }

  final void put_byte(byte c){
    pending_buf[pending++]=c;
  }
  final void put_short(int w) {
    put_byte((byte)(w/*&0xff*/));
    put_byte((byte)(w>>>8));
  }
  final void putShortMSB(int b){
    put_byte((byte)(b>>8));
    put_byte((byte)(b/*&0xff*/));
  }   

  final void send_code(int c, short[] tree){
    int c2=c*2;
    send_bits((tree[c2]&0xffff), (tree[c2+1]&0xffff));
  }

  void send_bits(int value, int length){
    int len = length;
    if (bi_valid > (int)Buf_size - len) {
      int val = value;
//      bi_buf |= (val << bi_valid);
      bi_buf |= ((val << bi_valid)&0xffff);
      put_short(bi_buf);
      bi_buf = (short)(val >>> (Buf_size - bi_valid));
      bi_valid += len - Buf_size;
    } else {
//      bi_buf |= (value) << bi_valid;
      bi_buf |= (((value) << bi_valid)&0xffff);
      bi_valid += len;
    }
  }

  // Send one empty static block to give enough lookahead for inflate.
  // This takes 10 bits, of which 7 may remain in the bit buffer.
  // The current inflate code requires 9 bits of lookahead. If the
  // last two codes for the previous block (real code plus EOB) were coded
  // on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
  // the last real code. In this case we send two empty static blocks instead
  // of one. (There are no problems if the previous block is stored or fixed.)
  // To simplify the code, we assume the worst case of last real code encoded
  // on one bit only.
  void _tr_align(){
    send_bits(STATIC_TREES<<1, 3);
    send_code(END_BLOCK, StaticTree.getStatic_ltree());

    bi_flush();

    // Of the 10 bits for the empty block, we have already sent
    // (10 - bi_valid) bits. The lookahead for the last real code (before
    // the EOB of the previous block) was thus at least one plus the length
    // of the EOB plus what we have just sent of the empty static block.
    if (1 + last_eob_len + 10 - bi_valid < 9) {
      send_bits(STATIC_TREES<<1, 3);
      send_code(END_BLOCK, StaticTree.getStatic_ltree());
      bi_flush();
    }
    last_eob_len = 7;
  }


  // Save the match info and tally the frequency counts. Return true if
  // the current block must be flushed.
  boolean _tr_tally (int dist, // distance of matched string
		     int lc // match length-MIN_MATCH or unmatched char (if dist==0)
		     ){

    pending_buf[d_buf+last_lit*2] = (byte)(dist>>>8);
    pending_buf[d_buf+last_lit*2+1] = (byte)dist;

    pending_buf[l_buf+last_lit] = (byte)lc; last_lit++;

    if (dist == 0) {
      // lc is the unmatched char
      dyn_ltree[lc*2]++;
    } 
    else {
      matches++;
      // Here, lc is the match length - MIN_MATCH
      dist--;             // dist = match distance - 1
      dyn_ltree[(Tree.getLength_code(lc)+LITERALS+1)*2]++;
      dyn_dtree[Tree.d_code(dist)*2]++;
    }

    if ((last_lit & 0x1fff) == 0 && level > 2) {
      // Compute an upper bound for the compressed length
      int out_length = last_lit*8;
      int in_length = strstart - block_start;
      int dcode;
      for (dcode = 0; dcode < D_CODES; dcode++) {
	out_length += (int)dyn_dtree[dcode*2] *
	  (5L+Tree.extra_dbits[dcode]);
      }
      out_length >>>= 3;
      if ((matches < (last_lit/2)) && out_length < in_length/2) return true;
    }

    return (last_lit == lit_bufsize-1);
    // We avoid equality with lit_bufsize because of wraparound at 64K
    // on 16 bit machines and because stored blocks are restricted to
    // 64K-1 bytes.
  }

  // Send the block data compressed using the given Huffman trees
  void compress_block(short[] ltree, short[] dtree){
    int  dist;      // distance of matched string
    int lc;         // match length or unmatched char (if dist == 0)
    int lx = 0;     // running index in l_buf
    int code;       // the code to send
    int extra;      // number of extra bits to send

    if (last_lit != 0){
      do{
	dist=((pending_buf[d_buf+lx*2]<<8)&0xff00)|
	  (pending_buf[d_buf+lx*2+1]&0xff);
	lc=(pending_buf[l_buf+lx])&0xff; lx++;

	if(dist == 0){
	  send_code(lc, ltree); // send a literal byte
	} 
	else{
	  // Here, lc is the match length - MIN_MATCH
	  code = Tree.getLength_code(lc);

	  send_code(code+LITERALS+1, ltree); // send the length code
	  extra = Tree.extra_lbits[code];
	  if(extra != 0){
	    lc -= Tree.base_length[code];
	    send_bits(lc, extra);       // send the extra length bits
	  }
	  dist--; // dist is now the match distance - 1
	  code = Tree.d_code(dist);

	  send_code(code, dtree);       // send the distance code
	  extra = Tree.extra_dbits[code];
	  if (extra != 0) {
	    dist -= Tree.base_dist[code];
	    send_bits(dist, extra);   // send the extra distance bits
	  }
	} // literal or match pair ?

	// Check that the overlay between pending_buf and d_buf+l_buf is ok:
      }
      while (lx < last_lit);
    }

    send_code(END_BLOCK, ltree);
    last_eob_len = ltree[END_BLOCK*2+1];
  }

  // Set the data type to ASCII or BINARY, using a crude approximation:
  // binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
  // IN assertion: the fields freq of dyn_ltree are set and the total of all
  // frequencies does not exceed 64K (to fit in an int on 16 bit machines).
  void set_data_type(){
    int n = 0;
    int  ascii_freq = 0;
    int  bin_freq = 0;
    while(n<7){ bin_freq += dyn_ltree[n*2]; n++;}
    while(n<128){ ascii_freq += dyn_ltree[n*2]; n++;}
    while(n<LITERALS){ bin_freq += dyn_ltree[n*2]; n++;}
    data_type=(byte)(bin_freq > (ascii_freq >>> 2) ? Z_BINARY : Z_ASCII);
  }

  // Flush the bit buffer, keeping at most 7 bits in it.
  void bi_flush(){
    if (bi_valid == 16) {
      put_short(bi_buf);
      bi_buf=0;
      bi_valid=0;
    }
    else if (bi_valid >= 8) {
      put_byte((byte)bi_buf);
      bi_buf>>>=8;
      bi_valid-=8;
    }
  }

  // Flush the bit buffer and align the output on a byte boundary
  void bi_windup(){
    if (bi_valid > 8) {
      put_short(bi_buf);
    } else if (bi_valid > 0) {
      put_byte((byte)bi_buf);
    }
    bi_buf = 0;
    bi_valid = 0;
  }

  // Copy a stored block, storing first the length and its
  // one's complement if requested.
  void copy_block(int buf,         // the input data
		  int len,         // its length
		  boolean header   // true if block header must be written
		  ){
    int index=0;
    bi_windup();      // align on byte boundary
    last_eob_len = 8; // enough lookahead for inflate

    if (header) {
      put_short((short)len);   
      put_short((short)~len);
    }

    //  while(len--!=0) {
    //    put_byte(window[buf+index]);
    //    index++;
    //  }
    put_byte(window, buf, len);
  }

  void flush_block_only(boolean eof){
    _tr_flush_block(block_start>=0 ? block_start : -1,
		    strstart-block_start,
		    eof);
    block_start=strstart;
    strm.flush_pending();
  }

  // Copy without compression as much as possible from the input stream, return
  // the current block state.
  // This function does not insert new strings in the dictionary since
  // uncompressible data is probably not useful. This function is used
  // only for the level=0 compression option.
  // NOTE: this function should be optimized to avoid extra copying from
  // window to pending_buf.
  int deflate_stored(int flush){
    // Stored blocks are limited to 0xffff bytes, pending_buf is limited
    // to pending_buf_size, and each stored block has a 5 byte header:

    int max_block_size = 0xffff;
    int max_start;

    if(max_block_size > pending_buf_size - 5) {
      max_block_size = pending_buf_size - 5;
    }

    // Copy as much as possible from input to output:
    while(true){
      // Fill the window as much as possible:
      if(lookahead<=1){
	fill_window();
	if(lookahead==0 && flush==Z_NO_FLUSH) return NeedMore;
	if(lookahead==0) break; // flush the current block
      }

      strstart+=lookahead;
      lookahead=0;

      // Emit a stored block if pending_buf will be full:
      max_start=block_start+max_block_size;
      if(strstart==0|| strstart>=max_start) {
	// strstart == 0 is possible when wraparound on 16-bit machine
	lookahead = (int)(strstart-max_start);
	strstart = (int)max_start;
      
	flush_block_only(false);
	if(strm.avail_out==0) return NeedMore;

      }

      // Flush if we may have to slide, otherwise block_start may become
      // negative and the data will be gone:
      if(strstart-block_start >= w_size-MIN_LOOKAHEAD) {
	flush_block_only(false);
	if(strm.avail_out==0) return NeedMore;
      }
    }

    flush_block_only(flush == Z_FINISH);
    if(strm.avail_out==0)
      return (flush == Z_FINISH) ? FinishStarted : NeedMore;

    return flush == Z_FINISH ? FinishDone : BlockDone;
  }

  // Send a stored block
  void _tr_stored_block(int buf,        // input block
			int stored_len, // length of input block
			boolean eof     // true if this is the last block for a file
			){
    send_bits((STORED_BLOCK<<1)+(eof?1:0), 3);  // send block type
    copy_block(buf, stored_len, true);          // with header
  }

  // Determine the best encoding for the current block: dynamic trees, static
  // trees or store, and output the encoded block to the zip file.
  void _tr_flush_block(int buf,        // input block, or NULL if too old
		       int stored_len, // length of input block
		       boolean eof     // true if this is the last block for a file
		       ) {
    int opt_lenb, static_lenb;// opt_len and static_len in bytes
    int max_blindex = 0;      // index of last bit length code of non zero freq

    // Build the Huffman trees unless a stored block is forced
    if(level > 0) {
      // Check if the file is ascii or binary
      if(data_type == Z_UNKNOWN) set_data_type();

      // Construct the literal and distance trees
      l_desc.build_tree(this);

      d_desc.build_tree(this);

      // At this point, opt_len and static_len are the total bit lengths of
      // the compressed block data, excluding the tree representations.

      // Build the bit length tree for the above two trees, and get the index
      // in bl_order of the last bit length code to send.
      max_blindex=build_bl_tree();

      // Determine the best encoding. Compute first the block length in bytes
      opt_lenb=(opt_len+3+7)>>>3;
      static_lenb=(static_len+3+7)>>>3;

      if(static_lenb<=opt_lenb) opt_lenb=static_lenb;
    }
    else {
      opt_lenb=static_lenb=stored_len+5; // force a stored block
    }

    if(stored_len+4<=opt_lenb && buf != -1){
      // 4: two words for the lengths
      // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
      // Otherwise we can't have processed more than WSIZE input bytes since
      // the last block flush, because compression would have been
      // successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
      // transform a block into a stored block.
      _tr_stored_block(buf, stored_len, eof);
    }
    else if(static_lenb == opt_lenb){
      send_bits((STATIC_TREES<<1)+(eof?1:0), 3);
      compress_block(StaticTree.getStatic_ltree(), StaticTree.static_dtree);
    }
    else{
      send_bits((DYN_TREES<<1)+(eof?1:0), 3);
      send_all_trees(l_desc.max_code+1, d_desc.max_code+1, max_blindex+1);
      compress_block(dyn_ltree, dyn_dtree);
    }

    // The above check is made mod 2^32, for files larger than 512 MB
    // and uLong implemented on 32 bits.

    init_block();

    if(eof){
      bi_windup();
    }
  }

  // Fill the window when the lookahead becomes insufficient.
  // Updates strstart and lookahead.
  //
  // IN assertion: lookahead < MIN_LOOKAHEAD
  // OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
  //    At least one byte has been read, or avail_in == 0; reads are
  //    performed for at least two bytes (required for the zip translate_eol
  //    option -- not supported here).
  void fill_window(){
    int n, m;
    int p;
    int more;    // Amount of free space at the end of the window.

    do{
      more = (window_size-lookahead-strstart);

      // Deal with !@#$% 64K limit:
      if(more==0 && strstart==0 && lookahead==0){
	more = w_size;
      } 
      else if(more==-1) {
	// Very unlikely, but possible on 16 bit machine if strstart == 0
	// and lookahead == 1 (input done one byte at time)
	more--;

	// If the window is almost full and there is insufficient lookahead,
	// move the upper half to the lower one to make room in the upper half.
      }
      else if(strstart >= w_size+ w_size-MIN_LOOKAHEAD) {
	System.arraycopy(window, w_size, window, 0, w_size);
	match_start-=w_size;
	strstart-=w_size; // we now have strstart >= MAX_DIST
	block_start-=w_size;

	// Slide the hash table (could be avoided with 32 bit values
	// at the expense of memory usage). We slide even when level == 0
	// to keep the hash table consistent if we switch back to level > 0
	// later. (Using level 0 permanently is not an optimal usage of
	// zlib, so we don't care about this pathological case.)

	n = hash_size;
	p=n;
	do {
	  m = (head[--p]&0xffff);
	  head[p]=(m>=w_size ? (short)(m-w_size) : 0);
	}
	while (--n != 0);

	n = w_size;
	p = n;
	do {
	  m = (prev[--p]&0xffff);
	  prev[p] = (m >= w_size ? (short)(m-w_size) : 0);
	  // If n is not on any hash chain, prev[n] is garbage but
	  // its value will never be used.
	}
	while (--n!=0);
	more += w_size;
      }

      if (strm.avail_in == 0) return;

      // If there was no sliding:
      //    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
      //    more == window_size - lookahead - strstart
      // => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
      // => more >= window_size - 2*WSIZE + 2
      // In the BIG_MEM or MMAP case (not yet supported),
      //   window_size == input_size + MIN_LOOKAHEAD  &&
      //   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
      // Otherwise, window_size == 2*WSIZE so more >= 2.
      // If there was sliding, more >= WSIZE. So in all cases, more >= 2.

      n = strm.read_buf(window, strstart + lookahead, more);
      lookahead += n;

      // Initialize the hash value now that we have some input:
      if(lookahead >= MIN_MATCH) {
	ins_h = window[strstart]&0xff;
	ins_h=(((ins_h)<<hash_shift)^(window[strstart+1]&0xff))&hash_mask;
      }
      // If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
      // but this is not important since only literal bytes will be emitted.
    }
    while (lookahead < MIN_LOOKAHEAD && strm.avail_in != 0);
  }

  // Compress as much as possible from the input stream, return the current
  // block state.
  // This function does not perform lazy evaluation of matches and inserts
  // new strings in the dictionary only for unmatched strings or for short
  // matches. It is used only for the fast compression options.
  int deflate_fast(int flush){
//    short hash_head = 0; // head of the hash chain
    int hash_head = 0; // head of the hash chain
    boolean bflush;      // set if current block must be flushed

    while(true){
      // Make sure that we always have enough lookahead, except
      // at the end of the input file. We need MAX_MATCH bytes
      // for the next match, plus MIN_MATCH bytes to insert the
      // string following the next match.
      if(lookahead < MIN_LOOKAHEAD){
	fill_window();
	if(lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH){
	  return NeedMore;
	}
	if(lookahead == 0) break; // flush the current block
      }

      // Insert the string window[strstart .. strstart+2] in the
      // dictionary, and set hash_head to the head of the hash chain:
      if(lookahead >= MIN_MATCH){
	ins_h=(((ins_h)<<hash_shift)^(window[(strstart)+(MIN_MATCH-1)]&0xff))&hash_mask;

//	prev[strstart&w_mask]=hash_head=head[ins_h];
        hash_head=(head[ins_h]&0xffff);
	prev[strstart&w_mask]=head[ins_h];
	head[ins_h]=(short)strstart;
      }

      // Find the longest match, discarding those <= prev_length.
      // At this point we have always match_length < MIN_MATCH

      if(hash_head!=0L && 
	 ((strstart-hash_head)&0xffff) <= w_size-MIN_LOOKAHEAD
	 ){
	// To simplify the code, we prevent matches with the string
	// of window index 0 (in particular we have to avoid a match
	// of the string with itself at the start of the input file).
	if(strategy != Z_HUFFMAN_ONLY){
	  match_length=longest_match (hash_head);
	}
	// longest_match() sets match_start
      }
      if(match_length>=MIN_MATCH){
	//        check_match(strstart, match_start, match_length);

	bflush=_tr_tally(strstart-match_start, match_length-MIN_MATCH);

	lookahead -= match_length;

	// Insert new strings in the hash table only if the match length
	// is not too large. This saves time but degrades compression.
	if(match_length <= max_lazy_match &&
	   lookahead >= MIN_MATCH) {
	  match_length--; // string at strstart already in hash table
	  do{
	    strstart++;

	    ins_h=((ins_h<<hash_shift)^(window[(strstart)+(MIN_MATCH-1)]&0xff))&hash_mask;
//	    prev[strstart&w_mask]=hash_head=head[ins_h];
	    hash_head=(head[ins_h]&0xffff);
	    prev[strstart&w_mask]=head[ins_h];
	    head[ins_h]=(short)strstart;

	    // strstart never exceeds WSIZE-MAX_MATCH, so there are
	    // always MIN_MATCH bytes ahead.
	  }
	  while (--match_length != 0);
	  strstart++; 
	}
	else{
	  strstart += match_length;
	  match_length = 0;
	  ins_h = window[strstart]&0xff;

	  ins_h=(((ins_h)<<hash_shift)^(window[strstart+1]&0xff))&hash_mask;
	  // If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	  // matter since it will be recomputed at next deflate call.
	}
      }
      else {
	// No match, output a literal byte

	bflush=_tr_tally(0, window[strstart]&0xff);
	lookahead--;
	strstart++; 
      }
      if (bflush){

	flush_block_only(false);
	if(strm.avail_out==0) return NeedMore;
      }
    }

    flush_block_only(flush == Z_FINISH);
    if(strm.avail_out==0){
      if(flush == Z_FINISH) return FinishStarted;
      else return NeedMore;
    }
    return flush==Z_FINISH ? FinishDone : BlockDone;
  }

  // Same as above, but achieves better compression. We use a lazy
  // evaluation for matches: a match is finally adopted only if there is
  // no better match at the next window position.
  int deflate_slow(int flush){
//    short hash_head = 0;    // head of hash chain
    int hash_head = 0;    // head of hash chain
    boolean bflush;         // set if current block must be flushed

    // Process the input block.
    while(true){
      // Make sure that we always have enough lookahead, except
      // at the end of the input file. We need MAX_MATCH bytes
      // for the next match, plus MIN_MATCH bytes to insert the
      // string following the next match.

      if (lookahead < MIN_LOOKAHEAD) {
	fill_window();
	if(lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	  return NeedMore;
	}
	if(lookahead == 0) break; // flush the current block
      }

      // Insert the string window[strstart .. strstart+2] in the
      // dictionary, and set hash_head to the head of the hash chain:

      if(lookahead >= MIN_MATCH) {
	ins_h=(((ins_h)<<hash_shift)^(window[(strstart)+(MIN_MATCH-1)]&0xff)) & hash_mask;
//	prev[strstart&w_mask]=hash_head=head[ins_h];
	hash_head=(head[ins_h]&0xffff);
	prev[strstart&w_mask]=head[ins_h];
	head[ins_h]=(short)strstart;
      }

      // Find the longest match, discarding those <= prev_length.
      prev_length = match_length; prev_match = match_start;
      match_length = MIN_MATCH-1;

      if (hash_head != 0 && prev_length < max_lazy_match &&
	  ((strstart-hash_head)&0xffff) <= w_size-MIN_LOOKAHEAD
	  ){
	// To simplify the code, we prevent matches with the string
	// of window index 0 (in particular we have to avoid a match
	// of the string with itself at the start of the input file).

	if(strategy != Z_HUFFMAN_ONLY) {
	  match_length = longest_match(hash_head);
	}
	// longest_match() sets match_start

	if (match_length <= 5 && (strategy == Z_FILTERED ||
				  (match_length == MIN_MATCH &&
				   strstart - match_start > 4096))) {

	  // If prev_match is also MIN_MATCH, match_start is garbage
	  // but we will ignore the current match anyway.
	  match_length = MIN_MATCH-1;
	}
      }

      // If there was a match at the previous step and the current
      // match is not better, output the previous match:
      if(prev_length >= MIN_MATCH && match_length <= prev_length) {
	int max_insert = strstart + lookahead - MIN_MATCH;
	// Do not insert strings in hash table beyond this.

	//          check_match(strstart-1, prev_match, prev_length);

	bflush=_tr_tally(strstart-1-prev_match, prev_length - MIN_MATCH);

	// Insert in hash table all strings up to the end of the match.
	// strstart-1 and strstart are already inserted. If there is not
	// enough lookahead, the last two strings are not inserted in
	// the hash table.
	lookahead -= prev_length-1;
	prev_length -= 2;
	do{
	  if(++strstart <= max_insert) {
	    ins_h=(((ins_h)<<hash_shift)^(window[(strstart)+(MIN_MATCH-1)]&0xff))&hash_mask;
	    //prev[strstart&w_mask]=hash_head=head[ins_h];
	    hash_head=(head[ins_h]&0xffff);
	    prev[strstart&w_mask]=head[ins_h];
	    head[ins_h]=(short)strstart;
	  }
	}
	while(--prev_length != 0);
	match_available = 0;
	match_length = MIN_MATCH-1;
	strstart++;

	if (bflush){
	  flush_block_only(false);
	  if(strm.avail_out==0) return NeedMore;
	}
      } else if (match_available!=0) {

	// If there was no match at the previous position, output a
	// single literal. If there was a match but the current match
	// is longer, truncate the previous match to a single literal.

	bflush=_tr_tally(0, window[strstart-1]&0xff);

	if (bflush) {
	  flush_block_only(false);
	}
	strstart++;
	lookahead--;
	if(strm.avail_out == 0) return NeedMore;
      } else {
	// There is no previous match to compare with, wait for
	// the next step to decide.

	match_available = 1;
	strstart++;
	lookahead--;
      }
    }

    if(match_available!=0) {
      bflush=_tr_tally(0, window[strstart-1]&0xff);
      match_available = 0;
    }
    flush_block_only(flush == Z_FINISH);

    if(strm.avail_out==0){
      if(flush == Z_FINISH) return FinishStarted;
      else return NeedMore;
    }

    return flush == Z_FINISH ? FinishDone : BlockDone;
  }

  int longest_match(int cur_match){
    int chain_length = max_chain_length; // max hash chain length
    int scan = strstart;                 // current string
    int match;                           // matched string
    int len;                             // length of current match
    int best_len = prev_length;          // best match length so far
    int limit = strstart>(w_size-MIN_LOOKAHEAD) ?
      strstart-(w_size-MIN_LOOKAHEAD) : 0;
    int nice_match=this.nice_match;

    // Stop when cur_match becomes <= limit. To simplify the code,
    // we prevent matches with the string of window index 0.

    int wmask = w_mask;

    int strend = strstart + MAX_MATCH;
    byte scan_end1 = window[scan+best_len-1];
    byte scan_end = window[scan+best_len];

    // The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
    // It is easy to get rid of this optimization if necessary.

    // Do not waste too much time if we already have a good match:
    if (prev_length >= good_match) {
      chain_length >>= 2;
    }

    // Do not look for matches beyond the end of the input. This is necessary
    // to make deflate deterministic.
    if (nice_match > lookahead) nice_match = lookahead;

    do {
      match = cur_match;

      // Skip to next match if the match length cannot increase
      // or if the match length is less than 2:
      if (window[match+best_len]   != scan_end  ||
	  window[match+best_len-1] != scan_end1 ||
	  window[match]       != window[scan]     ||
	  window[++match]     != window[scan+1])      continue;

      // The check at best_len-1 can be removed because it will be made
      // again later. (This heuristic is not always a win.)
      // It is not necessary to compare scan[2] and match[2] since they
      // are always equal when the other bytes match, given that
      // the hash keys are equal and that HASH_BITS >= 8.
      scan += 2; match++;

      // We check for insufficient lookahead only every 8th comparison;
      // the 256th check will be made at strstart+258.
      do {
      } while (window[++scan] == window[++match] &&
	       window[++scan] == window[++match] &&
	       window[++scan] == window[++match] &&
	       window[++scan] == window[++match] &&
	       window[++scan] == window[++match] &&
	       window[++scan] == window[++match] &&
	       window[++scan] == window[++match] &&
	       window[++scan] == window[++match] &&
	       scan < strend);

      len = MAX_MATCH - (int)(strend - scan);
      scan = strend - MAX_MATCH;

      if(len>best_len) {
	match_start = cur_match;
	best_len = len;
	if (len >= nice_match) break;
	scan_end1  = window[scan+best_len-1];
	scan_end   = window[scan+best_len];
      }

    } while ((cur_match = (prev[cur_match & wmask]&0xffff)) > limit
	     && --chain_length != 0);

    if (best_len <= lookahead) return best_len;
    return lookahead;
  }
    
  int deflateInit(ZStream strm, int level, int bits){
    return deflateInit2(strm, level, Z_DEFLATED, bits, DEF_MEM_LEVEL,
			Z_DEFAULT_STRATEGY);
  }
  int deflateInit(ZStream strm, int level){
    return deflateInit(strm, level, MAX_WBITS);
  }
  int deflateInit2(ZStream strm, int level, int method,  int windowBits,
		   int memLevel, int strategy){
    int noheader = 0;
    //    byte[] my_version=ZLIB_VERSION;

    //
    //  if (version == null || version[0] != my_version[0]
    //  || stream_size != sizeof(z_stream)) {
    //  return Z_VERSION_ERROR;
    //  }

    strm.msg = null;

    if (level == Z_DEFAULT_COMPRESSION) level = 6;

    if (windowBits < 0) { // undocumented feature: suppress zlib header
      noheader = 1;
      windowBits = -windowBits;
    }

    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || 
	method != Z_DEFLATED ||
	windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
      return Z_STREAM_ERROR;
    }

    strm.dstate = (Deflate)this;

    this.noheader = noheader;
    w_bits = windowBits;
    w_size = 1 << w_bits;
    w_mask = w_size - 1;

    hash_bits = memLevel + 7;
    hash_size = 1 << hash_bits;
    hash_mask = hash_size - 1;
    hash_shift = ((hash_bits+MIN_MATCH-1)/MIN_MATCH);

    window = new byte[w_size*2];
    prev = new short[w_size];
    head = new short[hash_size];

    lit_bufsize = 1 << (memLevel + 6); // 16K elements by default

    // We overlay pending_buf and d_buf+l_buf. This works since the average
    // output size for (length,distance) codes is <= 24 bits.
    pending_buf = new byte[lit_bufsize*4];
    pending_buf_size = lit_bufsize*4;

    d_buf = lit_bufsize/2;
    l_buf = (1+2)*lit_bufsize;

    this.level = level;

//System.out.println("level="+level);

    this.strategy = strategy;
    this.method = (byte)method;

    return deflateReset(strm);
  }

  int deflateReset(ZStream strm){
    strm.total_in = strm.total_out = 0;
    strm.msg = null; //
    strm.data_type = Z_UNKNOWN;

    pending = 0;
    pending_out = 0;

    if(noheader < 0) {
      noheader = 0; // was set to -1 by deflate(..., Z_FINISH);
    }
    status = (noheader!=0) ? BUSY_STATE : INIT_STATE;
    strm.adler=strm._adler.adler32(0, null, 0, 0);

    last_flush = Z_NO_FLUSH;

    tr_init();
    lm_init();
    return Z_OK;
  }

  int deflateEnd(){
    if(status!=INIT_STATE && status!=BUSY_STATE && status!=FINISH_STATE){
      return Z_STREAM_ERROR;
    }
    // Deallocate in reverse order of allocations:
    pending_buf=null;
    head=null;
    prev=null;
    window=null;
    // free
    // dstate=null;
    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
  }

  int deflateParams(ZStream strm, int _level, int _strategy){
    int err=Z_OK;

    if(_level == Z_DEFAULT_COMPRESSION){
      _level = 6;
    }
    if(_level < 0 || _level > 9 || 
       _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
      return Z_STREAM_ERROR;
    }

    if(config_table[level].func!=config_table[_level].func &&
       strm.total_in != 0) {
      // Flush the last buffer:
      err = strm.deflate(Z_PARTIAL_FLUSH);
    }

    if(level != _level) {
      level = _level;
      max_lazy_match   = config_table[level].max_lazy;
      good_match       = config_table[level].good_length;
      nice_match       = config_table[level].nice_length;
      max_chain_length = config_table[level].max_chain;
    }
    strategy = _strategy;
    return err;
  }

  int deflateSetDictionary (ZStream strm, byte[] dictionary, int dictLength){
    int length = dictLength;
    int index=0;

    if(dictionary == null || status != INIT_STATE)
      return Z_STREAM_ERROR;

    strm.adler=strm._adler.adler32(strm.adler, dictionary, 0, dictLength);

    if(length < MIN_MATCH) return Z_OK;
    if(length > w_size-MIN_LOOKAHEAD){
      length = w_size-MIN_LOOKAHEAD;
      index=dictLength-length; // use the tail of the dictionary
    }
    System.arraycopy(dictionary, index, window, 0, length);
    strstart = length;
    block_start = length;

    // Insert all strings in the hash table (except for the last two bytes).
    // s->lookahead stays null, so s->ins_h will be recomputed at the next
    // call of fill_window.

    ins_h = window[0]&0xff;
    ins_h=(((ins_h)<<hash_shift)^(window[1]&0xff))&hash_mask;

    for(int n=0; n<=length-MIN_MATCH; n++){
      ins_h=(((ins_h)<<hash_shift)^(window[(n)+(MIN_MATCH-1)]&0xff))&hash_mask;
      prev[n&w_mask]=head[ins_h];
      head[ins_h]=(short)n;
    }
    return Z_OK;
  }

  int deflate(ZStream strm, int flush){
    int old_flush;

    if(flush>Z_FINISH || flush<0){
      return Z_STREAM_ERROR;
    }

    if(strm.next_out == null ||
       (strm.next_in == null && strm.avail_in != 0) ||
       (status == FINISH_STATE && flush != Z_FINISH)) {
      strm.msg=z_errmsg[Z_NEED_DICT-(Z_STREAM_ERROR)];
      return Z_STREAM_ERROR;
    }
    if(strm.avail_out == 0){
      strm.msg=z_errmsg[Z_NEED_DICT-(Z_BUF_ERROR)];
      return Z_BUF_ERROR;
    }

    this.strm = strm; // just in case
    old_flush = last_flush;
    last_flush = flush;

    // Write the zlib header
    if(status == INIT_STATE) {
      int header = (Z_DEFLATED+((w_bits-8)<<4))<<8;
      int level_flags=((level-1)&0xff)>>1;

      if(level_flags>3) level_flags=3;
      header |= (level_flags<<6);
      if(strstart!=0) header |= PRESET_DICT;
      header+=31-(header % 31);

      status=BUSY_STATE;
      putShortMSB(header);


      // Save the adler32 of the preset dictionary:
      if(strstart!=0){
        putShortMSB((int)(strm.adler>>>16));
        putShortMSB((int)(strm.adler&0xffff));
      }
      strm.adler=strm._adler.adler32(0, null, 0, 0);
    }

    // Flush as much pending output as possible
    if(pending != 0) {
      strm.flush_pending();
      if(strm.avail_out == 0) {
	//System.out.println("  avail_out==0");
	// Since avail_out is 0, deflate will be called again with
	// more output space, but possibly with both pending and
	// avail_in equal to zero. There won't be anything to do,
	// but this is not an error situation so make sure we
	// return OK instead of BUF_ERROR at next call of deflate:
	last_flush = -1;
	return Z_OK;
      }

      // Make sure there is something to do and avoid duplicate consecutive
      // flushes. For repeated and useless calls with Z_FINISH, we keep
      // returning Z_STREAM_END instead of Z_BUFF_ERROR.
    }
    else if(strm.avail_in==0 && flush <= old_flush &&
	    flush != Z_FINISH) {
      strm.msg=z_errmsg[Z_NEED_DICT-(Z_BUF_ERROR)];
      return Z_BUF_ERROR;
    }

    // User must not provide more input after the first FINISH:
    if(status == FINISH_STATE && strm.avail_in != 0) {
      strm.msg=z_errmsg[Z_NEED_DICT-(Z_BUF_ERROR)];
      return Z_BUF_ERROR;
    }

    // Start a new block or continue the current one.
    if(strm.avail_in!=0 || lookahead!=0 ||
       (flush != Z_NO_FLUSH && status != FINISH_STATE)) {
      int bstate=-1;
      switch(config_table[level].func){
      case STORED: 
	bstate = deflate_stored(flush);
	break;
      case FAST: 
	bstate = deflate_fast(flush);
	break;
      case SLOW: 
	bstate = deflate_slow(flush);
	break;
      default:
      }

      if (bstate==FinishStarted || bstate==FinishDone) {
	status = FINISH_STATE;
      }
      if (bstate==NeedMore || bstate==FinishStarted) {
	if(strm.avail_out == 0) {
	  last_flush = -1; // avoid BUF_ERROR next call, see above
	}
	return Z_OK;
	// If flush != Z_NO_FLUSH && avail_out == 0, the next call
	// of deflate should use the same flush parameter to make sure
	// that the flush is complete. So we don't have to output an
	// empty block here, this will be done at next call. This also
	// ensures that for a very small output buffer, we emit at most
	// one empty block.
      }

      if (bstate==BlockDone) {
	if(flush == Z_PARTIAL_FLUSH) {
	  _tr_align();
	} 
	else { // FULL_FLUSH or SYNC_FLUSH
	  _tr_stored_block(0, 0, false);
	  // For a full flush, this empty block will be recognized
	  // as a special marker by inflate_sync().
	  if(flush == Z_FULL_FLUSH) {
	    //state.head[s.hash_size-1]=0;
	    for(int i=0; i<hash_size/*-1*/; i++)  // forget history
	      head[i]=0;
	  }
	}
	strm.flush_pending();
	if(strm.avail_out == 0) {
	  last_flush = -1; // avoid BUF_ERROR at next call, see above
	  return Z_OK;
	}
      }
    }

    if(flush!=Z_FINISH) return Z_OK;
    if(noheader!=0) return Z_STREAM_END;

    // Write the zlib trailer (adler32)
    putShortMSB((int)(strm.adler>>>16));
    putShortMSB((int)(strm.adler&0xffff));
    strm.flush_pending();

    // If avail_out is zero, the application will call deflate again
    // to flush the rest.
    noheader = -1; // write the trailer only once!
    return pending != 0 ? Z_OK : Z_STREAM_END;
  }
}
/*
 * FilterInputStream.java
 *
 * Created on 30 Июль 2006 г., 20:31
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package com.jcraft.jzlib;

import java.io.IOException;
import java.io.InputStream;

/**
 *
 * @author evgs
 */
public class FilterInputStream extends InputStream{

    protected InputStream in;
    
    /** Creates a new instance of FilterInputStream */
    protected FilterInputStream(InputStream in) { this.in=in; }
    
    public int available() throws IOException {  return in.available(); }
    
    public void close() throws IOException { in.close(); }
    
    public void mark(int readlimit) { in.mark(readlimit); }
    
    public boolean markSupported() { return in.markSupported(); }
    
    public int read() throws IOException { return in.read(); }
    
    public int read(byte[] b) throws IOException { return in.read(b); }
    
    public int read(byte[] b, int off, int len) throws IOException { return in.read(b, off, len); }

    public void reset() throws IOException { in.reset(); }
    
    public long skip(long n) throws IOException { return in.skip(n); }

}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

final class InfBlocks{
  static final private int MANY=1440;

  // And'ing with mask[n] masks the lower n bits
  static final private int[] inflate_mask = {
    0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f,
    0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff,
    0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff,
    0x00007fff, 0x0000ffff
  };

  // Table for deflate from PKZIP's appnote.txt.
  static final int[] border = { // Order of the bit length code lengths
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
  };

  static final private int Z_OK=0;
  static final private int Z_STREAM_END=1;
  static final private int Z_NEED_DICT=2;
  static final private int Z_ERRNO=-1;
  static final private int Z_STREAM_ERROR=-2;
  static final private int Z_DATA_ERROR=-3;
  static final private int Z_MEM_ERROR=-4;
  static final private int Z_BUF_ERROR=-5;
  static final private int Z_VERSION_ERROR=-6;

  static final private int TYPE=0;  // get type bits (3, including end bit)
  static final private int LENS=1;  // get lengths for stored
  static final private int STORED=2;// processing stored block
  static final private int TABLE=3; // get table lengths
  static final private int BTREE=4; // get bit lengths tree for a dynamic block
  static final private int DTREE=5; // get length, distance trees for a dynamic block
  static final private int CODES=6; // processing fixed or dynamic block
  static final private int DRY=7;   // output remaining window bytes
  static final private int DONE=8;  // finished last block, done
  static final private int BAD=9;   // ot a data error--stuck here

  int mode;            // current inflate_block mode 

  int left;            // if STORED, bytes left to copy 

  int table;           // table lengths (14 bits) 
  int index;           // index into blens (or border) 
  int[] blens;         // bit lengths of codes 
  int[] bb=new int[1]; // bit length tree depth 
  int[] tb=new int[1]; // bit length decoding tree 

  InfCodes codes=new InfCodes();      // if CODES, current state 

  int last;            // true if this block is the last block 

  // mode independent information 
  int bitk;            // bits in bit buffer 
  int bitb;            // bit buffer 
  int[] hufts;         // single malloc for tree space 
  byte[] window;       // sliding window 
  int end;             // one byte after sliding window 
  int read;            // window read pointer 
  int write;           // window write pointer 
  Object checkfn;      // check function 
  long check;          // check on output 

  InfTree inftree=new InfTree();

  InfBlocks(ZStream z, Object checkfn, int w){
    hufts=new int[MANY*3];
    window=new byte[w];
    end=w;
    this.checkfn = checkfn;
    mode = TYPE;
    reset(z, null);
  }

  void reset(ZStream z, long[] c){
    if(c!=null) c[0]=check;
    if(mode==BTREE || mode==DTREE){
    }
    if(mode==CODES){
      codes.free(z);
    }
    mode=TYPE;
    bitk=0;
    bitb=0;
    read=write=0;

    if(checkfn != null)
      z.adler=check=z._adler.adler32(0L, null, 0, 0);
  }

  int proc(ZStream z, int r){
    int t;              // temporary storage
    int b;              // bit buffer
    int k;              // bits in bit buffer
    int p;              // input data pointer
    int n;              // bytes available there
    int q;              // output window write pointer
    int m;              // bytes to end of window or read pointer

    // copy input/output information to locals (UPDATE macro restores)
    {p=z.next_in_index;n=z.avail_in;b=bitb;k=bitk;}
    {q=write;m=(int)(q<read?read-q-1:end-q);}

    // process input based on current state
    while(true){
      switch (mode){
      case TYPE:

	while(k<(3)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    bitb=b; bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    write=q;
	    return inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}
	t = (int)(b & 7);
	last = t & 1;

	switch (t >>> 1){
        case 0:                         // stored 
          {b>>>=(3);k-=(3);}
          t = k & 7;                    // go to byte boundary

          {b>>>=(t);k-=(t);}
          mode = LENS;                  // get length of stored block
          break;
        case 1:                         // fixed
          {
            int[] bl=new int[1];
	    int[] bd=new int[1];
            int[][] tl=new int[1][];
	    int[][] td=new int[1][];

	    InfTree.inflate_trees_fixed(bl, bd, tl, td, z);
            codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);
          }

          {b>>>=(3);k-=(3);}

          mode = CODES;
          break;
        case 2:                         // dynamic

          {b>>>=(3);k-=(3);}

          mode = TABLE;
          break;
        case 3:                         // illegal

          {b>>>=(3);k-=(3);}
          mode = BAD;
          z.msg = "invalid block type";
          r = Z_DATA_ERROR;

	  bitb=b; bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return inflate_flush(z,r);
	}
	break;
      case LENS:

	while(k<(32)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    bitb=b; bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    write=q;
	    return inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){
	  mode = BAD;
	  z.msg = "invalid stored block lengths";
	  r = Z_DATA_ERROR;

	  bitb=b; bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return inflate_flush(z,r);
	}
	left = (b & 0xffff);
	b = k = 0;                       // dump bits
	mode = left!=0 ? STORED : (last!=0 ? DRY : TYPE);
	break;
      case STORED:
	if (n == 0){
	  bitb=b; bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return inflate_flush(z,r);
	}

	if(m==0){
	  if(q==end&&read!=0){
	    q=0; m=(int)(q<read?read-q-1:end-q);
	  }
	  if(m==0){
	    write=q; 
	    r=inflate_flush(z,r);
	    q=write;m=(int)(q<read?read-q-1:end-q);
	    if(q==end&&read!=0){
	      q=0; m=(int)(q<read?read-q-1:end-q);
	    }
	    if(m==0){
	      bitb=b; bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      write=q;
	      return inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	t = left;
	if(t>n) t = n;
	if(t>m) t = m;
	System.arraycopy(z.next_in, p, window, q, t);
	p += t;  n -= t;
	q += t;  m -= t;
	if ((left -= t) != 0)
	  break;
	mode = last!=0 ? DRY : TYPE;
	break;
      case TABLE:

	while(k<(14)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    bitb=b; bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    write=q;
	    return inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	table = t = (b & 0x3fff);
	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
	  {
	    mode = BAD;
	    z.msg = "too many length or distance symbols";
	    r = Z_DATA_ERROR;

	    bitb=b; bitk=k; 
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    write=q;
	    return inflate_flush(z,r);
	  }
	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
	if(blens==null || blens.length<t){
	  blens=new int[t];
	}
	else{
	  for(int i=0; i<t; i++){blens[i]=0;}
	}

	{b>>>=(14);k-=(14);}

	index = 0;
	mode = BTREE;
      case BTREE:
	while (index < 4 + (table >>> 10)){
	  while(k<(3)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      bitb=b; bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      write=q;
	      return inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

	  blens[border[index++]] = b&7;

	  {b>>>=(3);k-=(3);}
	}

	while(index < 19){
	  blens[border[index++]] = 0;
	}

	bb[0] = 7;
	t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
	if (t != Z_OK){
	  r = t;
	  if (r == Z_DATA_ERROR){
	    blens=null;
	    mode = BAD;
	  }

	  bitb=b; bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return inflate_flush(z,r);
	}

	index = 0;
	mode = DTREE;
      case DTREE:
	while (true){
	  t = table;
	  if(!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){
	    break;
	  }

	  int[] h;
	  int i, j, c;

	  t = bb[0];

	  while(k<(t)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      bitb=b; bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      write=q;
	      return inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

	  if(tb[0]==-1){
            //System.err.println("null...");
	  }

	  t=hufts[(tb[0]+(b&inflate_mask[t]))*3+1];
	  c=hufts[(tb[0]+(b&inflate_mask[t]))*3+2];

	  if (c < 16){
	    b>>>=(t);k-=(t);
	    blens[index++] = c;
	  }
	  else { // c == 16..18
	    i = c == 18 ? 7 : c - 14;
	    j = c == 18 ? 11 : 3;

	    while(k<(t+i)){
	      if(n!=0){
		r=Z_OK;
	      }
	      else{
		bitb=b; bitk=k; 
		z.avail_in=n;
		z.total_in+=p-z.next_in_index;z.next_in_index=p;
		write=q;
		return inflate_flush(z,r);
	      };
	      n--;
	      b|=(z.next_in[p++]&0xff)<<k;
	      k+=8;
	    }

	    b>>>=(t);k-=(t);

	    j += (b & inflate_mask[i]);

	    b>>>=(i);k-=(i);

	    i = index;
	    t = table;
	    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
		(c == 16 && i < 1)){
	      blens=null;
	      mode = BAD;
	      z.msg = "invalid bit length repeat";
	      r = Z_DATA_ERROR;

	      bitb=b; bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      write=q;
	      return inflate_flush(z,r);
	    }

	    c = c == 16 ? blens[i-1] : 0;
	    do{
	      blens[i++] = c;
	    }
	    while (--j!=0);
	    index = i;
	  }
	}

	tb[0]=-1;
	{
	  int[] bl=new int[1];
	  int[] bd=new int[1];
	  int[] tl=new int[1];
	  int[] td=new int[1];
	  bl[0] = 9;         // must be <= 9 for lookahead assumptions
	  bd[0] = 6;         // must be <= 9 for lookahead assumptions

	  t = table;
	  t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 
					    1 + ((t >> 5) & 0x1f),
					    blens, bl, bd, tl, td, hufts, z);

	  if (t != Z_OK){
	    if (t == Z_DATA_ERROR){
	      blens=null;
	      mode = BAD;
	    }
	    r = t;

	    bitb=b; bitk=k; 
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    write=q;
	    return inflate_flush(z,r);
	  }
	  codes.init(bl[0], bd[0], hufts, tl[0], hufts, td[0], z);
	}
	mode = CODES;
      case CODES:
	bitb=b; bitk=k;
	z.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;
	write=q;

	if ((r = codes.proc(this, z, r)) != Z_STREAM_END){
	  return inflate_flush(z, r);
	}
	r = Z_OK;
	codes.free(z);

	p=z.next_in_index; n=z.avail_in;b=bitb;k=bitk;
	q=write;m=(int)(q<read?read-q-1:end-q);

	if (last==0){
	  mode = TYPE;
	  break;
	}
	mode = DRY;
      case DRY:
	write=q; 
	r=inflate_flush(z, r); 
	q=write; m=(int)(q<read?read-q-1:end-q);
	if (read != write){
	  bitb=b; bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return inflate_flush(z, r);
	}
	mode = DONE;
      case DONE:
	r = Z_STREAM_END;

	bitb=b; bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	write=q;
	return inflate_flush(z, r);
      case BAD:
	r = Z_DATA_ERROR;

	bitb=b; bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	write=q;
	return inflate_flush(z, r);

      default:
	r = Z_STREAM_ERROR;

	bitb=b; bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	write=q;
	return inflate_flush(z, r);
      }
    }
  }

  void free(ZStream z){
    reset(z, null);
    window=null;
    hufts=null;
    //ZFREE(z, s);
  }

  void set_dictionary(byte[] d, int start, int n){
    System.arraycopy(d, start, window, 0, n);
    read = write = n;
  }

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
  int sync_point(){
    return mode == LENS ? 1 : 0;
  }

  // copy as much as possible from the sliding window to the output area
  int inflate_flush(ZStream z, int r){
    int n;
    int p;
    int q;

    // local copies of source and destination pointers
    p = z.next_out_index;
    q = read;

    // compute number of bytes to copy as far as end of window
    n = (int)((q <= write ? write : end) - q);
    if (n > z.avail_out) n = z.avail_out;
    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

    // update counters
    z.avail_out -= n;
    z.total_out += n;

    // update check information
    if(checkfn != null)
      z.adler=check=z._adler.adler32(check, window, q, n);

    // copy as far as end of window
    System.arraycopy(window, q, z.next_out, p, n);
    p += n;
    q += n;

    // see if more to copy at beginning of window
    if (q == end){
      // wrap pointers
      q = 0;
      if (write == end)
        write = 0;

      // compute bytes to copy
      n = write - q;
      if (n > z.avail_out) n = z.avail_out;
      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

      // update counters
      z.avail_out -= n;
      z.total_out += n;

      // update check information
      if(checkfn != null)
	z.adler=check=z._adler.adler32(check, window, q, n);

      // copy
      System.arraycopy(window, q, z.next_out, p, n);
      p += n;
      q += n;
    }

    // update pointers
    z.next_out_index = p;
    read = q;

    // done
    return r;
  }
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

final class InfCodes{

  static final private int[] inflate_mask = {
    0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f,
    0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff,
    0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff,
    0x00007fff, 0x0000ffff
  };

  static final private int Z_OK=0;
  static final private int Z_STREAM_END=1;
  static final private int Z_NEED_DICT=2;
  static final private int Z_ERRNO=-1;
  static final private int Z_STREAM_ERROR=-2;
  static final private int Z_DATA_ERROR=-3;
  static final private int Z_MEM_ERROR=-4;
  static final private int Z_BUF_ERROR=-5;
  static final private int Z_VERSION_ERROR=-6;

  // waiting for "i:"=input,
  //             "o:"=output,
  //             "x:"=nothing
  static final private int START=0;  // x: set up for LEN
  static final private int LEN=1;    // i: get length/literal/eob next
  static final private int LENEXT=2; // i: getting length extra (have base)
  static final private int DIST=3;   // i: get distance next
  static final private int DISTEXT=4;// i: getting distance extra
  static final private int COPY=5;   // o: copying bytes in window, waiting for space
  static final private int LIT=6;    // o: got literal, waiting for output space
  static final private int WASH=7;   // o: got eob, possibly still output waiting
  static final private int END=8;    // x: got eob and all data flushed
  static final private int BADCODE=9;// x: got error

  int mode;      // current inflate_codes mode

  // mode dependent information
  int len;

  int[] tree; // pointer into tree
  int tree_index=0;
  int need;   // bits needed

  int lit;

  // if EXT or COPY, where and how much
  int get;              // bits to get for extra
  int dist;             // distance back to copy from

  byte lbits;           // ltree bits decoded per branch
  byte dbits;           // dtree bits decoder per branch
  int[] ltree;          // literal/length/eob tree
  int ltree_index;      // literal/length/eob tree
  int[] dtree;          // distance tree
  int dtree_index;      // distance tree

  InfCodes(){
  }
  void init(int bl, int bd,
	   int[] tl, int tl_index,
	   int[] td, int td_index, ZStream z){
    mode=START;
    lbits=(byte)bl;
    dbits=(byte)bd;
    ltree=tl;
    ltree_index=tl_index;
    dtree = td;
    dtree_index=td_index;
    tree=null;
  }

  int proc(InfBlocks s, ZStream z, int r){ 
    int j;              // temporary storage
    int[] t;            // temporary pointer
    int tindex;         // temporary pointer
    int e;              // extra bits or operation
    int b=0;            // bit buffer
    int k=0;            // bits in bit buffer
    int p=0;            // input data pointer
    int n;              // bytes available there
    int q;              // output window write pointer
    int m;              // bytes to end of window or read pointer
    int f;              // pointer to copy strings from

    // copy input/output information to locals (UPDATE macro restores)
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // process input and output based on current state
    while (true){
      switch (mode){
	// waiting for "i:"=input, "o:"=output, "x:"=nothing
      case START:         // x: set up for LEN
	if (m >= 258 && n >= 10){

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  r = inflate_fast(lbits, dbits, 
			   ltree, ltree_index, 
			   dtree, dtree_index,
			   s, z);

	  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
	  q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	  if (r != Z_OK){
	    mode = r == Z_STREAM_END ? WASH : BADCODE;
	    break;
	  }
	}
	need = lbits;
	tree = ltree;
	tree_index=ltree_index;

	mode = LEN;
      case LEN:           // i: get length/literal/eob next
	j = need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(tree_index+(b&inflate_mask[j]))*3;

	b>>>=(tree[tindex+1]);
	k-=(tree[tindex+1]);

	e=tree[tindex];

	if(e == 0){               // literal
	  lit = tree[tindex+2];
	  mode = LIT;
	  break;
	}
	if((e & 16)!=0 ){          // length
	  get = e & 15;
	  len = tree[tindex+2];
	  mode = LENEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  need = e;
	  tree_index = tindex/3+tree[tindex+2];
	  break;
	}
	if ((e & 32)!=0){               // end of block
	  mode = WASH;
	  break;
	}
	mode = BADCODE;        // invalid code
	z.msg = "invalid literal/length code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case LENEXT:        // i: getting length extra (have base)
	j = get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	len += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	need = dbits;
	tree = dtree;
	tree_index=dtree_index;
	mode = DIST;
      case DIST:          // i: get distance next
	j = need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(tree_index+(b & inflate_mask[j]))*3;

	b>>=tree[tindex+1];
	k-=tree[tindex+1];

	e = (tree[tindex]);
	if((e & 16)!=0){               // distance
	  get = e & 15;
	  dist = tree[tindex+2];
	  mode = DISTEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  need = e;
	  tree_index = tindex/3 + tree[tindex+2];
	  break;
	}
	mode = BADCODE;        // invalid code
	z.msg = "invalid distance code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case DISTEXT:       // i: getting distance extra
	j = get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	dist += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	mode = COPY;
      case COPY:          // o: copying bytes in window, waiting for space
        f = q - dist;
        while(f < 0){     // modulo window size-"while" instead
          f += s.end;     // of "if" handles invalid distances
	}
	while (len!=0){

	  if(m==0){
	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.write=q; r=s.inflate_flush(z,r);
	      q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}

	      if(m==0){
		s.bitb=b;s.bitk=k;
		z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
		s.write=q;
		return s.inflate_flush(z,r);
	      }  
	    }
	  }

	  s.window[q++]=s.window[f++]; m--;

	  if (f == s.end)
            f = 0;
	  len--;
	}
	mode = START;
	break;
      case LIT:           // o: got literal, waiting for output space
	if(m==0){
	  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	  if(m==0){
	    s.write=q; r=s.inflate_flush(z,r);
	    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;
	      return s.inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	s.window[q++]=(byte)lit; m--;

	mode = START;
	break;
      case WASH:           // o: got eob, possibly more output
	if (k > 7){        // return unused byte, if any
	  k -= 8;
	  n++;
	  p--;             // can always return one
	}

	s.write=q; r=s.inflate_flush(z,r);
	q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	if (s.read != s.write){
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  return s.inflate_flush(z,r);
	}
	mode = END;
      case END:
	r = Z_STREAM_END;
	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case BADCODE:       // x: got error

	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      default:
	r = Z_STREAM_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);
      }
    }
  }

  void free(ZStream z){
    //  ZFREE(z, c);
  }

  // Called with number of bytes left to write in window at least 258
  // (the maximum string length) and number of input bytes available
  // at least ten.  The ten bytes are six bytes for the longest length/
  // distance pair plus four bytes for overloading the bit buffer.

  int inflate_fast(int bl, int bd, 
		   int[] tl, int tl_index,
		   int[] td, int td_index,
		   InfBlocks s, ZStream z){
    int t;                // temporary pointer
    int[] tp;             // temporary pointer
    int tp_index;         // temporary pointer
    int e;                // extra bits or operation
    int b;                // bit buffer
    int k;                // bits in bit buffer
    int p;                // input data pointer
    int n;                // bytes available there
    int q;                // output window write pointer
    int m;                // bytes to end of window or read pointer
    int ml;               // mask for literal/length tree
    int md;               // mask for distance tree
    int c;                // bytes to copy
    int d;                // distance back to copy from
    int r;                // copy source pointer

    int tp_index_t_3;     // (tp_index+t)*3

    // load input, output, bit values
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // initialize masks
    ml = inflate_mask[bl];
    md = inflate_mask[bd];

    // do until not enough input or output space for fast loop
    do {                          // assume called with m >= 258 && n >= 10
      // get literal/length code
      while(k<(20)){              // max bits for literal/length code
	n--;
	b|=(z.next_in[p++]&0xff)<<k;k+=8;
      }

      t= b&ml;
      tp=tl; 
      tp_index=tl_index;
      tp_index_t_3=(tp_index+t)*3;
      if ((e = tp[tp_index_t_3]) == 0){
	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	s.window[q++] = (byte)tp[tp_index_t_3+2];
	m--;
	continue;
      }
      do {

	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	if((e&16)!=0){
	  e &= 15;
	  c = tp[tp_index_t_3+2] + ((int)b & inflate_mask[e]);

	  b>>=e; k-=e;

	  // decode distance base of block to copy
	  while(k<(15)){           // max bits for distance code
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;k+=8;
	  }

	  t= b&md;
	  tp=td;
	  tp_index=td_index;
          tp_index_t_3=(tp_index+t)*3;
	  e = tp[tp_index_t_3];

	  do {

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    if((e&16)!=0){
	      // get extra bits to add to distance base
	      e &= 15;
	      while(k<(e)){         // get extra bits (up to 13)
		n--;
		b|=(z.next_in[p++]&0xff)<<k;k+=8;
	      }

	      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);

	      b>>=(e); k-=(e);

	      // do the copy
	      m -= c;
	      if (q >= d){                // offset before dest
		//  just copy
		r=q-d;
		if(q-r>0 && 2>(q-r)){           
		  s.window[q++]=s.window[r++]; // minimum count is three,
		  s.window[q++]=s.window[r++]; // so unroll loop a little
		  c-=2;
		}
		else{
		  System.arraycopy(s.window, r, s.window, q, 2);
		  q+=2; r+=2; c-=2;
		}
	      }
	      else{                  // else offset after destination
                r=q-d;
                do{
                  r+=s.end;          // force pointer in window
                }while(r<0);         // covers invalid distances
		e=s.end-r;
		if(c>e){             // if source crosses,
		  c-=e;              // wrapped copy
		  if(q-r>0 && e>(q-r)){           
		    do{s.window[q++] = s.window[r++];}
		    while(--e!=0);
		  }
		  else{
		    System.arraycopy(s.window, r, s.window, q, e);
		    q+=e; r+=e; e=0;
		  }
		  r = 0;                  // copy rest from start of window
		}

	      }

	      // copy all or what's left
	      if(q-r>0 && c>(q-r)){           
		do{s.window[q++] = s.window[r++];}
		while(--c!=0);
	      }
	      else{
		System.arraycopy(s.window, r, s.window, q, c);
		q+=c; r+=c; c=0;
	      }
	      break;
	    }
	    else if((e&64)==0){
	      t+=tp[tp_index_t_3+2];
	      t+=(b&inflate_mask[e]);
	      tp_index_t_3=(tp_index+t)*3;
	      e=tp[tp_index_t_3];
	    }
	    else{
	      z.msg = "invalid distance code";

	      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;

	      return Z_DATA_ERROR;
	    }
	  }
	  while(true);
	  break;
	}

	if((e&64)==0){
	  t+=tp[tp_index_t_3+2];
	  t+=(b&inflate_mask[e]);
	  tp_index_t_3=(tp_index+t)*3;
	  if((e=tp[tp_index_t_3])==0){

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    s.window[q++]=(byte)tp[tp_index_t_3+2];
	    m--;
	    break;
	  }
	}
	else if((e&32)!=0){

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;
 
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_STREAM_END;
	}
	else{
	  z.msg="invalid literal/length code";

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_DATA_ERROR;
	}
      } 
      while(true);
    } 
    while(m>=258 && n>= 10);

    // not enough input or output--restore pointers and return
    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

    s.bitb=b;s.bitk=k;
    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
    s.write=q;

    return Z_OK;
  }
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

final class Inflate{
  
  static final private int MAX_WBITS=15; // 32K LZ77 window

  // preset dictionary flag in zlib header
  static final private int PRESET_DICT=0x20;

  static final int Z_NO_FLUSH=0;
  static final int Z_PARTIAL_FLUSH=1;
  static final int Z_SYNC_FLUSH=2;
  static final int Z_FULL_FLUSH=3;
  static final int Z_FINISH=4;

  static final private int Z_DEFLATED=8;

  static final private int Z_OK=0;
  static final private int Z_STREAM_END=1;
  static final private int Z_NEED_DICT=2;
  static final private int Z_ERRNO=-1;
  static final private int Z_STREAM_ERROR=-2;
  static final private int Z_DATA_ERROR=-3;
  static final private int Z_MEM_ERROR=-4;
  static final private int Z_BUF_ERROR=-5;
  static final private int Z_VERSION_ERROR=-6;

  static final private int METHOD=0;   // waiting for method byte
  static final private int FLAG=1;     // waiting for flag byte
  static final private int DICT4=2;    // four dictionary check bytes to go
  static final private int DICT3=3;    // three dictionary check bytes to go
  static final private int DICT2=4;    // two dictionary check bytes to go
  static final private int DICT1=5;    // one dictionary check byte to go
  static final private int DICT0=6;    // waiting for inflateSetDictionary
  static final private int BLOCKS=7;   // decompressing blocks
  static final private int CHECK4=8;   // four check bytes to go
  static final private int CHECK3=9;   // three check bytes to go
  static final private int CHECK2=10;  // two check bytes to go
  static final private int CHECK1=11;  // one check byte to go
  static final private int DONE=12;    // finished check, done
  static final private int BAD=13;     // got an error--stay here

  int mode;                            // current inflate mode

  // mode dependent information
  int method;        // if FLAGS, method byte

  // if CHECK, check values to compare
  long[] was=new long[1] ; // computed check value
  long need;               // stream check value

  // if BAD, inflateSync's marker bytes count
  int marker;

  // mode independent information
  int  nowrap;          // flag for no wrapper
  int wbits;            // log2(window size)  (8..15, defaults to 15)

  InfBlocks blocks;     // current inflate_blocks state

  int inflateReset(ZStream z){
    if(z == null || z.istate == null) return Z_STREAM_ERROR;
    
    z.total_in = z.total_out = 0;
    z.msg = null;
    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;
    z.istate.blocks.reset(z, null);
    return Z_OK;
  }

  int inflateEnd(ZStream z){
    if(blocks != null)
      blocks.free(z);
    blocks=null;
    //    ZFREE(z, z->state);
    return Z_OK;
  }

  int inflateInit(ZStream z, int w){
    z.msg = null;
    blocks = null;

    // handle undocumented nowrap option (no zlib header or check)
    nowrap = 0;
    if(w < 0){
      w = - w;
      nowrap = 1;
    }

    // set window size
    if(w<8 ||w>15){
      inflateEnd(z);
      return Z_STREAM_ERROR;
    }
    wbits=w;

    z.istate.blocks=new InfBlocks(z, 
				  z.istate.nowrap!=0 ? null : this,
				  1<<w);

    // reset state
    inflateReset(z);
    return Z_OK;
  }

  int inflate(ZStream z, int f){
    int r;
    int b;

    if(z == null || z.istate == null || z.next_in == null)
      return Z_STREAM_ERROR;
    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
    r = Z_BUF_ERROR;
    while (true){
//System.out.println("mode: "+z.istate.mode);
      switch (z.istate.mode){
      case METHOD:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){
          z.istate.mode = BAD;
          z.msg="unknown compression method";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        if((z.istate.method>>4)+8>z.istate.wbits){
          z.istate.mode = BAD;
          z.msg="invalid window size";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        z.istate.mode=FLAG;
      case FLAG:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        b = (z.next_in[z.next_in_index++])&0xff;

        if((((z.istate.method << 8)+b) % 31)!=0){
          z.istate.mode = BAD;
          z.msg = "incorrect header check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        if((b&PRESET_DICT)==0){
          z.istate.mode = BLOCKS;
          break;
        }
        z.istate.mode = DICT4;
      case DICT4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000L;
        z.istate.mode=DICT3;
      case DICT3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000L;
        z.istate.mode=DICT2;
      case DICT2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00L;
        z.istate.mode=DICT1;
      case DICT1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need += (z.next_in[z.next_in_index++]&0xffL);
        z.adler = z.istate.need;
        z.istate.mode = DICT0;
        return Z_NEED_DICT;
      case DICT0:
        z.istate.mode = BAD;
        z.msg = "need dictionary";
        z.istate.marker = 0;       // can try inflateSync
        return Z_STREAM_ERROR;
      case BLOCKS:

        r = z.istate.blocks.proc(z, r);
        if(r == Z_DATA_ERROR){
          z.istate.mode = BAD;
          z.istate.marker = 0;     // can try inflateSync
          break;
        }
        if(r == Z_OK){
          r = f;
        }
        if(r != Z_STREAM_END){
          return r;
        }
        r = f;
        z.istate.blocks.reset(z, z.istate.was);
        if(z.istate.nowrap!=0){
          z.istate.mode=DONE;
          break;
        }
        z.istate.mode=CHECK4;
      case CHECK4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000L;
        z.istate.mode=CHECK3;
      case CHECK3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000L;
        z.istate.mode = CHECK2;
      case CHECK2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00L;
        z.istate.mode = CHECK1;
      case CHECK1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=(z.next_in[z.next_in_index++]&0xffL);

        if(((int)(z.istate.was[0])) != ((int)(z.istate.need))){
          z.istate.mode = BAD;
          z.msg = "incorrect data check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        z.istate.mode = DONE;
      case DONE:
        return Z_STREAM_END;
      case BAD:
        return Z_DATA_ERROR;
      default:
        return Z_STREAM_ERROR;
      }
    }
  }


  int inflateSetDictionary(ZStream z, byte[] dictionary, int dictLength){
    int index=0;
    int length = dictLength;
    if(z==null || z.istate == null|| z.istate.mode != DICT0)
      return Z_STREAM_ERROR;

    if(z._adler.adler32(1L, dictionary, 0, dictLength)!=z.adler){
      return Z_DATA_ERROR;
    }

    z.adler = z._adler.adler32(0, null, 0, 0);

    if(length >= (1<<z.istate.wbits)){
      length = (1<<z.istate.wbits)-1;
      index=dictLength - length;
    }
    z.istate.blocks.set_dictionary(dictionary, index, length);
    z.istate.mode = BLOCKS;
    return Z_OK;
  }

  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};

  int inflateSync(ZStream z){
    int n;       // number of bytes to look at
    int p;       // pointer to bytes
    int m;       // number of marker bytes found in a row
    long r, w;   // temporaries to save total_in and total_out

    // set up
    if(z == null || z.istate == null)
      return Z_STREAM_ERROR;
    if(z.istate.mode != BAD){
      z.istate.mode = BAD;
      z.istate.marker = 0;
    }
    if((n=z.avail_in)==0)
      return Z_BUF_ERROR;
    p=z.next_in_index;
    m=z.istate.marker;

    // search
    while (n!=0 && m < 4){
      if(z.next_in[p] == mark[m]){
        m++;
      }
      else if(z.next_in[p]!=0){
        m = 0;
      }
      else{
        m = 4 - m;
      }
      p++; n--;
    }

    // restore
    z.total_in += p-z.next_in_index;
    z.next_in_index = p;
    z.avail_in = n;
    z.istate.marker = m;

    // return no joy or set up to restart on a new block
    if(m != 4){
      return Z_DATA_ERROR;
    }
    r=z.total_in;  w=z.total_out;
    inflateReset(z);
    z.total_in=r;  z.total_out = w;
    z.istate.mode = BLOCKS;
    return Z_OK;
  }

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
  // but removes the length bytes of the resulting empty stored block. When
  // decompressing, PPP checks that at the end of input packet, inflate is
  // waiting for these length bytes.
  int inflateSyncPoint(ZStream z){
    if(z == null || z.istate == null || z.istate.blocks == null)
      return Z_STREAM_ERROR;
    return z.istate.blocks.sync_point();
  }
}
/* -*-mode:java; c-basic-offset:2; indent-tabs-mode:nil -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

import util.ArrayLoader;

final class InfTree{

  static final private int MANY=1440;

  static final private int Z_OK=0;
  static final private int Z_STREAM_END=1;
  static final private int Z_NEED_DICT=2;
  static final private int Z_ERRNO=-1;
  static final private int Z_STREAM_ERROR=-2;
  static final private int Z_DATA_ERROR=-3;
  static final private int Z_MEM_ERROR=-4;
  static final private int Z_BUF_ERROR=-5;
  static final private int Z_VERSION_ERROR=-6;

  static final int fixed_bl = 9;
  static final int fixed_bd = 5;

/*  static final int[] fixed_tl = {
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,192,
    80,7,10, 0,8,96, 0,8,32, 0,9,160,
    0,8,0, 0,8,128, 0,8,64, 0,9,224,
    80,7,6, 0,8,88, 0,8,24, 0,9,144,
    83,7,59, 0,8,120, 0,8,56, 0,9,208,
    81,7,17, 0,8,104, 0,8,40, 0,9,176,
    0,8,8, 0,8,136, 0,8,72, 0,9,240,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,200,
    81,7,13, 0,8,100, 0,8,36, 0,9,168,
    0,8,4, 0,8,132, 0,8,68, 0,9,232,
    80,7,8, 0,8,92, 0,8,28, 0,9,152,
    84,7,83, 0,8,124, 0,8,60, 0,9,216,
    82,7,23, 0,8,108, 0,8,44, 0,9,184,
    0,8,12, 0,8,140, 0,8,76, 0,9,248,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,196,
    81,7,11, 0,8,98, 0,8,34, 0,9,164,
    0,8,2, 0,8,130, 0,8,66, 0,9,228,
    80,7,7, 0,8,90, 0,8,26, 0,9,148,
    84,7,67, 0,8,122, 0,8,58, 0,9,212,
    82,7,19, 0,8,106, 0,8,42, 0,9,180,
    0,8,10, 0,8,138, 0,8,74, 0,9,244,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,204,
    81,7,15, 0,8,102, 0,8,38, 0,9,172,
    0,8,6, 0,8,134, 0,8,70, 0,9,236,
    80,7,9, 0,8,94, 0,8,30, 0,9,156,
    84,7,99, 0,8,126, 0,8,62, 0,9,220,
    82,7,27, 0,8,110, 0,8,46, 0,9,188,
    0,8,14, 0,8,142, 0,8,78, 0,9,252,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,194,
    80,7,10, 0,8,97, 0,8,33, 0,9,162,
    0,8,1, 0,8,129, 0,8,65, 0,9,226,
    80,7,6, 0,8,89, 0,8,25, 0,9,146,
    83,7,59, 0,8,121, 0,8,57, 0,9,210,
    81,7,17, 0,8,105, 0,8,41, 0,9,178,
    0,8,9, 0,8,137, 0,8,73, 0,9,242,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,202,
    81,7,13, 0,8,101, 0,8,37, 0,9,170,
    0,8,5, 0,8,133, 0,8,69, 0,9,234,
    80,7,8, 0,8,93, 0,8,29, 0,9,154,
    84,7,83, 0,8,125, 0,8,61, 0,9,218,
    82,7,23, 0,8,109, 0,8,45, 0,9,186,
    0,8,13, 0,8,141, 0,8,77, 0,9,250,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,198,
    81,7,11, 0,8,99, 0,8,35, 0,9,166,
    0,8,3, 0,8,131, 0,8,67, 0,9,230,
    80,7,7, 0,8,91, 0,8,27, 0,9,150,
    84,7,67, 0,8,123, 0,8,59, 0,9,214,
    82,7,19, 0,8,107, 0,8,43, 0,9,182,
    0,8,11, 0,8,139, 0,8,75, 0,9,246,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,206,
    81,7,15, 0,8,103, 0,8,39, 0,9,174,
    0,8,7, 0,8,135, 0,8,71, 0,9,238,
    80,7,9, 0,8,95, 0,8,31, 0,9,158,
    84,7,99, 0,8,127, 0,8,63, 0,9,222,
    82,7,27, 0,8,111, 0,8,47, 0,9,190,
    0,8,15, 0,8,143, 0,8,79, 0,9,254,
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,193,

    80,7,10, 0,8,96, 0,8,32, 0,9,161,
    0,8,0, 0,8,128, 0,8,64, 0,9,225,
    80,7,6, 0,8,88, 0,8,24, 0,9,145,
    83,7,59, 0,8,120, 0,8,56, 0,9,209,
    81,7,17, 0,8,104, 0,8,40, 0,9,177,
    0,8,8, 0,8,136, 0,8,72, 0,9,241,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,201,
    81,7,13, 0,8,100, 0,8,36, 0,9,169,
    0,8,4, 0,8,132, 0,8,68, 0,9,233,
    80,7,8, 0,8,92, 0,8,28, 0,9,153,
    84,7,83, 0,8,124, 0,8,60, 0,9,217,
    82,7,23, 0,8,108, 0,8,44, 0,9,185,
    0,8,12, 0,8,140, 0,8,76, 0,9,249,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,197,
    81,7,11, 0,8,98, 0,8,34, 0,9,165,
    0,8,2, 0,8,130, 0,8,66, 0,9,229,
    80,7,7, 0,8,90, 0,8,26, 0,9,149,
    84,7,67, 0,8,122, 0,8,58, 0,9,213,
    82,7,19, 0,8,106, 0,8,42, 0,9,181,
    0,8,10, 0,8,138, 0,8,74, 0,9,245,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,205,
    81,7,15, 0,8,102, 0,8,38, 0,9,173,
    0,8,6, 0,8,134, 0,8,70, 0,9,237,
    80,7,9, 0,8,94, 0,8,30, 0,9,157,
    84,7,99, 0,8,126, 0,8,62, 0,9,221,
    82,7,27, 0,8,110, 0,8,46, 0,9,189,
    0,8,14, 0,8,142, 0,8,78, 0,9,253,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,195,
    80,7,10, 0,8,97, 0,8,33, 0,9,163,
    0,8,1, 0,8,129, 0,8,65, 0,9,227,
    80,7,6, 0,8,89, 0,8,25, 0,9,147,
    83,7,59, 0,8,121, 0,8,57, 0,9,211,
    81,7,17, 0,8,105, 0,8,41, 0,9,179,
    0,8,9, 0,8,137, 0,8,73, 0,9,243,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,203,
    81,7,13, 0,8,101, 0,8,37, 0,9,171,
    0,8,5, 0,8,133, 0,8,69, 0,9,235,
    80,7,8, 0,8,93, 0,8,29, 0,9,155,
    84,7,83, 0,8,125, 0,8,61, 0,9,219,
    82,7,23, 0,8,109, 0,8,45, 0,9,187,
    0,8,13, 0,8,141, 0,8,77, 0,9,251,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,199,
    81,7,11, 0,8,99, 0,8,35, 0,9,167,
    0,8,3, 0,8,131, 0,8,67, 0,9,231,
    80,7,7, 0,8,91, 0,8,27, 0,9,151,
    84,7,67, 0,8,123, 0,8,59, 0,9,215,
    82,7,19, 0,8,107, 0,8,43, 0,9,183,
    0,8,11, 0,8,139, 0,8,75, 0,9,247,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,207,
    81,7,15, 0,8,103, 0,8,39, 0,9,175,
    0,8,7, 0,8,135, 0,8,71, 0,9,239,
    80,7,9, 0,8,95, 0,8,31, 0,9,159,
    84,7,99, 0,8,127, 0,8,63, 0,9,223,
    82,7,27, 0,8,111, 0,8,47, 0,9,191,
    0,8,15, 0,8,143, 0,8,79, 0,9,255
  };
  static final int[] fixed_td = {
    80,5,1, 87,5,257, 83,5,17, 91,5,4097,
    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,
    80,5,3, 88,5,513, 84,5,33, 92,5,8193,
    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,
    80,5,2, 87,5,385, 83,5,25, 91,5,6145,
    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,
    80,5,4, 88,5,769, 84,5,49, 92,5,12289,
    82,5,13, 90,5,3073, 86,5,193, 192,5,24577
  };*/
  

  // Tables for deflate from PKZIP's appnote.txt.
  static final int[] cplens = { // Copy lengths for literal codes 257..285
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  };

  // see note #13 above about 258
  static final int[] cplext = { // Extra bits for literal codes 257..285
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid
  };

  static final int[] cpdist = { // Copy offsets for distance codes 0..29
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577
  };

  static final int[] cpdext = { // Extra bits for distance codes
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};

  // If BMAX needs to be larger than 16, then h and x[] should be uLong.
  static final int BMAX=15;         // maximum bit length of any code

  int[] hn = null;  // hufts used in space
  int[] v = null;   // work area for huft_build 
  int[] c = null;   // bit length count table
  int[] r = null;   // table entry for structure assignment
  int[] u = null;   // table stack
  int[] x = null;   // bit offsets, then code stack

  private static int[] fixed_tl;

  private static int[] fixed_td;

  private int huft_build(int[] b, // code lengths in bits (all assumed <= BMAX)
                         int bindex, 
                         int n,   // number of codes (assumed <= 288)
                         int s,   // number of simple-valued codes (0..s-1)
                         int[] d, // list of base values for non-simple codes
                         int[] e, // list of extra bits for non-simple codes
                         int[] t, // result: starting table
                         int[] m, // maximum lookup bits, returns actual
                         int[] hp,// space for trees
                         int[] hn,// hufts used in space
                         int[] v  // working area: values in order of bit length
                         ){
    // Given a list of code lengths and a maximum table size, make a set of
    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
    // if the given code set is incomplete (the tables are still built in this
    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
    // lengths), or Z_MEM_ERROR if not enough memory.

    int a;                       // counter for codes of length k
    int f;                       // i repeats in table every f entries
    int g;                       // maximum code length
    int h;                       // table level
    int i;                       // counter, current code
    int j;                       // counter
    int k;                       // number of bits in current code
    int l;                       // bits per table (returned in m)
    int mask;                    // (1 << w) - 1, to avoid cc -O bug on HP
    int p;                       // pointer into c[], b[], or v[]
    int q;                       // points to current table
    int w;                       // bits before this table == (l * h)
    int xp;                      // pointer into x
    int y;                       // number of dummy codes added
    int z;                       // number of entries in current table

    // Generate counts for each bit length

    p = 0; i = n;
    do {
      c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX
    }while(i!=0);

    if(c[0] == n){                // null input--all zero length codes
      t[0] = -1;
      m[0] = 0;
      return Z_OK;
    }

    // Find minimum and maximum length, bound *m by those
    l = m[0];
    for (j = 1; j <= BMAX; j++)
      if(c[j]!=0) break;
    k = j;                        // minimum code length
    if(l < j){
      l = j;
    }
    for (i = BMAX; i!=0; i--){
      if(c[i]!=0) break;
    }
    g = i;                        // maximum code length
    if(l > i){
      l = i;
    }
    m[0] = l;

    // Adjust last length count to fill out codes, if needed
    for (y = 1 << j; j < i; j++, y <<= 1){
      if ((y -= c[j]) < 0){
        return Z_DATA_ERROR;
      }
    }
    if ((y -= c[i]) < 0){
      return Z_DATA_ERROR;
    }
    c[i] += y;

    // Generate starting offsets into the value table for each length
    x[1] = j = 0;
    p = 1;  xp = 2;
    while (--i!=0) {                 // note that i == g from above
      x[xp] = (j += c[p]);
      xp++;
      p++;
    }

    // Make a table of values in order of bit lengths
    i = 0; p = 0;
    do {
      if ((j = b[bindex+p]) != 0){
        v[x[j]++] = i;
      }
      p++;
    }
    while (++i < n);
    n = x[g];                     // set n to length of v

    // Generate the Huffman codes and for each, make the table entries
    x[0] = i = 0;                 // first Huffman code is zero
    p = 0;                        // grab values in bit order
    h = -1;                       // no tables yet--level -1
    w = -l;                       // bits decoded == (l * h)
    u[0] = 0;                     // just to keep compilers happy
    q = 0;                        // ditto
    z = 0;                        // ditto

    // go through the bit lengths (k already is bits in shortest code)
    for (; k <= g; k++){
      a = c[k];
      while (a--!=0){
	// here i is the Huffman code of length k bits for value *p
	// make tables up to required level
        while (k > w + l){
          h++;
          w += l;                 // previous table always l bits
	  // compute minimum size table less than or equal to l bits
          z = g - w;
          z = (z > l) ? l : z;        // table size upper limit
          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table
                                      // too few codes for k-w bit table
            f -= a + 1;               // deduct codes from patterns left
            xp = k;
            if(j < z){
              while (++j < z){        // try smaller tables up to z bits
                if((f <<= 1) <= c[++xp])
                  break;              // enough codes to use up j bits
                f -= c[xp];           // else deduct codes from patterns
              }
	    }
          }
          z = 1 << j;                 // table entries for j-bit table

	  // allocate new table
          if (hn[0] + z > MANY){       // (note: doesn't matter for fixed)
            return Z_DATA_ERROR;       // overflow of MANY
          }
          u[h] = q = /*hp+*/ hn[0];   // DEBUG
          hn[0] += z;
 
	  // connect to last table, if there is one
	  if(h!=0){
            x[h]=i;           // save pattern for backing up
            r[0]=(byte)j;     // bits in this table
            r[1]=(byte)l;     // bits to dump before this table
            j=i>>>(w - l);
            r[2] = (int)(q - u[h-1] - j);               // offset to this table
            System.arraycopy(r, 0, hp, (u[h-1]+j)*3, 3); // connect to last table
          }
          else{
            t[0] = q;               // first table is returned result
	  }
        }

	// set up table entry in r
        r[1] = (byte)(k - w);
        if (p >= n){
          r[0] = 128 + 64;      // out of values--invalid code
	}
        else if (v[p] < s){
          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block
          r[2] = v[p++];          // simple code is just the value
        }
        else{
          r[0]=(byte)(e[v[p]-s]+16+64); // non-simple--look up in lists
          r[2]=d[v[p++] - s];
        }

        // fill code-like entries with r
        f=1<<(k-w);
        for (j=i>>>w;j<z;j+=f){
          System.arraycopy(r, 0, hp, (q+j)*3, 3);
	}

	// backwards increment the k-bit code i
        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){
          i ^= j;
	}
        i ^= j;

	// backup over finished tables
        mask = (1 << w) - 1;      // needed on HP, cc -O bug
        while ((i & mask) != x[h]){
          h--;                    // don't need to update q
          w -= l;
          mask = (1 << w) - 1;
        }
      }
    }
    // Return Z_BUF_ERROR if we were given an incomplete table
    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
  }

  int inflate_trees_bits(int[] c,  // 19 code lengths
                         int[] bb, // bits tree desired/actual depth
                         int[] tb, // bits tree result
                         int[] hp, // space for trees
                         ZStream z // for messages
                         ){
    int result;
    initWorkArea(19);
    hn[0]=0;
    result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);

    if(result == Z_DATA_ERROR){
      z.msg = "oversubscribed dynamic bit lengths tree";
    }
    else if(result == Z_BUF_ERROR || bb[0] == 0){
      z.msg = "incomplete dynamic bit lengths tree";
      result = Z_DATA_ERROR;
    }
    return result;
  }

  int inflate_trees_dynamic(int nl,   // number of literal/length codes
                            int nd,   // number of distance codes
                            int[] c,  // that many (total) code lengths
                            int[] bl, // literal desired/actual bit depth
                            int[] bd, // distance desired/actual bit depth 
                            int[] tl, // literal/length tree result
                            int[] td, // distance tree result
                            int[] hp, // space for trees
                            ZStream z // for messages
                            ){
    int result;

    // build literal/length tree
    initWorkArea(288);
    hn[0]=0;
    result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
    if (result != Z_OK || bl[0] == 0){
      if(result == Z_DATA_ERROR){
        z.msg = "oversubscribed literal/length tree";
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "incomplete literal/length tree";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    // build distance tree
    initWorkArea(288);
    result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);

    if (result != Z_OK || (bd[0] == 0 && nl > 257)){
      if (result == Z_DATA_ERROR){
        z.msg = "oversubscribed distance tree";
      }
      else if (result == Z_BUF_ERROR) {
        z.msg = "incomplete distance tree";
        result = Z_DATA_ERROR;
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "empty distance tree with lengths";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    return Z_OK;
  }

  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth
                                 int[] bd,  //distance desired/actual bit depth
                                 int[][] tl,//literal/length tree result
                                 int[][] td,//distance tree result 
                                 ZStream z  //for memory allocation
				 ){
    bl[0]=fixed_bl;
    bd[0]=fixed_bd;
    
    if (fixed_tl==null) fixed_tl=new ArrayLoader().readIntArray("/fixed_tl");
    tl[0]=fixed_tl;
    if (fixed_td==null) fixed_td=new ArrayLoader().readIntArray("/fixed_td");
    td[0]=fixed_td;
    return Z_OK;
  }

  private void initWorkArea(int vsize){
    if(hn==null){
      hn=new int[1];
      v=new int[vsize];
      c=new int[BMAX+1];
      r=new int[3];
      u=new int[BMAX];
      x=new int[BMAX+1];
    }
    if(v.length<vsize){ v=new int[vsize]; }
    for(int i=0; i<vsize; i++){v[i]=0;}
    for(int i=0; i<BMAX+1; i++){c[i]=0;}
    for(int i=0; i<3; i++){r[i]=0;}
//  for(int i=0; i<BMAX; i++){u[i]=0;}
    System.arraycopy(c, 0, u, 0, BMAX);
//  for(int i=0; i<BMAX+1; i++){x[i]=0;}
    System.arraycopy(c, 0, x, 0, BMAX+1);
  }
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

final public class JZlib{
  private static final String version="1.0.2";
  public static String version(){return version;}

  // compression levels
  static final public int Z_NO_COMPRESSION=0;
  static final public int Z_BEST_SPEED=1;
  static final public int Z_BEST_COMPRESSION=9;
  static final public int Z_DEFAULT_COMPRESSION=(-1);

  // compression strategy
  static final public int Z_FILTERED=1;
  static final public int Z_HUFFMAN_ONLY=2;
  static final public int Z_DEFAULT_STRATEGY=0;

  static final public int Z_NO_FLUSH=0;
  static final public int Z_PARTIAL_FLUSH=1;
  static final public int Z_SYNC_FLUSH=2;
  static final public int Z_FULL_FLUSH=3;
  static final public int Z_FINISH=4;

  static final public int Z_OK=0;
  static final public int Z_STREAM_END=1;
  static final public int Z_NEED_DICT=2;
  static final public int Z_ERRNO=-1;
  static final public int Z_STREAM_ERROR=-2;
  static final public int Z_DATA_ERROR=-3;
  static final public int Z_MEM_ERROR=-4;
  static final public int Z_BUF_ERROR=-5;
  static final public int Z_VERSION_ERROR=-6;
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

import util.ArrayLoader;

final class StaticTree{
  static final private int MAX_BITS=15;

  static final private int BL_CODES=19;
  static final private int D_CODES=30;
  static final private int LITERALS=256;
  static final private int LENGTH_CODES=29;
  static final private int L_CODES=(LITERALS+1+LENGTH_CODES);

  // Bit length codes must not exceed MAX_BL_BITS bits
  static final int MAX_BL_BITS=7; 

  /*private static final short[] static_ltree = {
    12,  8, 140,  8,  76,  8, 204,  8,  44,  8,
    172,  8, 108,  8, 236,  8,  28,  8, 156,  8,
    92,  8, 220,  8,  60,  8, 188,  8, 124,  8,
    252,  8,   2,  8, 130,  8,  66,  8, 194,  8,
    34,  8, 162,  8,  98,  8, 226,  8,  18,  8,
    146,  8,  82,  8, 210,  8,  50,  8, 178,  8,
    114,  8, 242,  8,  10,  8, 138,  8,  74,  8,
    202,  8,  42,  8, 170,  8, 106,  8, 234,  8,
    26,  8, 154,  8,  90,  8, 218,  8,  58,  8,
    186,  8, 122,  8, 250,  8,   6,  8, 134,  8,
    70,  8, 198,  8,  38,  8, 166,  8, 102,  8,
    230,  8,  22,  8, 150,  8,  86,  8, 214,  8,
    54,  8, 182,  8, 118,  8, 246,  8,  14,  8,
    142,  8,  78,  8, 206,  8,  46,  8, 174,  8,
    110,  8, 238,  8,  30,  8, 158,  8,  94,  8,
    222,  8,  62,  8, 190,  8, 126,  8, 254,  8,
    1,  8, 129,  8,  65,  8, 193,  8,  33,  8,
    161,  8,  97,  8, 225,  8,  17,  8, 145,  8,
    81,  8, 209,  8,  49,  8, 177,  8, 113,  8,
    241,  8,   9,  8, 137,  8,  73,  8, 201,  8,
    41,  8, 169,  8, 105,  8, 233,  8,  25,  8,
    153,  8,  89,  8, 217,  8,  57,  8, 185,  8,
    121,  8, 249,  8,   5,  8, 133,  8,  69,  8,
    197,  8,  37,  8, 165,  8, 101,  8, 229,  8,
    21,  8, 149,  8,  85,  8, 213,  8,  53,  8,
    181,  8, 117,  8, 245,  8,  13,  8, 141,  8,
    77,  8, 205,  8,  45,  8, 173,  8, 109,  8,
    237,  8,  29,  8, 157,  8,  93,  8, 221,  8,
    61,  8, 189,  8, 125,  8, 253,  8,  19,  9,
    275,  9, 147,  9, 403,  9,  83,  9, 339,  9,
    211,  9, 467,  9,  51,  9, 307,  9, 179,  9,
    435,  9, 115,  9, 371,  9, 243,  9, 499,  9,
    11,  9, 267,  9, 139,  9, 395,  9,  75,  9,
    331,  9, 203,  9, 459,  9,  43,  9, 299,  9,
    171,  9, 427,  9, 107,  9, 363,  9, 235,  9,
    491,  9,  27,  9, 283,  9, 155,  9, 411,  9,
    91,  9, 347,  9, 219,  9, 475,  9,  59,  9,
    315,  9, 187,  9, 443,  9, 123,  9, 379,  9,
    251,  9, 507,  9,   7,  9, 263,  9, 135,  9,
    391,  9,  71,  9, 327,  9, 199,  9, 455,  9,
    39,  9, 295,  9, 167,  9, 423,  9, 103,  9,
    359,  9, 231,  9, 487,  9,  23,  9, 279,  9,
    151,  9, 407,  9,  87,  9, 343,  9, 215,  9,
    471,  9,  55,  9, 311,  9, 183,  9, 439,  9,
    119,  9, 375,  9, 247,  9, 503,  9,  15,  9,
    271,  9, 143,  9, 399,  9,  79,  9, 335,  9,
    207,  9, 463,  9,  47,  9, 303,  9, 175,  9,
    431,  9, 111,  9, 367,  9, 239,  9, 495,  9,
    31,  9, 287,  9, 159,  9, 415,  9,  95,  9,
    351,  9, 223,  9, 479,  9,  63,  9, 319,  9,
    191,  9, 447,  9, 127,  9, 383,  9, 255,  9,
    511,  9,   0,  7,  64,  7,  32,  7,  96,  7,
    16,  7,  80,  7,  48,  7, 112,  7,   8,  7,
    72,  7,  40,  7, 104,  7,  24,  7,  88,  7,
    56,  7, 120,  7,   4,  7,  68,  7,  36,  7,
    100,  7,  20,  7,  84,  7,  52,  7, 116,  7,
    3,  8, 131,  8,  67,  8, 195,  8,  35,  8,
    163,  8,  99,  8, 227,  8
  };*/

  static final short[] static_dtree = {
    0, 5, 16, 5,  8, 5, 24, 5,  4, 5,
    20, 5, 12, 5, 28, 5,  2, 5, 18, 5,
    10, 5, 26, 5,  6, 5, 22, 5, 14, 5,
    30, 5,  1, 5, 17, 5,  9, 5, 25, 5,
    5, 5, 21, 5, 13, 5, 29, 5,  3, 5,
    19, 5, 11, 5, 27, 5,  7, 5, 23, 5
  };

  static StaticTree static_l_desc =
    new StaticTree(getStatic_ltree(), Tree.extra_lbits,
		   LITERALS+1, L_CODES, MAX_BITS);

  static StaticTree static_d_desc =
    new StaticTree(static_dtree, Tree.extra_dbits,
		   0,  D_CODES, MAX_BITS);

  static StaticTree static_bl_desc =
    new StaticTree(null, Tree.extra_blbits,
		   0, BL_CODES, MAX_BL_BITS);

  short[] static_tree;     // static tree or null
  int[] extra_bits;        // extra bits for each code or null
  int extra_base;          // base index for extra_bits
  int elems;               // max number of elements in the tree
  int max_length;          // max bit length for the codes

    private static short[] static_ltree;

  StaticTree(short[] static_tree,
	     int[] extra_bits,
	     int extra_base,
	     int elems,
	     int max_length
	     ){
    this.static_tree=static_tree;
    this.extra_bits=extra_bits;
    this.extra_base=extra_base;
    this.elems=elems;
    this.max_length=max_length;
  }

    public static short[] getStatic_ltree() {
        if (static_ltree==null) static_ltree=new ArrayLoader().readShortArray("/static_ltree");
        return static_ltree;
    }
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

import util.ArrayLoader;

final class Tree{
  static final private int MAX_BITS=15;
  static final private int BL_CODES=19;
  static final private int D_CODES=30;
  static final private int LITERALS=256;
  static final private int LENGTH_CODES=29;
  static final private int L_CODES=(LITERALS+1+LENGTH_CODES);
  static final private int HEAP_SIZE=(2*L_CODES+1);

  // Bit length codes must not exceed MAX_BL_BITS bits
  static final int MAX_BL_BITS=7; 

  // end of block literal code
  static final int END_BLOCK=256; 

  // repeat previous bit length 3-6 times (2 bits of repeat count)
  static final int REP_3_6=16; 

  // repeat a zero length 3-10 times  (3 bits of repeat count)
  static final int REPZ_3_10=17; 

  // repeat a zero length 11-138 times  (7 bits of repeat count)
  static final int REPZ_11_138=18; 

  // extra bits for each length code
  static final int[] extra_lbits={
    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0
  };

  // extra bits for each distance code
  static final int[] extra_dbits={
    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13
  };

  // extra bits for each bit length code
  static final int[] extra_blbits={
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7
  };

  static final byte[] bl_order={
    16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};


  // The lengths of the bit length codes are sent in order of decreasing
  // probability, to avoid transmitting the lengths for unused bit
  // length codes.

  static final int Buf_size=8*2;

  // see definition of array dist_code below
  static final int DIST_CODE_LEN=512;

  static byte[] _dist_code;
  /*static final byte[] _dist_code = {
    0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
    8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
    18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
    23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
  };*/

  private static byte[] _length_code;
  /*private static final byte[] _length_code={
    0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
    13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
    17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
    19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
  };*/

  static final int[] base_length = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
    64, 80, 96, 112, 128, 160, 192, 224, 0
  };

  static final int[] base_dist = {
       0,   1,      2,     3,     4,    6,     8,    12,    16,     24,
      32,  48,     64,    96,   128,  192,   256,   384,   512,    768,
    1024, 1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
  };

  // Mapping from a distance to a distance code. dist is the distance - 1 and
  // must not have side effects. _dist_code[256] and _dist_code[257] are never
  // used.
  static int d_code(int dist){
      if (_dist_code==null) _dist_code=new ArrayLoader().readByteArray("/dist_code");
      //ArrayLoader.writeByteArray("dist_code", _dist_code);
    return ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>>7)]);
  }

  short[] dyn_tree;      // the dynamic tree
  int     max_code;      // largest code with non zero frequency
  StaticTree stat_desc;  // the corresponding static tree

  // Compute the optimal bit lengths for a tree and update the total bit length
  // for the current block.
  // IN assertion: the fields freq and dad are set, heap[heap_max] and
  //    above are the tree nodes sorted by increasing frequency.
  // OUT assertions: the field len is set to the optimal bit length, the
  //     array bl_count contains the frequencies for each bit length.
  //     The length opt_len is updated; static_len is also updated if stree is
  //     not null.
  void gen_bitlen(Deflate s){
    short[] tree = dyn_tree;
    short[] stree = stat_desc.static_tree;
    int[] extra = stat_desc.extra_bits;
    int base = stat_desc.extra_base;
    int max_length = stat_desc.max_length;
    int h;              // heap index
    int n, m;           // iterate over the tree elements
    int bits;           // bit length
    int xbits;          // extra bits
    short f;            // frequency
    int overflow = 0;   // number of elements with bit length too large

    for (bits = 0; bits <= MAX_BITS; bits++) s.bl_count[bits] = 0;

    // In a first pass, compute the optimal bit lengths (which may
    // overflow in the case of the bit length tree).
    tree[s.heap[s.heap_max]*2+1] = 0; // root of the heap

    for(h=s.heap_max+1; h<HEAP_SIZE; h++){
      n = s.heap[h];
      bits = tree[tree[n*2+1]*2+1] + 1;
      if (bits > max_length){ bits = max_length; overflow++; }
      tree[n*2+1] = (short)bits;
      // We overwrite tree[n*2+1] which is no longer needed

      if (n > max_code) continue;  // not a leaf node

      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) xbits = extra[n-base];
      f = tree[n*2];
      s.opt_len += f * (bits + xbits);
      if (stree!=null) s.static_len += f * (stree[n*2+1] + xbits);
    }
    if (overflow == 0) return;

    // This happens for example on obj2 and pic of the Calgary corpus
    // Find the first bit length which could increase:
    do {
      bits = max_length-1;
      while(s.bl_count[bits]==0) bits--;
      s.bl_count[bits]--;      // move one leaf down the tree
      s.bl_count[bits+1]+=2;   // move one overflow item as its brother
      s.bl_count[max_length]--;
      // The brother of the overflow item also moves one step up,
      // but this does not affect bl_count[max_length]
      overflow -= 2;
    }
    while (overflow > 0);

    for (bits = max_length; bits != 0; bits--) {
      n = s.bl_count[bits];
      while (n != 0) {
	m = s.heap[--h];
	if (m > max_code) continue;
	if (tree[m*2+1] != bits) {
	  s.opt_len += ((long)bits - (long)tree[m*2+1])*(long)tree[m*2];
	  tree[m*2+1] = (short)bits;
	}
	n--;
      }
    }
  }

  // Construct one Huffman tree and assigns the code bit strings and lengths.
  // Update the total bit length for the current block.
  // IN assertion: the field freq is set for all tree elements.
  // OUT assertions: the fields len and code are set to the optimal bit length
  //     and corresponding code. The length opt_len is updated; static_len is
  //     also updated if stree is not null. The field max_code is set.
  void build_tree(Deflate s){
    short[] tree=dyn_tree;
    short[] stree=stat_desc.static_tree;
    int elems=stat_desc.elems;
    int n, m;          // iterate over heap elements
    int max_code=-1;   // largest code with non zero frequency
    int node;          // new node being created

    // Construct the initial heap, with least frequent element in
    // heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
    // heap[0] is not used.
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;

    for(n=0; n<elems; n++) {
      if(tree[n*2] != 0) {
	s.heap[++s.heap_len] = max_code = n;
	s.depth[n] = 0;
      }
      else{
	tree[n*2+1] = 0;
      }
    }

    // The pkzip format requires that at least one distance code exists,
    // and that at least one bit should be sent even if there is only one
    // possible code. So to avoid special checks later on we force at least
    // two codes of non zero frequency.
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
      tree[node*2] = 1;
      s.depth[node] = 0;
      s.opt_len--; if (stree!=null) s.static_len -= stree[node*2+1];
      // node is 0 or 1 so it does not have extra bits
    }
    this.max_code = max_code;

    // The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
    // establish sub-heaps of increasing lengths:

    for(n=s.heap_len/2;n>=1; n--)
      s.pqdownheap(tree, n);

    // Construct the Huffman tree by repeatedly combining the least two
    // frequent nodes.

    node=elems;                 // next internal node of the tree
    do{
      // n = node of least frequency
      n=s.heap[1];
      s.heap[1]=s.heap[s.heap_len--];
      s.pqdownheap(tree, 1);
      m=s.heap[1];                // m = node of next least frequency

      s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency
      s.heap[--s.heap_max] = m;

      // Create a new node father of n and m
      tree[node*2] = (short)(tree[n*2] + tree[m*2]);
      s.depth[node] = (byte)(Math.max(s.depth[n],s.depth[m])+1);
      tree[n*2+1] = tree[m*2+1] = (short)node;

      // and insert the new node in the heap
      s.heap[1] = node++;
      s.pqdownheap(tree, 1);
    }
    while(s.heap_len>=2);

    s.heap[--s.heap_max] = s.heap[1];

    // At this point, the fields freq and dad are set. We can now
    // generate the bit lengths.

    gen_bitlen(s);

    // The field len is now set, we can generate the bit codes
    gen_codes(tree, max_code, s.bl_count);
  }

  // Generate the codes for a given tree and bit counts (which need not be
  // optimal).
  // IN assertion: the array bl_count contains the bit length statistics for
  // the given tree and the field len is set for all tree elements.
  // OUT assertion: the field code is set for all tree elements of non
  //     zero code length.
  static void gen_codes(short[] tree, // the tree to decorate
			int max_code, // largest code with non zero frequency
			short[] bl_count // number of codes at each bit length
			){
    short[] next_code=new short[MAX_BITS+1]; // next code value for each bit length
    short code = 0;            // running code value
    int bits;                  // bit index
    int n;                     // code index

    // The distribution counts are first used to generate the code values
    // without bit reversal.
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = (short)((code + bl_count[bits-1]) << 1);
    }

    // Check that the bit counts in bl_count are consistent. The last code
    // must be all ones.
    //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
    //        "inconsistent bit counts");
    //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
      int len = tree[n*2+1];
      if (len == 0) continue;
      // Now reverse the bits
      tree[n*2] = (short)(bi_reverse(next_code[len]++, len));
    }
  }

  // Reverse the first len bits of a code, using straightforward code (a faster
  // method would use a table)
  // IN assertion: 1 <= len <= 15
  static int bi_reverse(int code, // the value to invert
			int len   // its bit length
			){
    int res = 0;
    do{
      res|=code&1;
      code>>>=1;
      res<<=1;
    } 
    while(--len>0);
    return res>>>1;
  }

    public static byte getLength_code(int lc) {
        //ArrayLoader.writeByteArray("length_code",_length_code);
        if (_length_code==null) _length_code=new ArrayLoader().readByteArray("/length_code");
        return _length_code[lc];
    }
}

/* -*-mode:java; c-basic-offset:2; indent-tabs-mode:nil -*- */
/*
Copyright (c) 2001 Lapo Luchini.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS
OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;
import java.io.*;

public class ZInputStream extends FilterInputStream {

  protected ZStream z=new ZStream();
  protected int bufsize=512;
  protected int flush=JZlib.Z_NO_FLUSH;
  protected byte[] buf=new byte[bufsize],
                   buf1=new byte[1];
  protected boolean compress;

  protected InputStream in=null;

  public ZInputStream(InputStream in) {
    this(in, false);
  }
  public ZInputStream(InputStream in, boolean nowrap) {
    super(in);
    this.in=in;
    z.inflateInit(nowrap);
    compress=false;
    z.next_in=buf;
    z.next_in_index=0;
    z.avail_in=0;
  }

  public ZInputStream(InputStream in, int level) {
    super(in);
    this.in=in;
    z.deflateInit(level);
    compress=true;
    z.next_in=buf;
    z.next_in_index=0;
    z.avail_in=0;
  }

  /*public int available() throws IOException {
    return inf.finished() ? 0 : 1;
  }*/

  public int read() throws IOException {
    if(read(buf1, 0, 1)==-1)
      return(-1);
    return(buf1[0]&0xFF);
  }

  private boolean nomoreinput=false;

  public int read(byte[] b, int off, int len) throws IOException {
    if(len==0)
      return(0);
    int err;
    z.next_out=b;
    z.next_out_index=off;
    z.avail_out=len;
    do {
      if((z.avail_in==0)&&(!nomoreinput)) { // if buffer is empty and more input is avaiable, refill it
	z.next_in_index=0;
        
        int avail=in.available();
        
        while (avail==0) {
            try { Thread.sleep(100); } catch (Exception e) {};
            avail=in.available();
        }

	z.avail_in=in.read(buf, 0, (avail<bufsize)?avail:bufsize);//(bufsize<z.avail_out ? bufsize : z.avail_out));
        
	if(z.avail_in==-1) {
	  z.avail_in=0;
	  nomoreinput=true;
	}
      }
      if(compress)
	err=z.deflate(flush);
      else
	err=z.inflate(flush);
      if(nomoreinput&&(err==JZlib.Z_BUF_ERROR))
        return(-1);
      if(err!=JZlib.Z_OK && err!=JZlib.Z_STREAM_END)
	throw new ZStreamException((compress ? "de" : "in")+"flating: "+z.msg);
      if((nomoreinput||err==JZlib.Z_STREAM_END)&&(z.avail_out==len))
	return(-1);
    } 
    while(z.avail_out==len&&err==JZlib.Z_OK);
    //System.err.print("("+(len-z.avail_out)+")");
    /*    for (int i=0; i<len-z.avail_out; i++) {
            System.out.print((char) b[i]);
        }
        System.out.println();
     */
    return(len-z.avail_out);
  }

  public long skip(long n) throws IOException {
    int len=512;
    if(n<len)
      len=(int)n;
    byte[] tmp=new byte[len];
    return((long)read(tmp));
  }

  public int getFlushMode() {
    return(flush);
  }

  public void setFlushMode(int flush) {
    this.flush=flush;
  }

  /**
   * We can't count available data size after zlib processing
   * so available() always returns internal buffer size
   */
  public int available() throws IOException {
      return bufsize;
  }


  /**
   * Returns the total number of bytes input so far.
   */
  public long getTotalIn() {
    return z.total_in;
  }

  /**
   * Returns the total number of bytes output so far.
   */
  public long getTotalOut() {
    return z.total_out;
  }

  public void close() throws IOException{
    in.close();
  }
}
/* -*-mode:java; c-basic-offset:2; indent-tabs-mode:nil -*- */
/*
Copyright (c) 2001 Lapo Luchini.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS
OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;
import java.io.*;

public class ZOutputStream extends OutputStream {

  protected ZStream z=new ZStream();
  protected int bufsize=512;
  protected int flush=JZlib.Z_NO_FLUSH;
  protected byte[] buf=new byte[bufsize],
                   buf1=new byte[1];
  protected boolean compress;

  protected OutputStream out;

  public ZOutputStream(OutputStream out) {
    super();
    this.out=out;
    z.inflateInit();
    compress=false;
  }

  public ZOutputStream(OutputStream out, int level) {
    this(out, level, false);
  }
  public ZOutputStream(OutputStream out, int level, boolean nowrap) {
    super();
    this.out=out;
    z.deflateInit(level, nowrap);
    compress=true;
  }

  public void write(int b) throws IOException {
    buf1[0]=(byte)b;
    write(buf1, 0, 1);
  }

  public void write(byte b[], int off, int len) throws IOException {
    if(len==0)
      return;
    int err;
    z.next_in=b;
    z.next_in_index=off;
    z.avail_in=len;
    do{
      z.next_out=buf;
      z.next_out_index=0;
      z.avail_out=bufsize;
      if(compress)
        err=z.deflate(flush);
      else
        err=z.inflate(flush);
      if(err!=JZlib.Z_OK)
        throw new ZStreamException((compress?"de":"in")+"flating: "+z.msg);
      out.write(buf, 0, bufsize-z.avail_out);
    } 
    while(z.avail_in>0 || z.avail_out==0);
  }

  public int getFlushMode() {
    return(flush);
  }

  public void setFlushMode(int flush) {
    this.flush=flush;
  }

  public void finish() throws IOException {
    int err;
    do{
      z.next_out=buf;
      z.next_out_index=0;
      z.avail_out=bufsize;
      if(compress){ err=z.deflate(JZlib.Z_FINISH);  }
      else{ err=z.inflate(JZlib.Z_FINISH); }
      if(err!=JZlib.Z_STREAM_END && err != JZlib.Z_OK)
      throw new ZStreamException((compress?"de":"in")+"flating: "+z.msg);
      if(bufsize-z.avail_out>0){
	out.write(buf, 0, bufsize-z.avail_out);
      }
    }
    while(z.avail_in>0 || z.avail_out==0);
    flush();
  }
  public void end() {
    if(z==null)
      return;
    if(compress){ z.deflateEnd(); }
    else{ z.inflateEnd(); }
    z.free();
    z=null;
  }
  public void close() throws IOException {
    try{
      try{finish();}
      catch (IOException ignored) {}
    }
    finally{
      end();
      out.close();
      out=null;
    }
  }

  /**
   * Returns the total number of bytes input so far.
   */
  public long getTotalIn() {
    return z.total_in;
  }

  /**
   * Returns the total number of bytes output so far.
   */
  public long getTotalOut() {
    return z.total_out;
  }

  public void flush() throws IOException {
    out.flush();
  }

}
/* -*-mode:java; c-basic-offset:2; indent-tabs-mode:nil -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

final public class ZStream{

  static final private int MAX_WBITS=15;        // 32K LZ77 window
  static final private int DEF_WBITS=MAX_WBITS;

  static final private int Z_NO_FLUSH=0;
  static final private int Z_PARTIAL_FLUSH=1;
  static final private int Z_SYNC_FLUSH=2;
  static final private int Z_FULL_FLUSH=3;
  static final private int Z_FINISH=4;

  static final private int MAX_MEM_LEVEL=9;

  static final private int Z_OK=0;
  static final private int Z_STREAM_END=1;
  static final private int Z_NEED_DICT=2;
  static final private int Z_ERRNO=-1;
  static final private int Z_STREAM_ERROR=-2;
  static final private int Z_DATA_ERROR=-3;
  static final private int Z_MEM_ERROR=-4;
  static final private int Z_BUF_ERROR=-5;
  static final private int Z_VERSION_ERROR=-6;

  public byte[] next_in;     // next input byte
  public int next_in_index;
  public int avail_in;       // number of bytes available at next_in
  public long total_in;      // total nb of input bytes read so far

  public byte[] next_out;    // next output byte should be put there
  public int next_out_index;
  public int avail_out;      // remaining free space at next_out
  public long total_out;     // total nb of bytes output so far

  public String msg;

  Deflate dstate; 
  Inflate istate; 

  int data_type; // best guess about the data type: ascii or binary

  public long adler;
  Adler32 _adler=new Adler32();

  public int inflateInit(){
    return inflateInit(DEF_WBITS);
  }
  public int inflateInit(boolean nowrap){
    return inflateInit(DEF_WBITS, nowrap);
  }
  public int inflateInit(int w){
    return inflateInit(w, false);
  }

  public int inflateInit(int w, boolean nowrap){
    istate=new Inflate();
    return istate.inflateInit(this, nowrap?-w:w);
  }

  public int inflate(int f){
    if(istate==null) return Z_STREAM_ERROR;
    return istate.inflate(this, f);
  }
  public int inflateEnd(){
    if(istate==null) return Z_STREAM_ERROR;
    int ret=istate.inflateEnd(this);
    istate = null;
    return ret;
  }
  public int inflateSync(){
    if(istate == null)
      return Z_STREAM_ERROR;
    return istate.inflateSync(this);
  }
  public int inflateSetDictionary(byte[] dictionary, int dictLength){
    if(istate == null)
      return Z_STREAM_ERROR;
    return istate.inflateSetDictionary(this, dictionary, dictLength);
  }

  public int deflateInit(int level){
    return deflateInit(level, MAX_WBITS);
  }
  public int deflateInit(int level, boolean nowrap){
    return deflateInit(level, MAX_WBITS, nowrap);
  }
  public int deflateInit(int level, int bits){
    return deflateInit(level, bits, false);
  }
  public int deflateInit(int level, int bits, boolean nowrap){
    dstate=new Deflate();
    return dstate.deflateInit(this, level, nowrap?-bits:bits);
  }
  public int deflate(int flush){
    if(dstate==null){
      return Z_STREAM_ERROR;
    }
    return dstate.deflate(this, flush);
  }
  public int deflateEnd(){
    if(dstate==null) return Z_STREAM_ERROR;
    int ret=dstate.deflateEnd();
    dstate=null;
    return ret;
  }
  public int deflateParams(int level, int strategy){
    if(dstate==null) return Z_STREAM_ERROR;
    return dstate.deflateParams(this, level, strategy);
  }
  public int deflateSetDictionary (byte[] dictionary, int dictLength){
    if(dstate == null)
      return Z_STREAM_ERROR;
    return dstate.deflateSetDictionary(this, dictionary, dictLength);
  }

  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  void flush_pending(){
    int len=dstate.pending;

    if(len>avail_out) len=avail_out;
    if(len==0) return;

    if(dstate.pending_buf.length<=dstate.pending_out ||
       next_out.length<=next_out_index ||
       dstate.pending_buf.length<(dstate.pending_out+len) ||
       next_out.length<(next_out_index+len)){
      System.out.println(dstate.pending_buf.length+", "+dstate.pending_out+
			 ", "+next_out.length+", "+next_out_index+", "+len);
      System.out.println("avail_out="+avail_out);
    }

    System.arraycopy(dstate.pending_buf, dstate.pending_out,
		     next_out, next_out_index, len);

    next_out_index+=len;
    dstate.pending_out+=len;
    total_out+=len;
    avail_out-=len;
    dstate.pending-=len;
    if(dstate.pending==0){
      dstate.pending_out=0;
    }
  }

  // Read a new buffer from the current input stream, update the adler32
  // and total number of bytes read.  All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  int read_buf(byte[] buf, int start, int size) {
    int len=avail_in;

    if(len>size) len=size;
    if(len==0) return 0;

    avail_in-=len;

    if(dstate.noheader==0) {
      adler=_adler.adler32(adler, next_in, next_in_index, len);
    }
    System.arraycopy(next_in, next_in_index, buf, start, len);
    next_in_index  += len;
    total_in += len;
    return len;
  }

  public void free(){
    next_in=null;
    next_out=null;
    msg=null;
    _adler=null;
  }
}
/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.jcraft.jzlib;

public class ZStreamException extends java.io.IOException {
  public ZStreamException() {
    super();
  }
  public ZStreamException(String s) {
    super(s);
  }
}
/*
 * @(#)MD5.java	1.9 95/08/07
 *
 * Copyright (c) 1994 Sun Microsystems, Inc. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for NON-COMMERCIAL purposes and without
 * fee is hereby granted provided that this copyright notice
 * appears in all copies. Please refer to the file "copyright.html"
 * for further important copyright and licensing information.
 *
 * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
 * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR
 * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 *
 * Updated to the JDK 1.0.2 release by Chuck McManis
 * 
 * This file was obtained from: http://www.mcmanis.com/~cmcmanis/java/src/util/crypt/MD5.java
 * More information can be found here: http://www.mcmanis.com/~cmcmanis/java/
 */

package com.ssttr.crypto;

/**
 * The MD5 class is used to compute an MD5 message digest over a given
 * buffer of bytes. It is an implementation of the RSA Data Security Inc
 * MD5 algorithim as described in internet RFC 1321.
 * @version 	06 Oct 1996, 1.9.1
 * @author 	Chuck McManis
 */
public final class MD5
extends MessageDigest
{
    /** containss the computed message digest */

    private int state[];
    private long count;
    private byte buffer[];
    private static int transformBuffer[];

    private static final int S11 = 7;
    private static final int S12 = 12;
    private static final int S13 = 17;
    private static final int S14 = 22;
    private static final int S21 = 5;
    private static final int S22 = 9;
    private static final int S23 = 14;
    private static final int S24 = 20;
    private static final int S31 = 4;
    private static final int S32 = 11;
    private static final int S33 = 16;
    private static final int S34 = 23;
    private static final int S41 = 6;
    private static final int S42 = 10;
    private static final int S43 = 15;
    private static final int S44 = 21;

    /**
     * Standard constructor, creates a new MD5 instance, allocates its
     * buffers from the heap.
     */
    public MD5() {
        state = new int[4];
        count = 0;
        if (transformBuffer == null)
            transformBuffer = new int[16];
        buffer = new byte[64];
        digestBits = new byte[16];
        digestValid = false;
    }

    /**
     * Alternate constructor, allows you to pass in the buffer where you
     * want the resulting digest stored.
     */
    public MD5(byte mydigest[]) {
        state = new int[4];
        count = 0;
        if (transformBuffer == null)
            transformBuffer = new int[16];
        buffer = new byte[64];
        digestBits = mydigest;
        digestValid = false;
    }

    /* **********************************************************
     * The MD5 Functions. These are copied verbatim from
     * the RFC to insure accuracy. The results of this
     * implementation were checked against the RSADSI version.
     * **********************************************************
     */

    private int F(int x, int y, int z) {
        return ((x & y) | ((~x) & z));
    }

    private int G(int x, int y, int z) {
        return ((x & z) | (y & (~z)));
    }

    private int H(int x, int y, int z) {
        return ((x ^ y) ^ z);
    }

    private int I(int x, int y, int z) {
        return (y ^ (x | (~z)));
    }

    private int rotateLeft(int a, int n) {
        return ((a << n) | (a >>> (32 - n)));
    }

    private int FF(int a, int b, int c, int d, int x, int s, int ac) {
        a += F(b, c, d) + x + ac;
        a = rotateLeft(a, s);
        a += b;
        return a;
    }

    private int GG(int a, int b, int c, int d, int x, int s, int ac) {
        a += G(b, c, d) + x + ac;
        a = rotateLeft(a, s);
        a += b;
        return a;
    }

    private int HH(int a, int b, int c, int d, int x, int s, int ac) {
        a += H(b, c, d) + x + ac;
        a = rotateLeft(a, s);
        a += b;
        return a;
    }

    private int II(int a, int b, int c, int d, int x, int s, int ac) {
        a += I(b, c, d) + x + ac;
        a = rotateLeft(a, s);
        a += b;
        return a;
    }

    /**
     * This is where the functions come together as the generic MD5
     * transformation operation, it is called by update() which is
     * synchronized (to protect transformBuffer)
     */
    void transform(byte buf[], int offset) {
        int a, b, c, d;
        int x[] = transformBuffer;

        a = state[0];
        b = state[1];
        c = state[2];
        d = state[3];

        for (int i = 0; i < 16; i++) {
            x[i] = (int)buf[i*4+offset] & 0xff;
            for (int j = 1; j < 4; j++) {
        	x[i] += ((int)buf[i*4+j+offset] & 0xff) << (j * 8);
            }
        }

        /* Round 1 */
        a = FF ( a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
        d = FF ( d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
        c = FF ( c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
        b = FF ( b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
        a = FF ( a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
        d = FF ( d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
        c = FF ( c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
        b = FF ( b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
        a = FF ( a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
        d = FF ( d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
        c = FF ( c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
        b = FF ( b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
        a = FF ( a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
        d = FF ( d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
        c = FF ( c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
        b = FF ( b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

        /* Round 2 */
        a = GG ( a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
        d = GG ( d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
        c = GG ( c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
        b = GG ( b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
        a = GG ( a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
        d = GG ( d, a, b, c, x[10], S22,  0x2441453); /* 22 */
        c = GG ( c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
        b = GG ( b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
        a = GG ( a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
        d = GG ( d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
        c = GG ( c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
        b = GG ( b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
        a = GG ( a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
        d = GG ( d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
        c = GG ( c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
        b = GG ( b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

        /* Round 3 */
        a = HH ( a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
        d = HH ( d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
        c = HH ( c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
        b = HH ( b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
        a = HH ( a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
        d = HH ( d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
        c = HH ( c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
        b = HH ( b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
        a = HH ( a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
        d = HH ( d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
        c = HH ( c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
        b = HH ( b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
        a = HH ( a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
        d = HH ( d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
        c = HH ( c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
        b = HH ( b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

        /* Round 4 */
        a = II ( a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
        d = II ( d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
        c = II ( c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
        b = II ( b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
        a = II ( a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
        d = II ( d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
        c = II ( c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
        b = II ( b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
        a = II ( a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
        d = II ( d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
        c = II ( c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
        b = II ( b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
        a = II ( a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
        d = II ( d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
        c = II ( c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
        b = II ( b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

        state[0] += a;
        state[1] += b;
        state[2] += c;
        state[3] += d;
    }

    /**
     * Initialize the MD5 state information and reset the bit count
     * to 0. Given this implementation you are constrained to counting
     * 2^64 bits.
     */
    public void init() {
        count = 0;
        // Load magic initialization constants.
        state[0] = 0x67452301;
        state[1] = 0xefcdab89;
        state[2] = 0x98badcfe;
        state[3] = 0x10325476;
        digestValid = false;
        for (int i = 0; i < digestBits.length; i++)
            digestBits[i] = 0;
    }

    /**
     * update adds the passed type to the input buffer
     */
    public synchronized void update(byte b) {
        int	index;

        index = (int) ((count >>> 3) & 0x3f);
        count += 8;
        buffer[index] = b;
        if (index  >= 63) {
            transform(buffer, 0);
        }
    }

    /**
     * Perform the final computations, any buffered bytes are added
     * to the digest, the count is added to the digest, and the resulting
     * digest is stored. After calling final you will need to call
     * init() again to do another digest.
     */
    public void finish() {
        byte	bits[] = new byte[8];
        byte	padding[];
        int	i, index, padLen;

        for (i = 0; i < 8; i++) {
            bits[i] = (byte)((count >>> (i * 8)) & 0xff);
        }

        index = (int)(count >> 3) & 0x3f;
        padLen = (index < 56) ? (56 - index) : (120 - index);
        padding = new byte[padLen];
        padding[0] = (byte) 0x80;
        update(padding);
        update(bits);

        for (i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
        	digestBits[i*4+j] = (byte)((state[i] >>> (j * 8)) & 0xff);
            }
        }
        digestValid = true;
    }

    public String getAlg() {
	return ("MD5");
    }
}
/*
 * @(#)MessageDigest.java	1.7 95/08/15
 *
 * Copyright (c) 1994 Sun Microsystems, Inc. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for NON-COMMERCIAL purposes and without
 * fee is hereby granted provided that this copyright notice
 * appears in all copies. Please refer to the file "copyright.html"
 * for further important copyright and licensing information.
 *
 * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
 * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR
 * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 *
 * Updated to JDK 1.0.2 levels by Chuck McManis
 * 
 * This file was obtained from: http://www.mcmanis.com/~cmcmanis/java/src/util/crypt/MessageDigest.java
 * More information can be found here: http://www.mcmanis.com/~cmcmanis/java/
 */

package com.ssttr.crypto;

import java.util.*;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
//import java.io.InputStream;
 

/**
 * The MessageDigest class defines a general class for computing digest
 * functions. It is defined as an abstract class that is subclassed by
 * message digest algorithms. In this way the PKCS classes can be built
 * to take a MessageDigest object without needing to know what 'kind'
 * of message digest they are computing.
 *
 * This class defines the standard functions that all message digest
 * algorithms share, and ways to put all Java fundamental types into
 * the digest. It does not define methods for digestifying either
 * arbitrary objects or arrays of objects however.
 *
 * @version 	5 Oct 1996, 1.8
 * @author 	Chuck McManis
 */
public abstract class MessageDigest
{

    /** the actual digest bits. */
    public byte digestBits[];

    /** status of the digest */
    public boolean digestValid;

    /**
     * This function is used to initialize any internal digest
     * variables or parameters.
     */
    public abstract void init();

    /**
     * The basic unit of digestifying is the byte. This method is
     * defined by the particular algorithim's subclass for that
     * algorithim. Subsequent versions of this method defined here
     * decompose the basic type into bytes and call this function.
     * If special processing is needed for a particular type your
     * subclass should override the method for that type.
     */
    public abstract void update(byte aValue);

    /**
     * Add a short value to the digest.
     */
    public synchronized void update(short aValue) {
        byte	b1, b2;

        b1 = (byte)((aValue >>> 8) & 0xff);
        b2 = (byte)(aValue & 0xff);
        update(b1);
        update(b2);
    }

    /**
     * Add an integer value to the digest.
     */
    public synchronized void update(int aValue) {
        byte	b;

        for (int i = 3; i >= 0; i--) {
            b = (byte)((aValue >>> (i * 8)) & 0xff);
            update(b);
        }
    }

    /**
     * Add a long to the digest.
     */
    public synchronized void update(long aValue) {
        byte	b;

    	for (int i = 7; i >= 0; i--) {
    	    b = (byte)((aValue >>> (i * 8)) & 0xff);
    	    update(b);
    	}
    }

    /**
     * Add specific bytes to the digest.
     */
    public synchronized void update(byte input[], int offset, int len) {
        for (int i = 0; i < len; i++) {
            update(input[i+offset]);
        }
    }

    /**
     * Add an array of bytes to the digest.
     */
    public synchronized void update(byte input[]) {
        update(input, 0, input.length);
    }

    /**
     * Add the bytes in the String 'input' to the current digest.
     * Note that the string characters are treated as unicode chars
     * of 16 bits each. To digestify ISO-Latin1 strings (ASCII) use
     * the updateASCII() method.
     */
    public void update(String input) {
    	int	i, len;
    	short	x;

    	len = input.length();
    	for (i = 0; i < len; i++) {
    	    x = (short) input.charAt(i);
    	    update(x);
    	}
    }

    /**
     * Treat the string as a sequence of ISO-Latin1 (8 bit) characters.
     */
    public void updateASCII(String input) {
    	int	i, len;
    	byte	x;

    	len = input.length();
    	for (i = 0; i < len; i++) {
    	    x = (byte) (input.charAt(i) & 0xff);
    	    update(x);
    	}
    }

    /**
     * Perform the final computations and cleanup.
     */
    public abstract void finish();

  
    /**
     * Return a string representation of this object.
    public String toString() {
    	ByteArrayOutputStream ou = new ByteArrayOutputStream();
    	PrintStream p = new PrintStream(ou);

    	p.print(this.getClass().getName()+" Message Digest ");
    	if (digestValid) {
    	    p.print("<");
    	    for(int i = 0; i < digestBits.length; i++)
     	        hexDigit(p, digestBits[i]);
    	    p.print(">");
    	} else {
    	    p.print("<incomplete>");
    	}
    	p.println();
    	return (ou.toString());
    }
     */
    
    public byte[] getDigestBits(){
        return (digestValid)? digestBits:null;
    }
    
    public String getDigestHex()
    {
        if (!digestValid) return null;
        StringBuffer out=new StringBuffer();
        
        for(int i = 0; i < digestBits.length; i++) {
            char c;
            
            c = (char) ((digestBits[i] >> 4) & 0xf);
            if (c > 9)   c = (char) ((c - 10) + 'a');
            else  c = (char) (c + '0');
            out.append(c);
            c = (char) (digestBits[i] & 0xf);
            if (c > 9)
                c = (char)((c-10) + 'a');
            else
                c = (char)(c + '0');
            out.append(c);
        }
        
    	return out.toString();
    }


    /**
     * Return a string that represents the algorithim of this
     * message digest.
     */
    public abstract String getAlg();

    static byte testdata[];


}
/*
 * SHA1.java - An implementation of the SHA-1 Algorithm
 *
 * This version by Chuck McManis (cmcmanis@netcom.com) and
 * still public domain.
 *
 * Based on the C code that Steve Reid wrote his header
 * was :
 *      SHA-1 in C
 *      By Steve Reid <steve@edmweb.com>
 *      100% Public Domain
 *
 *      Test Vectors (from FIPS PUB 180-1)
 *      "abc"
 *      A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
 *      "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
 *      84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
 *      A million repetitions of "a"
 *      34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
 * 
 * This file was obtained from: http://www.mcmanis.com/~cmcmanis/java/src/util/crypt/SHA1.java
 * More information can be found here: http://www.mcmanis.com/~cmcmanis/java/
 */

package com.ssttr.crypto;

/**
 * This is a simple port of Steve Reid's SHA-1 code into Java.
 * I've run his test vectors through the code and they all pass.
 *
 */
public final class SHA1 extends MessageDigest {
    private int state[] = new int[5];
    private long count;


    public SHA1() {
        state = new int[5];
        count = 0;
        if (block == null)
            block = new int[16];
        digestBits = new byte[20];
        digestValid = false;
    }

    /*
     * The following array forms the basis for the transform
     * buffer. Update puts bytes into this buffer and then
     * transform adds it into the state of the digest.
     */
    private int block[] = new int[16];
    private int blockIndex;

    /*
     * These functions are taken out of #defines in Steve's
     * code. Java doesn't have a preprocessor so the first
     * step is to just promote them to real methods.
     * Later we can optimize them out into inline code,
     * note that by making them final some compilers will
     * inline them when given the -O flag.
     */
    final int rol(int value, int bits) {
        int q = (value << bits) | (value >>> (32 - bits));
        return q;
    }

    final int blk0(int i) {
        block[i] = (rol(block[i],24)&0xFF00FF00) | (rol(block[i],8)&0x00FF00FF);
        return block[i];
    }

    final int blk(int i) {
        block[i&15] = rol(block[(i+13)&15]^block[(i+8)&15]^
                          block[(i+2)&15]^block[i&15], 1);
        return (block[i&15]);
    }

    final void R0(int data[], int v, int w, int x , int y, int z, int i) {
        data[z] += ((data[w] & (data[x] ^ data[y] )) ^ data[y]) +
                                blk0(i) + 0x5A827999 + rol(data[v] ,5);
        data[w] = rol(data[w], 30);
    }

    final void R1(int data[], int v, int w, int x, int y, int z, int i) {
        data[z] += ((data[w] & (data[x] ^ data[y])) ^ data[y]) +
                                blk(i) + 0x5A827999 + rol(data[v] ,5);
        data[w] = rol(data[w], 30);
    }

    final void R2(int data[], int v, int w, int x, int y, int z, int i) {
        data[z] += (data[w] ^ data[x] ^ data[y]) +
                                blk(i) + 0x6ED9EBA1 + rol(data[v] ,5);
        data[w] = rol(data[w], 30);
    }

    final void R3(int data[], int v, int w, int x, int y, int z, int i) {
        data[z] += (((data[w] | data[x]) & data[y]) | (data[w] & data[x])) +
                                blk(i) + 0x8F1BBCDC + rol(data[v] ,5);
        data[w] = rol(data[w], 30);
    }

    final void R4(int data[], int v, int w, int x, int y, int z, int i) {
        data[z] += (data[w] ^ data[x] ^ data[y]) +
                                blk(i) + 0xCA62C1D6 + rol(data[v] ,5);
        data[w] = rol(data[w], 30);
    }


    /*
     * Steve's original code and comments :
     *
     * blk0() and blk() perform the initial expand.
     * I got the idea of expanding during the round function from SSLeay
     *
     * #define blk0(i) block->l[i]
     * #define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
     *   ^block->l[(i+2)&15]^block->l[i&15],1))
     *
     * (R0+R1), R2, R3, R4 are the different operations used in SHA1
     * #define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
     * #define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
     * #define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
     * #define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
     * #define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
     */

    int dd[] = new int[5];

    /**
     * Hash a single 512-bit block. This is the core of the algorithm.
     *
     * Note that working with arrays is very inefficent in Java as it
     * does a class cast check each time you store into the array.
     *
     */

    void transform() {

        /* Copy context->state[] to working vars */
        dd[0] = state[0];
        dd[1] = state[1];
        dd[2] = state[2];
        dd[3] = state[3];
        dd[4] = state[4];
        /* 4 rounds of 20 operations each. Loop unrolled. */
        R0(dd,0,1,2,3,4, 0); R0(dd,4,0,1,2,3, 1); R0(dd,3,4,0,1,2, 2); R0(dd,2,3,4,0,1, 3);
        R0(dd,1,2,3,4,0, 4); R0(dd,0,1,2,3,4, 5); R0(dd,4,0,1,2,3, 6); R0(dd,3,4,0,1,2, 7);
        R0(dd,2,3,4,0,1, 8); R0(dd,1,2,3,4,0, 9); R0(dd,0,1,2,3,4,10); R0(dd,4,0,1,2,3,11);
        R0(dd,3,4,0,1,2,12); R0(dd,2,3,4,0,1,13); R0(dd,1,2,3,4,0,14); R0(dd,0,1,2,3,4,15);
        R1(dd,4,0,1,2,3,16); R1(dd,3,4,0,1,2,17); R1(dd,2,3,4,0,1,18); R1(dd,1,2,3,4,0,19);
        R2(dd,0,1,2,3,4,20); R2(dd,4,0,1,2,3,21); R2(dd,3,4,0,1,2,22); R2(dd,2,3,4,0,1,23);
        R2(dd,1,2,3,4,0,24); R2(dd,0,1,2,3,4,25); R2(dd,4,0,1,2,3,26); R2(dd,3,4,0,1,2,27);
        R2(dd,2,3,4,0,1,28); R2(dd,1,2,3,4,0,29); R2(dd,0,1,2,3,4,30); R2(dd,4,0,1,2,3,31);
        R2(dd,3,4,0,1,2,32); R2(dd,2,3,4,0,1,33); R2(dd,1,2,3,4,0,34); R2(dd,0,1,2,3,4,35);
        R2(dd,4,0,1,2,3,36); R2(dd,3,4,0,1,2,37); R2(dd,2,3,4,0,1,38); R2(dd,1,2,3,4,0,39);
        R3(dd,0,1,2,3,4,40); R3(dd,4,0,1,2,3,41); R3(dd,3,4,0,1,2,42); R3(dd,2,3,4,0,1,43);
        R3(dd,1,2,3,4,0,44); R3(dd,0,1,2,3,4,45); R3(dd,4,0,1,2,3,46); R3(dd,3,4,0,1,2,47);
        R3(dd,2,3,4,0,1,48); R3(dd,1,2,3,4,0,49); R3(dd,0,1,2,3,4,50); R3(dd,4,0,1,2,3,51);
        R3(dd,3,4,0,1,2,52); R3(dd,2,3,4,0,1,53); R3(dd,1,2,3,4,0,54); R3(dd,0,1,2,3,4,55);
        R3(dd,4,0,1,2,3,56); R3(dd,3,4,0,1,2,57); R3(dd,2,3,4,0,1,58); R3(dd,1,2,3,4,0,59);
        R4(dd,0,1,2,3,4,60); R4(dd,4,0,1,2,3,61); R4(dd,3,4,0,1,2,62); R4(dd,2,3,4,0,1,63);
        R4(dd,1,2,3,4,0,64); R4(dd,0,1,2,3,4,65); R4(dd,4,0,1,2,3,66); R4(dd,3,4,0,1,2,67);
        R4(dd,2,3,4,0,1,68); R4(dd,1,2,3,4,0,69); R4(dd,0,1,2,3,4,70); R4(dd,4,0,1,2,3,71);
        R4(dd,3,4,0,1,2,72); R4(dd,2,3,4,0,1,73); R4(dd,1,2,3,4,0,74); R4(dd,0,1,2,3,4,75);
        R4(dd,4,0,1,2,3,76); R4(dd,3,4,0,1,2,77); R4(dd,2,3,4,0,1,78); R4(dd,1,2,3,4,0,79);
        /* Add the working vars back into context.state[] */
        state[0] += dd[0];
        state[1] += dd[1];
        state[2] += dd[2];
        state[3] += dd[3];
        state[4] += dd[4];
    }


    /**
     *
     * SHA1Init - Initialize new context
     */
    public void init() {
        /* SHA1 initialization constants */
        state[0] = 0x67452301;
        state[1] = 0xEFCDAB89;
        state[2] = 0x98BADCFE;
        state[3] = 0x10325476;
        state[4] = 0xC3D2E1F0;
        count = 0;
        digestBits = new byte[20];
        digestValid = false;
        blockIndex = 0;
    }

    /**
     * Add one byte to the digest. When this is implemented
     * all of the abstract class methods end up calling
     * this method for types other than bytes.
     */
    public synchronized void update(byte b) {
        int mask = (8 * (blockIndex & 3));

        count += 8;
        block[blockIndex >> 2] &= ~(0xff << mask);
        block[blockIndex >> 2] |= (b & 0xff) << mask;
        blockIndex++;
        if (blockIndex == 64) {
            transform();
            blockIndex = 0;
        }
    }
    /**
     * Add an array of bytes to the digest.
     */
    public synchronized void update(byte input[]) {
        update(input, 0, input.length);
    }

    /* 
    public synchronized void update(byte input[], int offset, int len) {
        for (int i = 0; i < len; i++) {
            update(input[i+offset]);
        }
    }*/

    /**
     * Complete processing on the message digest.
     */
    public void finish() {
        byte bits[] = new byte[8];
        int i;

        for (i = 0; i < 8; i++) {
            bits[i] = (byte)((count >>> (((7 - i) * 8))) & 0xff);
        }

        update((byte) 128);
        while (blockIndex != 56)
            update((byte) 0);
        // This should cause a transform to happen.
        update(bits);
        for (i = 0; i < 20; i++) {
            digestBits[i] = (byte)
                ((state[i>>2] >> ((3-(i & 3)) * 8) ) & 0xff);
        }
        digestValid = true;
    }

    /** Return a string that identifies this algorithm */
    public String getAlg() { return "SHA1"; }

    /**
     * Print out the digest in a form that can be easily compared
     * to the test vectors.
     */
    /*
    private String digout() {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 20; i++) {
            char c1, c2;

            c1 = (char) ((digestBits[i] >>> 4) & 0xf);
            c2 = (char) (digestBits[i] & 0xf);
            c1 = (char) ((c1 > 9) ? 'A' + (c1 - 10) : '0' + c1);
            c2 = (char) ((c2 > 9) ? 'A' + (c2 - 10) : '0' + c2);
            sb.append(c1);
            sb.append(c2);
            if (((i+1) % 4) == 0)
                sb.append(' ');
        }
        return sb.toString();
    }
   */

    /**
     * This is a test program for the SHA1 algorithm. It puts
     * the three test vectors through the algorithm and prints
     * out the results (they should match.) Then it runs the
     * MessageDigest benchmark method to see how fast it is.
     * on my P133 its about 110 - 120K bytes/second.
     *
     * It then compares it to MD5, which is about 150K bytes/second.
     *
     * The reference to MoreOutputStream can be deleted. This is a
     * small class that opens a window to display the results. This
     * works around Symantec Cafe's tendency to shut down the DOS
     * window after showing the output, and the inability to scroll
     * back in a DOS window.
     */

/*
    public static void main(String args[]) {
        int i, j;
        SHA1 s = new SHA1();
        // This line may be safely deleted, its to make it easy to see
        // the output of the program.
        System.out = new java.io.PrintStream(new util.MoreOutputStream());


        System.out.println("SHA-1 Test PROGRAM.");
        System.out.println("This code runs the test vectors through the code.");

//      "abc"
//        A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D 

        System.out.println("First test is 'abc'");
        String z = "abc";
        s.init();
        s.update((byte) 'a');
        s.update((byte) 'b');
        s.update((byte) 'c');
        s.finish();
        System.out.println(s.digout());
        System.out.println("A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D");


//      "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
//        84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1 

        System.out.println("Next Test is 'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'");
        z = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
        s.init();
        s.updateASCII(z);
        s.finish();
        System.out.println(s.digout());
        System.out.println("84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1");

//      A million repetitions of "a"
//        34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F 

        System.out.println("Last test is 1 million 'a' characters.");
        s.init();
        for (i = 0; i < 1000000; i++)
            s.update((byte) 'a');
        s.finish();
        System.out.println(s.digout());
        System.out.println("34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F");
        MessageDigest.benchmark(s);
        MD5 mm = new MD5();
        MessageDigest.benchmark(mm);
    }
*/
    
}
/*
 * AppendNick.java
 *
 * Created on 14 Сентябрь 2005 г., 23:32
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;

import locale.SR;
import ui.*;
import Client.*;
import java.util.*;
import javax.microedition.lcdui.*;

/**
 *
 * @author EvgS
 */
public class AppendNick         
        extends VirtualList 
        implements CommandListener{

    Vector nicknames;
    
    Command cmdSelect=new Command(SR.MS_APPEND, Command.OK, 1);
    Command cmdCancel=new Command(SR.MS_CANCEL, Command.BACK, 99);
    
    /** Creates a new instance of AccountPicker */
    public AppendNick(Display display, Contact to) {
        super(display);
        //this.display=display;
        
        setTitleItem(new Title(SR.MS_SELECT_NICKNAME));
        
        nicknames=new Vector();
        for (Enumeration e=StaticData.getInstance().roster.getHContacts().elements(); e.hasMoreElements(); ) {
            Contact c=(Contact)e.nextElement();
            if (c.inGroup(to.getGroup()) && c.origin>Contact.ORIGIN_GROUPCHAT)
                nicknames.addElement(c);
        }

        addCommand(cmdSelect);
        addCommand(cmdCancel);
        
        setCommandListener(this);
    }
    
    public VirtualElement getItemRef(int Index) { return (VirtualElement)nicknames.elementAt(Index); }
    protected int getItemCount() { return nicknames.size();  }

    public void commandAction(Command c, Displayable d){
        if (c==cmdCancel) {
            destroyView();
            //Account.launchAccount();
            //StaticData.getInstance().account_index=0;
        }
        if (c==cmdSelect) eventOk();
        
    }
    public void eventOk(){
        TextBox t=(TextBox)parentView;

        try {
            String nick=((Contact)getFocusedObject()).getJid();
            int rp=nick.indexOf('/');
            StringBuffer b=new StringBuffer(nick.substring(rp+1));
            
            if (t.size()>0) {
                b.insert(0, (char)0x20);
                b.insert(0, t.getString());
		b.append(' ');
            } else {
                b.append(": ");
            }
            t.setString(b.toString());
        } catch (Exception e) {}
        
        destroyView();
    }

}
/*
 * BookmarkItem.java
 *
 * Created on 17 Сентябрь 2005 г., 23:21
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;
import Client.StaticData;
import com.alsutton.jabber.JabberDataBlock;
import images.RosterIcons;
import ui.*;

/**
 *
 * @author EvgS
 */
public class BookmarkItem extends IconTextElement{
    
    String name;
    String jid;
    String nick;
    String password;
    boolean autojoin;
    boolean isUrl;
    
    public int getImageIndex(){ return (isUrl)? RosterIcons.ICON_PRIVACY_ACTIVE: RosterIcons.ICON_GCJOIN_INDEX; }
    public String toString(){ return jid+'/'+nick; }
    public String getJid() { return jid; }

    public int getColor(){ return Colors.LIST_INK;}
    
    /** Creates a new instance of BookmarkItem */
    public BookmarkItem() {
        super(RosterIcons.getInstance());
    }
    
    public BookmarkItem(JabberDataBlock data) {
        this();
        isUrl=!data.getTagName().equals("conference");
        name=data.getAttribute("name");
        try {
            autojoin=data.getAttribute("autojoin").equals("true");
        } catch (Exception e) {}
        jid=data.getAttribute((isUrl)?"url":"jid");
        nick=data.getChildBlockText("nick");
        password=data.getChildBlockText("password");
    }
    
    public BookmarkItem(String jid, String nick, String password){
        this();
        this.name=this.jid=jid;
        this.nick=nick;
        this.password=password;
    }
    
    public JabberDataBlock constructBlock() {
        JabberDataBlock data=new JabberDataBlock((isUrl)?"url":"conference", null, null);
        data.setAttribute("name", name);
        data.setAttribute((isUrl)?"url":"jid", jid);
        if (autojoin) data.setAttribute("autojoin", "true");
        if (nick.length()>0) data.addChild("nick",nick);
        if (password.length()>0) data.addChild("password",password);
        
        return data;
    }
}
/*
 * Bookmarks.java
 *
 * Created on 18 Сентябрь 2005 пїЅ., 0:03
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;
import Client.*;
import ServiceDiscovery.ServiceDiscovery;
import images.RosterIcons;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.*;
import java.util.*;
import com.alsutton.jabber.*;
import com.alsutton.jabber.datablocks.Iq;

/**
 *
 * @author EvgS
 */
public class Bookmarks 
        extends VirtualList 
        implements CommandListener,
        JabberBlockListener
{
    
    private Vector bookmarks;
    
    private BookmarkItem toAdd;
    
    private Command cmdCancel=new Command (SR.MS_CANCEL, Command.BACK, 99);
    private Command cmdJoin=new Command (SR.MS_JOIN, Command.SCREEN, 10);
    private Command cmdDisco=new Command (SR.MS_DISCO_ROOM, Command.SCREEN, 15);
    private Command cmdRfsh=new Command (SR.MS_REFRESH, Command.SCREEN, 20);
    private Command cmdDel=new Command (SR.MS_DELETE, Command.SCREEN, 30);
    
    Roster roster=StaticData.getInstance().roster;

    JabberStream stream=roster.theStream;
    /** Creates a new instance of Bookmarks */
    public Bookmarks(Display display, BookmarkItem toAdd) {
        super (display);
        setTitleItem(new Title(2, null, SR.MS_BOOKMARKS));
        
        this.toAdd=toAdd;
        
        bookmarks=roster.bookmarks;
        if ( bookmarks==null ) loadBookmarks(); 
        else if (toAdd!=null) addBookmark();
        
        addCommand(cmdCancel);
        addCommand(cmdJoin);
        addCommand(cmdRfsh);
        addCommand(cmdDel);
        addCommand(cmdDisco);
        setCommandListener(this);
    }
    
    private void processIcon(boolean processing){
        getTitleItem().setElementAt((processing)?(Object)new Integer(RosterIcons.ICON_PROGRESS_INDEX):(Object)null, 0);
        redraw();
    }
    
    protected int getItemCount() { return (bookmarks==null)?0: bookmarks.size(); }
    protected VirtualElement getItemRef(int index) { return (VirtualElement) bookmarks.elementAt(index); }
    
    public void loadBookmarks() {
        stream.addBlockListener(this);
        JabberDataBlock rq=new JabberDataBlock("storage", null, null);
        rq.setNameSpace("storage:bookmarks");
        bookmarksRq(false, rq, "getbookmarks");
    }
    
    // пока здесь, но вообще-то это storageRq
    public void bookmarksRq(boolean set, JabberDataBlock child, String id) {
        JabberDataBlock request=new Iq(null, (set)?Iq.TYPE_SET: Iq.TYPE_GET, id);
        //request.setAttribute("to", StaticData.getInstance().account.getBareJid());
        JabberDataBlock query=request.addChild("query", null);
        query.setNameSpace("jabber:iq:private");
        query.addChild(child);
        
        processIcon(true);
        //System.out.println(request.toString());
        stream.send(request);
    }
    
    public int blockArrived(JabberDataBlock data) {
        try {
            ///System.out.println(data.toString());
            
            if (data.getAttribute("id").equals("getbookmarks")) {
                JabberDataBlock storage=data.findNamespace("jabber:iq:private").
                        findNamespace("storage:bookmarks");
                Vector bookmarks=new Vector();
                try {
                    for (Enumeration e=storage.getChildBlocks().elements(); e.hasMoreElements(); ){
                        bookmarks.addElement(new BookmarkItem((JabberDataBlock)e.nextElement()));
                    }
                } catch (Exception e) { /* no any bookmarks */}
                //StaticData.getInstance().roster.bookmarks=
                this.bookmarks=bookmarks;
                
                addBookmark();
                
                if (display!=null) redraw();
                roster.bookmarks=this.bookmarks=bookmarks;
                
                processIcon(false);
                return JabberBlockListener.NO_MORE_BLOCKS;
            }
        } catch (Exception e) { }
        return JabberBlockListener.BLOCK_REJECTED;
    }

    private void addBookmark() {
        if (toAdd!=null) {
            this.bookmarks.addElement(toAdd);
            saveBookmarks();
        }
    }
    
    public void eventOk(){
        BookmarkItem join=(BookmarkItem)getFocusedObject();
        if (join==null) return;
        if (join.isUrl) return;
        ConferenceForm.join(join.toString(), join.password, 20);
        stream.cancelBlockListener(this);
        display.setCurrent(StaticData.getInstance().roster);
    }
    
    public void commandAction(Command c, Displayable d){
        if (c==cmdCancel) exitBookmarks();
        if (c==cmdJoin) eventOk();
        if (c==cmdRfsh) loadBookmarks();
        if (c==cmdDel) deleteBookmark();
        if (c==cmdDisco) new ServiceDiscovery(display, ((BookmarkItem)getFocusedObject()).getJid(), null);
    }
    
    private void deleteBookmark(){
        BookmarkItem del=(BookmarkItem)getFocusedObject();
        if (del==null) return;
        if (del.isUrl) return;
        bookmarks.removeElement(del);
        saveBookmarks();
        roster.bookmarks=this.bookmarks=bookmarks;
        redraw();
    }
    
    private void saveBookmarks() {
        JabberDataBlock rq=new JabberDataBlock("storage", null, null);
        rq.setNameSpace("storage:bookmarks");
        for (Enumeration e=bookmarks.elements(); e.hasMoreElements(); ) {
            rq.addChild( ((BookmarkItem)e.nextElement()).constructBlock() );
        }
        bookmarksRq(true, rq, "getbookmarks");
    }

    private void exitBookmarks(){
        stream.cancelBlockListener(this);
        destroyView();
        //display.setCurrent(StaticData.getInstance().roster);
    }
}
/*
 * ConferenceForm.java
 *
 * Created on 24 Июль 2005 г., 18:32
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;
import Client.*;
import com.alsutton.jabber.JabberDataBlock;
import locale.SR;
import ui.*;
import javax.microedition.lcdui.*;
import ui.controls.NumberField;

/**
 *
 * @author EvgS
 */
public class ConferenceForm implements CommandListener{
    
    private Display display;
    private Displayable parentView;
    
    Command cmdJoin=new Command(SR.MS_JOIN, Command.SCREEN, 1);
    Command cmdBookmarks=new Command(SR.MS_BOOKMARKS, Command.SCREEN, 2);
    Command cmdAdd=new Command(SR.MS_ADD_BOOKMARK, Command.SCREEN, 3);
    Command cmdCancel=new Command (SR.MS_CANCEL, Command.BACK, 99);
    
    TextField roomField;
    TextField hostField;
    TextField nickField;
    TextField passField;
    NumberField msgLimitField;
    
    StaticData sd=StaticData.getInstance();
    /** Creates a new instance of GroupChatForm */
    public ConferenceForm(Display display) { this(display, null, null, null, null); }
    /** Creates a new instance of GroupChatForm */
    public ConferenceForm(Display display, String room, String server, String nick, String password) {
        this.display=display;
        parentView=display.getCurrent();
        
        Form formJoin=new Form(SR.MS_JOIN_CONFERENCE);

        if (room==null && server==null) {
            room=Config.getInstance().defGcRoom;
            // trying to split string like room@server
            int roomE=room.indexOf('@');
            if (roomE>0) {
                server=room.substring(roomE+1);
                room=room.substring(0, roomE);
            }
        }
        // default server
        if (server==null) server="conference."+sd.account.getServer();
        
        roomField=new TextField(SR.MS_ROOM, room, 64, TextField.URL);
        formJoin.append(roomField);
        
        hostField=new TextField(SR.MS_AT_HOST, server, 64, TextField.URL);
        formJoin.append(hostField);
        
        if (nick==null) nick=sd.account.getNickName();
        nickField=new TextField(SR.MS_NICKNAME, nick, 32, TextField.ANY);
        formJoin.append(nickField);
        
        passField=new TextField(SR.MS_PASSWORD, password, 32, TextField.ANY | ConstMIDP.TEXTFIELD_SENSITIVE );
        formJoin.append(passField);
        
        msgLimitField=new NumberField(SR.MS_MSG_LIMIT, 20, 0, 20);
        formJoin.append(msgLimitField);
        
        formJoin.addCommand(cmdJoin);
        formJoin.addCommand(cmdBookmarks);
        formJoin.addCommand(cmdAdd);
        
        formJoin.addCommand(cmdCancel);
        formJoin.setCommandListener(this);
        display.setCurrent(formJoin);
    }
    public void commandAction(Command c, Displayable d){
        if (c==cmdCancel) { destroyView(); }
        if (c==cmdBookmarks) { new Bookmarks(display, null); }
        if (c==cmdJoin || c==cmdAdd) {
            String nick=nickField.getString();
            String host=hostField.getString();
            String room=roomField.getString();
            String pass=passField.getString();
            int msgLimit=msgLimitField.getValue();
            
            if (nick.length()==0) return;
            if (room.length()==0) return;
            if (host.length()==0) return;
            StringBuffer gchat=new StringBuffer(room.trim());
            gchat.append('@');
            gchat.append(host.trim());
            //sd.roster.mucContact(gchat.toString(), Contact.ORIGIN_GROUPCHAT);
            if (c==cmdAdd) new Bookmarks(display, new BookmarkItem(gchat.toString(), nick, pass));
            else {
                try {
                    gchat.append('/');
                    gchat.append(nick.trim());
                    join(gchat.toString(),pass, msgLimit);
                    
                    display.setCurrent(sd.roster);
                } catch (Exception e) {
                    e.printStackTrace();
                    display.setCurrent(new Alert("Exception", e.toString(), null, AlertType.ERROR), sd.roster);
                }
            }
        }
    }
    public static void join(String name, String pass, int maxStanzas) {
        StaticData sd=StaticData.getInstance();
        
        
        
        ConferenceGroup grp=sd.roster.initMuc(name, pass);
        // требуется для возможности нормального выхода
        //sd.roster.mucContact(name, Contact.ORIGIN_GC_MYSELF); 
        //sd.roster.activeRooms.addElement(jid);
 
        JabberDataBlock x=new JabberDataBlock("x", null, null);
        x.setNameSpace("http://jabber.org/protocol/muc");
        if (pass.length()!=0) {
            // adding password to presence
            x.addChild("password", pass);
        }
        
        JabberDataBlock history=x.addChild("history", null);
        history.setAttribute("maxstanzas", String.valueOf(maxStanzas));
        history.setAttribute("maxchars","32768");
        try {
            long delay= ( grp.conferenceJoinTime
                              - ( (Msg)(grp.getConference().msgs.lastElement()) ).dateGmt
                        ) /1000 ;
            history.setAttribute("seconds",String.valueOf(delay)); // todo: change to since
        } catch (Exception e) {};

        //sd.roster.groups.getGroup(name.substring(0, name.indexOf('@'))).imageExpandedIndex=ImageList.ICON_GCJOIN_INDEX;
        sd.roster.sendPresence(name, null, x);
        sd.roster.reEnumRoster();
    }
    public void destroyView(){
        if (parentView!=null) display.setCurrent(parentView);
    }
}
/*
 * ConferenceGroup.java
 *
 * Created on 29 Ноябрь 2005 г., 23:11
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;

import Client.Contact;
import Client.Group;
import images.RosterIcons;
import java.util.*;
import ui.ImageList;

/**
 *
 * @author EvgS
 */
public class ConferenceGroup extends Group{
    
    /** Creates a new instance of ConferenceGroup */
    public ConferenceGroup(String name, String label) {
	super(name);
	this.label=label;
	imageExpandedIndex=RosterIcons.ICON_GCJOIN_INDEX;
    }

    String label;
    
    private MucContact selfContact;
    public String password;
    private MucContact conference;
    public String toString(){ return title(label); }

    public MucContact getSelfContact() { return selfContact; }
    public void setSelfContact(MucContact selfContact) { this.selfContact=selfContact; }
    public Contact getConference() { return conference; }
    public void setConference(MucContact conference) { this.conference=conference; }
    // не считаем группу в числе участников
    public int getOnlines(){ return (onlines>0)? onlines-1:0; }
    public int getNContacts(){ return (nContacts>0)? nContacts-1:0; }
    
    public long conferenceJoinTime;
}
/*
 * InviteForm.java
 *
 * Created on 15 Май 2006 г., 20:15
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;

import Client.Contact;
import Client.StaticData;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.datablocks.Message;
import com.alsutton.jabber.datablocks.Presence;
import java.util.Enumeration;
import javax.microedition.lcdui.ChoiceGroup;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.Form;
import javax.microedition.lcdui.TextField;
import locale.SR;
import ui.ConstMIDP;

/**
 *
 * @author root
 */
public class InviteForm implements CommandListener{
    
    private Display display;
    private Displayable parentView;
    
    Form form;
    TextField reason;
    ChoiceGroup conferenceList;
    
    Contact contact;
    
    Command cmdOk=new Command(SR.MS_OK, Command.OK, 1);
    Command cmdCancel=new Command(SR.MS_CANCEL, Command.BACK, 99);
    /** Creates a new instance of InviteForm */
    public InviteForm(Contact contact, Display display) {
        this.display=display;
        this.contact=contact;
        parentView=display.getCurrent();
        
        form=new Form(SR.MS_INVITE);
        reason=new TextField(SR.MS_INVITE_REASON, null, 200, TextField.ANY);
        
        conferenceList=new ChoiceGroup (SR.MS_CONFERENCE, ConstMIDP.CHOICE_POPUP);
        for (Enumeration c=StaticData.getInstance().roster.getHContacts().elements(); c.hasMoreElements(); ) {
            try {
                MucContact mc=(MucContact)c.nextElement();
                if (mc.origin==Contact.ORIGIN_GROUPCHAT && mc.status==Presence.PRESENCE_ONLINE)
                    conferenceList.append(mc.toString(), null);
            } catch (Exception e) {}
        }
        

        form.append(contact.getName());
        form.append("\n");
        form.append(conferenceList);
        form.append(reason);
        
        form.addCommand(cmdOk);
        form.addCommand(cmdCancel);
        form.setCommandListener(this);
        
        display.setCurrent(form);
    }

    public void commandAction(Command c, Displayable d) {
        if (c==cmdOk) {
            String room=conferenceList.getString( conferenceList.getSelectedIndex());
            String rs=reason.getString();
            
            Message inviteMsg=new Message(room);
            JabberDataBlock x=inviteMsg.addChild("x",null);
            x.setNameSpace("http://jabber.org/protocol/muc#user");
            JabberDataBlock invite=x.addChild("invite",null);
            invite.setAttribute("to", contact.getBareJid());
            invite.addChild("reason",rs);
            
            //System.out.println(inviteMsg.toString());
            StaticData.getInstance().roster.theStream.send(inviteMsg);
            display.setCurrent(StaticData.getInstance().roster);
        }
        if (c==cmdCancel) { display.setCurrent(parentView); }
    }
    
}
/*
 * MucContact.java
 *
 * Created on 2 Май 2006 г., 14:05
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;

import Client.Contact;
import Client.StaticData;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.datablocks.Presence;
import images.RosterIcons;
import locale.SR;

/**
 *
 * @author root
 */
public class MucContact extends Contact{
    
    public final static int AFFILIATION_OUTCAST=-1;
    public final static int AFFILIATION_NONE=0;
    public final static int AFFILIATION_MEMBER=1;
    public final static int AFFILIATION_ADMIN=2;
    public final static int AFFILIATION_OWNER=3;
    
    public final static int ROLE_VISITOR=-1;
    public final static int ROLE_PARTICIPANT=0;
    public final static int ROLE_MODERATOR=1;
    
    public String realJid;
    
    public String affiliation;
    public String role;
    
    public int roleCode;
    public int affiliationCode;

    /** Creates a new instance of MucContact */
    public MucContact(String nick, String jid) {
        super(nick, jid, Presence.PRESENCE_OFFLINE, "muc");
        offline_type=Presence.PRESENCE_OFFLINE;
    }
    
    public String processPresence(JabberDataBlock xmuc, Presence presence) {
        //System.out.println(presence);
        String from=jid.getJid();
        
        int presenceType=presence.getTypeIndex();
        
        if (presenceType==Presence.PRESENCE_ERROR) {
            String mucErrCode=presence.getChildBlock("error").getAttribute("code");            
            if (mucErrCode.equals("409")) return "Nickname is already in use by another occupant";
            if (mucErrCode.equals("403")) return "You are banned in this room";
        }
        
        JabberDataBlock item=xmuc.getChildBlock("item");   

        String role=item.getAttribute("role");
        if (role.equals("visitor")) roleCode=ROLE_VISITOR;
        if (role.equals("participant")) roleCode=ROLE_PARTICIPANT;
        if (role.equals("moderator")) roleCode=ROLE_MODERATOR;
        
        String affiliation=item.getAttribute("affiliation");
        if (affiliation.equals("owner")) affiliationCode=AFFILIATION_OWNER;
        if (affiliation.equals("admin")) affiliationCode=AFFILIATION_ADMIN;
        if (affiliation.equals("member")) affiliationCode=AFFILIATION_MEMBER;
        if (affiliation.equals("none")) affiliationCode=AFFILIATION_NONE;
        
        boolean roleChanged= !role.equals(this.role);
        boolean affiliationChanged= !affiliation.equals(this.affiliation);
        this.role=role;
        this.affiliation=affiliation;
        
        String chNick=item.getAttribute("nick");

        setSortKey(nick);
        
        if (role.equals("moderator")) {
            transport=RosterIcons.ICON_MODERATOR_INDEX;
            key0=1;
            //jidHash &= 0x3fffffff;
        } else {
            transport=0;
            key0=2;
            //jidHash |= 0x40000000;
        }


        int rp=from.indexOf('/');
        //String nick=from.substring(rp+1);
        
        JabberDataBlock statusBlock=xmuc.getChildBlock("status");
        int statusCode;
        try { 
            statusCode=Integer.parseInt( statusBlock.getAttribute("code") ); 
        } catch (Exception e) { statusCode=0; }
        

        StringBuffer b=new StringBuffer(nick);
        
        if (presence.getTypeIndex()==Presence.PRESENCE_OFFLINE) {
            String reason=item.getChildBlockText("reason");
            switch (statusCode) {
                
                case 303:
                    b.append(SR.MS_IS_NOW_KNOWN_AS);
                    b.append(chNick);
                    // исправим jid
                    String newJid=from.substring(0,rp+1)+chNick;
                    //System.out.println(newJid);
                    jid.setJid(newJid);
                    bareJid=newJid; // непонятно, зачем я так сделал...
                    from=newJid;
                    nick=chNick;
                    break;
                    
                case 307: //kick
                case 301: //ban
                    b.append(
                            (statusCode==301)? SR.MS_WAS_BANNED : SR.MS_WAS_KICKED );
                    b.append("(");
                    b.append(reason);
                    b.append(")");
                    testMeKicked();
                    break;
            
                case 322:
                    b.append(SR.MS_HAS_BEEN_KICKED_BECAUSE_ROOM_BECAME_MEMBERS_ONLY);
                    testMeKicked();
                    break;
                    
                default:
                b.append(SR.MS_HAS_LEFT_CHANNEL);
            } 
                
        } else {
            if (this.status==Presence.PRESENCE_OFFLINE) {
                String realJid=item.getAttribute("jid");
                if (realJid!=null) {
                    b.append(" (");
                    b.append(realJid);
                    b.append(')');
                    this.realJid=realJid;  //for moderating purposes
                }
                b.append(SR.MS_HAS_JOINED_THE_CHANNEL_AS);
                b.append(role);
                if (!affiliation.equals("none")) {
                    b.append(SR.MS_AND);
                    b.append(affiliation);
//toon
                    //b.append(" with status ");
                    //b.append(pr.getPresenceTxt());
                    
                }
            } else {
                b.append(SR.MS_IS_NOW);
                if ( roleChanged ) b.append(role);
                if (affiliationChanged) {
                    if (roleChanged) b.append(" and ");
                    
                    b.append(affiliation.equals("none")? "unaffiliated" : affiliation);
                }
                if (!roleChanged && !affiliationChanged)
                    b.append(presence.getPresenceTxt());
            }
//toon
        }
        
        
        return b.toString();
    }
    
    public String getTipString() {
        StringBuffer tip=new StringBuffer();
        int nm=getNewMsgsCount();
        if (nm!=0) {
            tip.append(nm);
            tip.append(' ');
        }
        if (realJid!=null) tip.append(realJid);
        
        return (tip.length()==0)? null:tip.toString();
    }
    
    void testMeKicked(){
        ConferenceGroup group=(ConferenceGroup)getGroup();
        if ( group.getSelfContact() == this ) 
            StaticData.getInstance().roster.leaveRoom(0,getGroup());
    }
}
/*
 * QueryConfigForm.java
 *
 * Created on 11 Октябрь 2005 г., 0:35
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference;

import Client.StaticData;
import ServiceDiscovery.DiscoForm;
import com.alsutton.jabber.JabberBlockListener;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.datablocks.Iq;
import com.alsutton.jabber.JabberStream;
import javax.microedition.lcdui.Display;

/**
 *
 * @author EvgS
 */
public class QueryConfigForm implements JabberBlockListener{
    
    private final static String OWNER_XMLNS="http://jabber.org/protocol/muc#owner";
    private Display display;
    /** Creates a new instance of QueryConfigForm */
    public QueryConfigForm(Display display, String roomJid) {
        JabberDataBlock getform=new Iq(roomJid, Iq.TYPE_GET, "confform");
        getform.addChild("query", null).setNameSpace(OWNER_XMLNS);
        
        JabberStream stream=StaticData.getInstance().roster.theStream;
        stream.addBlockListener(this);
        stream.send(getform);
        StaticData.getInstance().roster.setQuerySign(true);
        this.display=display;
    }
    
    public int blockArrived(JabberDataBlock data) {
        JabberDataBlock query=data.findNamespace(OWNER_XMLNS);
        if (query!=null) {
            StaticData.getInstance().roster.setQuerySign(false);
            if (data.getTypeAttribute().equals("result")) {
                new DiscoForm(display, data, StaticData.getInstance().roster.theStream, "muc_owner", "query");
            }
            return JabberBlockListener.NO_MORE_BLOCKS;
        }
        return JabberBlockListener.BLOCK_REJECTED;
    }
}
/*
 * AffiliationItem.java
 *
 * Created on 30 Октябрь 2005 г., 11:53
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference.affiliation;

import Client.StaticData;
import com.alsutton.jabber.JabberDataBlock;
import images.RosterIcons;
import ui.Colors;
import ui.IconTextElement;
import ui.ImageList;

/**
 *
 * @author EvgS
 */
public class AffiliationItem extends IconTextElement{
    public final static int AFFILIATION_NONE=0;
    public final static int AFFILIATION_OWNER=1;
    public final static int AFFILIATION_ADMIN=2;
    public final static int AFFILIATION_MEMBER=3;
    public final static int AFFILIATION_OUTCAST=4;
    
    public static String getAffiliationName(int index){
        switch (index) {
            case AFFILIATION_OWNER: return "owner";
            case AFFILIATION_ADMIN: return "admin";
            case AFFILIATION_MEMBER: return "member";
            case AFFILIATION_OUTCAST: return "outcast";
        }
        return "none";
    };
    
    public int getImageIndex(){ 
        switch (affiliation) {
            case AFFILIATION_OWNER: return RosterIcons.ICON_REGISTER_INDEX;
            case AFFILIATION_ADMIN: return RosterIcons.ICON_MODERATOR_INDEX;
            case AFFILIATION_MEMBER: return 0;
            case AFFILIATION_OUTCAST: return RosterIcons.ICON_ERROR_INDEX;
        }
        return RosterIcons.ICON_INVISIBLE_INDEX; 
    }

    public String jid;
    public int affiliation;
        
    /** Creates a new instance of AffiliationItem */
    public AffiliationItem(String jid, String affiliation) {
        super(RosterIcons.getInstance());
        this.jid=jid;
        for (int index=1; index<5; index++) {
            if (affiliation.equals(getAffiliationName(index))) this.affiliation=index;
        }
    }
    
    public AffiliationItem(JabberDataBlock item) {
        this(item.getAttribute("jid"), item.getAttribute("affiliation"));
    }
    
    
    public int getColor() { return Colors.LIST_INK; }
    
    public String toString() { return jid; }
}
/*
 * AffiliationModify.java
 *
 * Created on 30 Октябрь 2005 г., 15:32
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference.affiliation;

import Client.StaticData;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.JabberStream;
import com.alsutton.jabber.datablocks.Iq;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.YesNoAlert;

/**
 *
 * @author EvgS
 */
public class AffiliationModify implements CommandListener{
    
    Display display;
    Displayable parentView;
    
    Form f=new Form("Affiliation");
    TextField jid;
    ChoiceGroup affiliation;
    
    String room;
    int recentAffiliation;
    
    Command cmdCancel=new Command(SR.MS_CANCEL, Command.BACK, 99);
    Command cmdOk=new Command(SR.MS_SET, Command.OK, 1);
    
    /** Creates a new instance of AffiliationModify */
    public AffiliationModify(Display display, String room, String jid, String affiliation) {
        this.display=display;
        parentView=display.getCurrent();
        
        this.room=room;
        this.jid=new TextField(SR.MS_JID /*"Jid"*/ , jid, 80, TextField.URL);
        f.append(this.jid);
        
        this.affiliation=new ChoiceGroup(SR.MS_SET_AFFILIATION /*"Set affiliation to"*/, ui.ConstMIDP.CHOICE_POPUP);
        for (int index=0; index<=AffiliationItem.AFFILIATION_OUTCAST; index++) {
            String name=AffiliationItem.getAffiliationName(index);
            this.affiliation.append(name, null);
            if (affiliation.equals(name)) recentAffiliation=index;
        }
        this.affiliation.setSelectedIndex(recentAffiliation, true);
        f.append(this.affiliation);
        
        f.addCommand(cmdCancel);
        f.addCommand(cmdOk);
        f.setCommandListener(this);
        display.setCurrent(f);
    }
    
    
    private void modify(){
        JabberStream stream=StaticData.getInstance().roster.theStream;
        
        JabberDataBlock request=new Iq(room, Iq.TYPE_SET, "admin_modify");
        JabberDataBlock query=request.addChild("query", null);
        query.setNameSpace("http://jabber.org/protocol/muc#admin");
        JabberDataBlock child=query.addChild("item", null);
        child.setAttribute("jid", jid.getString());
        child.setAttribute("affiliation", AffiliationItem.getAffiliationName(affiliation.getSelectedIndex()));
        
        
        //processIcon(true);
        //System.out.println(request.toString());
        //stream.addBlockListener(this);
        stream.send(request);
        try {
            Affiliations a=(Affiliations) parentView;
            a.getList();
        } catch (Exception e) {};
        destroyView();
    }
    
    public void commandAction(Command c, Displayable d) {
        if (c==cmdOk) {
            if (jid.size()==0) return;
            if (recentAffiliation==AffiliationItem.AFFILIATION_OWNER) {
                StringBuffer warn=new StringBuffer(SR.MS_ARE_YOU_SURE_WANT_TO_DISCARD /*"Are You sure want to discard "*/);
                warn.append(jid.getString());
                warn.append(SR.MS_FROM_OWNER_TO/*" from OWNER to "*/);
                warn.append(AffiliationItem.getAffiliationName(affiliation.getSelectedIndex()));
                new YesNoAlert(display, parentView, SR.MS_MODIFY_AFFILIATION/*"Modify affiliation"*/, warn.toString()) {
                    public void yes() {
                        modify();
                    }
                };
            } else modify();
        }
        if (c==cmdCancel) { destroyView(); }
    }
    
    private void destroyView() { display.setCurrent(parentView); }
}
/*
 * AffiliationList.java
 *
 * Created on 30 Октябрь 2005 г., 12:34
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Conference.affiliation;

import Client.*;
import com.alsutton.jabber.JabberBlockListener;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.JabberStream;
import com.alsutton.jabber.datablocks.Iq;
import images.RosterIcons;
import java.util.Enumeration;
import java.util.Vector;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.ImageList;
import ui.VirtualElement;
import ui.VirtualList;

/**
 *
 * @author EvgS
 */
public class Affiliations 
        extends VirtualList 
        implements CommandListener,
        JabberBlockListener
{

    private Vector items;
    private String id="admin";
    private String namespace="http://jabber.org/protocol/muc#admin";
    private String room;

    private JabberStream stream=StaticData.getInstance().roster.theStream;
    
    private Command cmdCancel=new Command (SR.MS_BACK, Command.BACK, 99);
    private Command cmdModify=new Command (SR.MS_MODIFY, Command.SCREEN, 1);
    private Command cmdNew=new Command (SR.MS_NEW_JID, Command.SCREEN, 2);
 
    
    protected VirtualElement getItemRef(int index) { return (VirtualElement) items.elementAt(index); }
    protected int getItemCount() { return items.size(); }
    
    
    
    /** Creates a new instance of AffiliationList */
    public Affiliations(Display display, String room, int affiliationIndex) {
        super (display);
        this.room=room;
	
	//fix for old muc
	switch (affiliationIndex) {
	    case AffiliationItem.AFFILIATION_OWNER:
	    case AffiliationItem.AFFILIATION_ADMIN:
		if (!Config.getInstance().muc119) namespace="http://jabber.org/protocol/muc#owner";
	}
	
        this.id=AffiliationItem.getAffiliationName(affiliationIndex);
        
        setTitleItem(new Title(2, null, id));
        items=new Vector();
        
        addCommand(cmdCancel);
        addCommand(cmdModify);
        addCommand(cmdNew);
        
        setCommandListener(this);
        getList();
    }
    
    public void getList() {
        JabberDataBlock item=new JabberDataBlock("item", null, null);
        item.setAttribute("affiliation", id);
        listRq(false, item, id);
    }
    
    public void commandAction(Command c, Displayable d){
        if (c==cmdNew) new AffiliationModify(display, room, null, "none");
        if (c==cmdModify) eventOk();
        if (c!=cmdCancel) return;
        stream.cancelBlockListener(this);
        destroyView();
    }
    
    public void eventOk(){
        try {
            AffiliationItem item=(AffiliationItem)getFocusedObject();
            new AffiliationModify(display, room, item.jid, 
                    AffiliationItem.getAffiliationName(item.affiliation));
        } catch (Exception e) { }
    }
    
    private void processIcon(boolean processing){
        getTitleItem().setElementAt((processing)?(Object)new Integer(RosterIcons.ICON_PROGRESS_INDEX):(Object)null, 0);
        redraw();
    }
    
    public int blockArrived(JabberDataBlock data) {
        try {
            ///System.out.println(data.toString());
            
            if (data.getAttribute("id").equals(id)) {
                JabberDataBlock query=data.findNamespace(namespace);
                Vector items=new Vector();
                try {
                    for (Enumeration e=query.getChildBlocks().elements(); e.hasMoreElements(); ){
                        items.addElement(new AffiliationItem((JabberDataBlock)e.nextElement()));
                    }
                } catch (Exception e) { /* no any items */}
                //StaticData.getInstance().roster.bookmarks=
                this.items=items;
                
                if (display!=null) redraw();
                
                processIcon(false);
                return JabberBlockListener.NO_MORE_BLOCKS;
            }
        } catch (Exception e) { }
        return JabberBlockListener.BLOCK_REJECTED;
    }
    
    public void listRq(boolean set, JabberDataBlock child, String id) {
        
        JabberDataBlock request=new Iq(room, (set)? Iq.TYPE_SET: Iq.TYPE_GET, id);
        JabberDataBlock query=request.addChild("query", null);
        query.setNameSpace(namespace);
        query.addChild(child);
        
        processIcon(true);
        //System.out.println(request.toString());
        stream.addBlockListener(this);
        stream.send(request);
    }
}
/*
 * RosterIcons.java
 *
 * Created on 3 Декабрь 2005 г., 20:02
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package images;

import java.util.Hashtable;
import java.util.Vector;
import javax.microedition.lcdui.Graphics;
import ui.ImageList;
import util.StringLoader;

/**
 *
 * @author EvgS
 */
public class RosterIcons extends ImageList{
    
    private static RosterIcons instance;

    public static RosterIcons getInstance() {
	if (instance==null) instance=new RosterIcons();
	return instance;
    }

    private final static int ICONS_IN_ROW=8;
    private final static int ICONS_IN_COL=6;
    
    private Hashtable transports;
    private Vector transpSkins;
    
    /** Creates a new instance of RosterIcons */
    private RosterIcons() {
	super("/images/skin.png", ICONS_IN_COL, ICONS_IN_ROW);
        
        transports=new StringLoader().hashtableLoader("/images/transports.txt"); //new Hashtable();
        transpSkins=new Vector(transports.size());
        
        transports.put("conference", new Integer(ICON_GROUPCHAT_INDEX));
        
    }
    
    public int getTransportIndex(String name){
        Object o=transports.get(name);
        if (o instanceof String) {
            int index=(transpSkins.size()+1)<<24;
            // loading additional skin
            ImageList customTransp=new ImageList((String) o, 1, ICONS_IN_ROW);
            // customTransp loading success?
            if (customTransp.getHeight()==0) customTransp=this;
            
            transpSkins.addElement( customTransp );
            transports.put(name, new Integer(index) );
            
            return index;
        } else {
            return (o==null)?0:((Integer)o).intValue();
        }
        //if (resource) if (index==6) index=0;
    }
    

    public void drawImage(Graphics g, int index, int x, int y) {
        if (index>0x0ffffff) 
            ((ImageList)transpSkins.elementAt( (index>>24) -1 )).drawImage(g, index & 0xff, x, y);
        else super.drawImage(g, index, x, y);
    }

    public static final int ICON_INVISIBLE_INDEX = 0x10;

    public static final int ICON_ERROR_INDEX = 0x11;

    public static final int ICON_TRASHCAN_INDEX = 0x12;

    public static final int ICON_PROGRESS_INDEX = 0x13;

    public static final int ICON_MODERATOR_INDEX = 0x50;

    public static final int ICON_PRIVACY_ACTIVE = 0x46;

    public static final int ICON_PRIVACY_PASSIVE = 0x47;

    public static final int ICON_GROUPCHAT_INDEX = 0x40;

    public static final int ICON_GCJOIN_INDEX = 0x41;

    public static final int ICON_SEARCH_INDEX = 0x14;

    public static final int ICON_REGISTER_INDEX = 0x15;

    public static final int ICON_MSGCOLLAPSED_INDEX = 0x16;

    public static final int ICON_MESSAGE_INDEX = 0x20;

    public static final int ICON_AUTHRQ_INDEX = 0x21;

    public static final int ICON_COMPOSING_INDEX = 0x22;
    public static final int ICON_AD_HOC=ICON_COMPOSING_INDEX;

    public static final int ICON_EXPANDED_INDEX = 0x23;

    public static final int ICON_COLLAPSED_INDEX = 0x24;

    public static final int ICON_MESSAGE_BUTTONS = 0x25;

    public static final int ICON_PROFILE_INDEX = 0x30;

    public static final int ICON_PRIVACY_ALLOW = 0x36;

    public static final int ICON_PRIVACY_BLOCK = 0x37;

    public static final int ICON_KEYBLOCK_INDEX = 0x17;
}
/*
 * SmilesIcons.java
 *
 * Created on 3 Декабрь 2005 г., 20:07
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package images;

import ui.ImageList;

/**
 *
 * @author EvgS
 */
public class SmilesIcons extends ImageList{
    
    private final static int SMILES_IN_ROW=16;
    /** Creates a new instance of SmilesIcons */
    private SmilesIcons() {
	super("/images/smiles.png", 0, SMILES_IN_ROW);
    }
    private static ImageList instance;
    public static ImageList getInstance() {
	if (instance==null) instance=new SmilesIcons();
	return instance;
    }
}
/*
 * InfoWindow.java
 *
 * Created on 6 Сентябрь 2005 г., 22:21
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Info;
import Client.StaticData;
import javax.microedition.lcdui.*;
import locale.SR;
import midlet.Bombus;

/**
 *
 * @author EvgS
 */
public class InfoWindow implements CommandListener{

    private Display display;
    private Displayable parentView;
    
    private Form form;

    /** Creates a new instance of InfoWindow */
    public InfoWindow(Display display) {
        this.display=display;
        parentView=display.getCurrent();
        
        form=new Form(SR.MS_ABOUT);
        form.addCommand(new Command(SR.MS_CLOSE, Command.BACK, 99));
        try {
            Image icon=Bombus.programIcon;
            if (icon==null) icon=Image.createImage("/_icon.png");
            form.append(icon);
        } catch (Exception e) { }
        form.append("Bombus v"+Version.version+"\nMobile Jabber client\n");
        form.append(Version.getOs());
        form.append("\nCopyright (c) 2005-2006, Eugene Stahov (evgs),\n");
        form.append (new StringItem(null, Version.url
//#if !(MIDP1)
                , Item.HYPERLINK
//#endif
                ));
        
        StringBuffer memInfo=new StringBuffer("\n\nMemory:\n");
        memInfo.append("Free=");
        //mem.append(Runtime.getRuntime().freeMemory()>>10);
        //mem.append("\nFree=");
        System.gc();
        memInfo.append(Runtime.getRuntime().freeMemory()>>10);
        memInfo.append("\nTotal=");
        memInfo.append(Runtime.getRuntime().totalMemory()>>10);
        form.append(memInfo.toString());
//#if ZLIB
        form.append("\n\n");
        String conn_stats;
        try {
            conn_stats=StaticData.getInstance().roster.theStream.getStreamStats();
        } catch (Exception e) {
            conn_stats="disconnected";
        }
        form.append(conn_stats);
//#endif
     
        form.setCommandListener(this);
        display.setCurrent(form);
    }
    
    public void commandAction(Command c, Displayable d) {
        display.setCurrent(parentView);
    }
}
/*
 * Version.java
 *
 * Created on 23 Апрель 2005 г., 22:44
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Info;

import locale.SR;
import ui.ConstMIDP;

/**
 *
 * @author Evg_S
 */
public class Version {
//#if (!ZLIB)
//#     public final static String version="$BOMBUSVERSION$";
//#else
    public final static String version="$BOMBUSVERSION$-Zlib";
//#endif
    // this string will be patched by build.xml/post-preprocess
    
    public final static String url="http://bombus.jrudevels.org";

    public static boolean isSiemens;
	
    private static String platformName;
    
    public static String getPlatformName() {
        if (platformName==null) {
            platformName=System.getProperty("microedition.platform");
            
            String device=System.getProperty("device.model");
            String firmware=System.getProperty("device.software.version");
            
            if (platformName==null) platformName="Motorola";
            
            if (platformName.startsWith("j2me")) {
                
                if (device!=null && firmware!=null)
                    platformName="Motorola"; // buggy v360
            }
            
            if (platformName.startsWith("Moto")) {
                if (device==null) device=System.getProperty("funlights.product");
                if (device!=null) platformName="Motorola-"+device;
            }
            
//#if (!MIDP1)
            if (platformName.indexOf("SIE") > -1) {
                platformName=System.getProperty("microedition.platform");
                isSiemens=true;
            } else if (System.getProperty("com.siemens.OSVersion")!=null) {
                platformName="SIE-"+System.getProperty("microedition.platform")+"/"+System.getProperty("com.siemens.OSVersion");
                isSiemens=true;
            }
//#endif
        }
        return platformName;
    }

    public static String getOs() {
        return ConstMIDP.MIDP + " Platform=" +Version.getPlatformName();
    }
    
    public static String getVersionLang() { return version+" ("+SR.MS_IFACELANG+")"; }

}
/*
 * Utf8IOStream.java
 *
 * Created on 18 Декабрь 2005 пїЅ., 0:52
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package io;

//#if ZLIB
import com.jcraft.jzlib.JZlib;
import com.jcraft.jzlib.ZInputStream;
import com.jcraft.jzlib.ZOutputStream;
//#endif
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import javax.microedition.io.*;
import Client.Config;
import util.strconv;

/**
 *
 * @author EvgS
 */
public class Utf8IOStream implements Runnable{
    
    private StreamConnection connection;
    private InputStream inpStream;
    private OutputStream outStream;

    private boolean iStreamWaiting;

    private int bytesRecv;

    private int bytesSent;
    

//#if (ZLIB)
    public void setStreamCompression(){
        inpStream=new ZInputStream(inpStream);
        outStream=new ZOutputStream(outStream, JZlib.Z_DEFAULT_COMPRESSION);
        ((ZOutputStream)outStream).setFlushMode(JZlib.Z_SYNC_FLUSH);
    }
//#endif
    
//#if !(USE_UTF8_READER)
//#     private OutputStreamWriter outputWriter;
//#     private InputStreamReader inputReader;
//#endif
    
    /** Creates a new instance of Utf8IOStream */
    public Utf8IOStream(StreamConnection connection) throws IOException {
	this.connection=connection;
//#if !(MIDP1)
        try {
            Config cf=Config.getInstance();
            SocketConnection sc=(SocketConnection)connection;
            sc.setSocketOption(SocketConnection.KEEPALIVE, 1);
            /*if (cf.socketLINGER>=0) sc.setSocketOption(SocketConnection.LINGER, cf.socketLINGER);
            if (cf.socketRCVBUF>=0) sc.setSocketOption(SocketConnection.RCVBUF, cf.socketRCVBUF);
            if (cf.socketSNDBUF>=0) sc.setSocketOption(SocketConnection.SNDBUF, cf.socketSNDBUF);*/
        } catch (Exception e) {}
//#endif
	
	inpStream = connection.openInputStream();
	outStream = connection.openOutputStream();	

//#if !(USE_UTF8_READER)
//#         inputReader = new InputStreamReader(inpStream, "UTF-8");
//# 	outputWriter = new OutputStreamWriter(outStream,"UTF-8");
//#else
      length=pbyte=0;
//#endif


    }
    
    public void send( StringBuffer data ) throws IOException {
	
	synchronized (outStream) {
//#if !(USE_UTF8_READER)
//# 	    outputWriter.write(data);
//#else
	    //byte a[]=toUTF(data);
	    //for (int i=0;i<a.length; i++){
	    //	System.out.print(" "+((char)a[i])+"="+a[i]);
	    //}
	    //System.out.println();
            
            StringBuffer outbuf=strconv.toUTFSb(data);
            int outLen=outbuf.length();
            byte bytes[]=new byte[outLen];
            for (int i=0; i<outLen; i++) {
                bytes[i]=(byte)outbuf.charAt(i);
            }
            
	    outStream.write(bytes);
            bytesSent++;
//#endif
	    
//#if OUTSTREAM_FLUSH
	    outStream.flush();
//#endif
	}
//#if (XML_STREAM_DEBUG)        
//#         System.out.println(">> "+data);
//#endif
    }
    
//#if USE_UTF8_READER
    // temporary

    byte cbuf[]=new byte[512];
    int length;
    int pbyte;
    
    private int chRead() throws IOException{
        bytesRecv++;
        if (length>pbyte) return cbuf[pbyte++];

        int avail=inpStream.available();
        
//#if ZLIB
        if (inpStream instanceof ZInputStream) avail=512;
//#endif
        
        while (avail==0 
//#if (!ZLIB)
//#                 && iStreamWaiting
//#endif
                ) {
            try { Thread.sleep(100); } catch (Exception e) {};
            avail=inpStream.available();
        }
        
    //#if !(XML_STREAM_DEBUG)
	if (avail<2) return inpStream.read() &0xff;
    //#else
//#         if (avail<2) {
//# 	  System.out.println(" single-byte");
//#           int ch=inpStream.read();
//# 	  System.out.println("<< "+(char)ch);
//# 	  return ch;
//#         }
//#           System.out.println(" prebuffering "+avail);
    //#endif
	
	
	
	length= inpStream.read(cbuf, 0, (avail<512)?avail:512 );
	pbyte=1;
	
    //#if (XML_STREAM_DEBUG)
//# 	System.out.println("<< "+new String(cbuf, 0, length));
    //#endif
	return cbuf[0];
    }
//#endif
    
    public int getNextCharacter()
    throws IOException {
//#if !(USE_UTF8_READER)
//# 	return inputReader.read();
//#else
	int chr = chRead() &0xff;
	if( chr == 0xff ) return -1; // end of stream
	
	if (chr<0x80) return chr;
	if (chr<0xc0) throw new IOException("Bad UTF-8 Encoding encountered");
	
        int chr2= chRead() &0xff;
        if (chr2==0xff) return -1;
        if (chr2<0x80) throw new IOException("Bad UTF-8 Encoding encountered");
	
	if (chr<0xe0) {
	    // cx, dx 
	    return ((chr & 0x1f)<<6) | (chr2 &0x3f);
	}
	if (chr<0xf0) {
	    // cx, dx 
	    int chr3= chRead() &0xff;
	    if (chr3==0xff) return -1;
	    if (chr3<0x80) throw new IOException("Bad UTF-8 Encoding encountered");
	    else return ((chr & 0x0f)<<12) | ((chr2 &0x3f) <<6) | (chr3 &0x3f);
	}
	
	//System.out.print((char)j);
	return -1;
//#endif
    }
    
    public void close() {
//#if !(USE_UTF8_READER)
//# 	try { outputWriter.close(); }  catch (Exception e) {};
//# 	try { inputReader.close();  }  catch (Exception e) {};
//#endif
	try { outStream.close();    }  catch (Exception e) {};
	try { inpStream.close();    }  catch (Exception e) {};
	// Alcatel temporary bugfix - this method hangs
	//try { connection.close();   }  catch (Exception e) {};
	new Thread(this).start();
    }

    public void run() {
	// Alcatel temporary bugfix - this method hangs
	try { connection.close();   }  catch (Exception e) {};
    }
    
    public String readLine() throws IOException {
	StringBuffer buf=new StringBuffer();
	/*if (afterEol>0) {
	    buf.append(afterEol);
	    afterEol=0;
	}*/
	
	boolean eol=false;
	while (true) {
	    int c = getNextCharacter();
	    if (c<0) { 
		eol=true;
		if (buf.length()==0) return null;
		break;
	    }
	    if (c==0x0d || c==0x0a) {
		eol=true;
		//inputstream.mark(2);
		if (c==0x0a) break;
	    }
	    else {
		if (eol) {
		    //afterEol=c;
		    //inputstream.reset();
		    break;
		}
		buf.append((char) c);
	    }
	}
	return buf.toString();
    }

    /**
     * Enables inputStream.available() polling before read
     * it is critical for Motorola phones
     */
    public void setStreamWaiting(boolean iStreamWaiting) {  this.iStreamWaiting = iStreamWaiting; }
//#if ZLIB
    public String getStreamStats() {
        StringBuffer stats=new StringBuffer();
        int sent=this.bytesSent;
        int recv=this.bytesRecv;
        if (inpStream instanceof ZInputStream) {
            ZInputStream z = (ZInputStream) inpStream;
            recv+=z.getTotalIn()-z.getTotalOut();
            ZOutputStream zo = (ZOutputStream) outStream;
            sent+=zo.getTotalIn()-zo.getTotalOut();
            stats.append("ZLib:\nin="); stats.append(z.getTotalIn()); stats.append(" inz="); stats.append(z.getTotalOut());
            stats.append("\nout="); stats.append(zo.getTotalOut()); stats.append(" outz="); stats.append(zo.getTotalIn());
        }
        stats.append("\nStream:\nin="); stats.append(recv);
        stats.append("\nout="); stats.append(sent);
        
        return stats.toString();
    }
//#endif
}
/*
 * FileComMotorolaIo.java
 *
 * Created on 1 Октябрь 2006 г., 20:54
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package io.file;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Vector;
import javax.microedition.io.Connector;

/**
 *
 * @author evgs
 */
class FileComMotorolaIo extends FileIO{

    private com.motorola.io.FileConnection fileConnection;

    /** Creates a new instance of FileComMotorolaIo */
    public FileComMotorolaIo(String fileName) {
        this.fileName=fileName;
    }

    protected void openFile() throws IOException {
        fileConnection = (com.motorola.io.FileConnection) Connector.open("file://" + fileName);
    }

    public OutputStream openOutputStream() throws IOException {
        if (fileConnection==null) openFile();
        if (!fileConnection.exists()) {
            fileConnection.create();
        } else {
            fileConnection.delete();
            fileConnection.create();
        }
        return fileConnection.openOutputStream();
    }

    public InputStream openInputStream() throws IOException {
        if (fileConnection==null) openFile();
        return fileConnection.openInputStream(); 
    }

    public void close() throws IOException {
        if (fileConnection!=null) fileConnection.close();
        fileConnection=null;
    }

    public long fileSize() {
        return (fileConnection == null)? 0: fileConnection.fileSize();
    }

    protected Vector rootDirs() {
        String[] roots = com.motorola.io.FileSystemRegistry.listRoots();
        Vector rd=new Vector(roots.length);
        for (int i = 0; i < roots.length; i++)
            rd.addElement(roots[i].substring(1));
        return rd;
    }

    protected Vector dirs(boolean directoriesOnly) throws IOException {
        openFile();
        String[] list = fileConnection.list();
        close();
        
        Vector rd=new Vector(list.length + 1);
        for (int i = 0; i < list.length; i++) {
            if (directoriesOnly & !list[i].endsWith("/")) continue;
            rd.addElement(list[i].substring(fileName.length()));
        }
        return rd;
    }
}
/*
 * File.java
 *
 * Created on 1 Октябрь 2006 г., 20:52
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package io.file;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Vector;

/**
 *
 * @author evgs
 */
public abstract class FileIO {
    private final static int NOT_DETECTED=0;
    private final static int NONE=-1;
    private final static int JSR75=1;
    private final static int COM_MOTOROLA=2;
    private final static int COM_SIEMENS=3;
    
    private static int fileSystemType;
    
    protected String fileName;
    
    public static FileIO createConnection(String fileName) {
        if (fileSystemType==NOT_DETECTED) {
            fileSystemType=NONE;
            try {
                Class.forName("javax.microedition.io.file.FileConnection");
                fileSystemType=JSR75;
            } catch (Exception e) {}
            try {
                Class.forName("com.motorola.io.FileConnection");
                fileSystemType=COM_MOTOROLA;
            } catch (Exception e) {}
            try {
                Class.forName("com.siemens.mp.io.File");
                fileSystemType=COM_SIEMENS;
            } catch (Exception e) {}
        }
        switch (fileSystemType) {
            case JSR75: return new FileJSR75(fileName);
            case COM_MOTOROLA: return new FileComMotorolaIo(fileName);
            case COM_SIEMENS: return new FileSiemens(fileName);
        }
        return null;
    }
    
    public Vector fileList(boolean directoriesOnly) throws IOException{
        if (fileName.equals("/")) return rootDirs();
        Vector dir=dirs(directoriesOnly);
        dir.addElement("../");
        return dir;
    }
    
    public abstract OutputStream openOutputStream() throws IOException;
   
    public abstract InputStream openInputStream() throws IOException;
    
    public abstract void close() throws IOException;
    
    public abstract long fileSize() throws IOException;

    protected abstract Vector rootDirs();
    protected abstract Vector dirs(boolean directoriesOnly) throws IOException;
}
/*
 * FileJSR75.java
 *
 * Created on 1 Октябрь 2006 г., 20:53
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package io.file;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.Vector;
import javax.microedition.io.Connector;

/**
 *
 * @author evgs
 */
class FileJSR75 extends FileIO{
    private javax.microedition.io.file.FileConnection fileConnection;

    /** Creates a new instance of FileJSR75 */
    public FileJSR75(String fileName) {
        this.fileName=fileName;
    }
    
    protected void openFile() throws IOException{
        fileConnection = (javax.microedition.io.file.FileConnection) Connector.open("file://" + fileName);
    }

    public OutputStream openOutputStream() throws IOException{
        if (fileConnection==null) openFile();
        if (!fileConnection.exists()) {
            fileConnection.create();
        } else {
            fileConnection.delete();
            fileConnection.create();
        }
        return fileConnection.openOutputStream();
    }

    public InputStream openInputStream() throws IOException{
        if (fileConnection==null) openFile();
        return fileConnection.openInputStream(); 
    }

    public void close() throws IOException{
        if (fileConnection!=null) fileConnection.close();
        fileConnection=null;
    }

    public long fileSize() throws IOException {
        return (fileConnection == null)? 0: fileConnection.fileSize();
    }

    protected Vector rootDirs() {
        Vector rd = new Vector();
        Enumeration roots = javax.microedition.io.file.FileSystemRegistry.listRoots();
        while (roots.hasMoreElements())
            rd.addElement(((String) roots.nextElement()));
        return rd;
    }

    protected Vector dirs(boolean directoriesOnly) throws IOException{
        openFile();
        Enumeration dirs=fileConnection.list();
        close();
        Vector rd=new Vector();
        while (dirs.hasMoreElements()) {
            rd.addElement((String)dirs.nextElement());
        }
        return rd;
    }
}
/*
 * FileSiemens.java
 *
 * Created on 7 Октябрь 2006 г., 23:20
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */


package io.file;

import com.siemens.mp.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Vector;

public class FileSiemens extends FileIO{
    
    private File f;
    private int fd;

    public FileSiemens(String fileName) {
        // Siemens requires backslashes
        this.fileName=fileName=fileName.replace('/', '\\').substring(1);
    }
    
    public void openFile() throws IOException{
	f = new File();
        fd = f.open(fileName);
    }
    
    public void close() throws IOException{
	f.close(fd);
	f = null;
    }
    
    public long fileSize() throws IOException {
	return f.length(fd);
    }

    protected Vector rootDirs() {
        Vector rd = new Vector();
        rd.addElement("/0:/");
        rd.addElement("/1:/");
        rd.addElement("/2:/");
        rd.addElement("/3:/");
        rd.addElement("/4:/");
        return rd;
    }

    protected Vector dirs(boolean directoriesOnly) throws IOException{
        String[] directory=File.list(fileName);
        Vector rd=new Vector(directory.length + 1);
        for (int i = 0; i < File.list(fileName).length; i++) {
            if (File.isDirectory(fileName+directory[i])) {
                rd.addElement(directory[i]+"/");
            } else {
                rd.addElement(directory[i]);
            }
        }
        return rd;
    }

    public OutputStream openOutputStream() throws IOException {
        return null;
    }

    public InputStream openInputStream() throws IOException {
        return new FileSiemensInputStream(f, fd);
    }  
}

class FileSiemensInputStream extends InputStream {
    private int fileDescriptor;
    private File f;

    public FileSiemensInputStream(File f, int fd) {
        this.f=f; this.fileDescriptor=fd;
    }
    
    public int read() throws IOException {
        byte buf[]=new byte[1];
        f.read(fileDescriptor, buf, 0, 1);
        return buf[0];
    }

    public int read(byte[] b, int off, int len) throws IOException {  return f.read(fileDescriptor, b, off, len); }

    public int read(byte[] b) throws IOException {  return f.read(fileDescriptor, b, 0, b.length);  }
}/*
 * Browser.java
 *
 * Created on 26 Сентябрь 2006 г., 23:42
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package io.file.browse;

import Client.Title;
import images.RosterIcons;
import io.file.FileIO;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;

import javax.microedition.io.Connector;
import javax.microedition.io.file.FileConnection;
import javax.microedition.io.file.FileSystemRegistry;

import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import locale.SR;
import ui.IconTextElement;
import ui.VirtualElement;
import ui.VirtualList;

/**
 *
 * @author evgs
 */
public class Browser extends VirtualList implements CommandListener{
 
    private Vector dir;
    
    Command cmdOk=new Command(SR.MS_BROWSE, Command.OK, 1);
    Command cmdSelect=new Command(SR.MS_SELECT, Command.SCREEN, 2);
    Command cmdBack=new Command(SR.MS_BACK, Command.BACK, 98);
    Command cmdCancel=new Command(SR.MS_CANCEL, Command.CANCEL, 99);
    
    private String path;
    private BrowserListener browserListener;
    
    /** Creates a new instance of Browser */
    public Browser(Display display, BrowserListener browserListener, boolean getDirectory) {
        super(display);
        
        this.browserListener=browserListener;
        
        setTitleItem(new Title(2, null, null));
        
        addCommand(cmdOk);
        if (getDirectory) addCommand(cmdSelect);
        addCommand(cmdBack);
        addCommand(cmdCancel);
        setCommandListener(this);
        
        path="/";
        readDirectory(path);
        sort(dir);
    }
    
    protected int getItemCount() { return dir.size(); }
    
    protected VirtualElement getItemRef(int index) { return (VirtualElement) dir.elementAt(index); }
    
    public void commandAction(Command command, Displayable displayable) {
        if (command==cmdBack) {
            if (!chDir("../")) {
                destroyView();
                return;
            }
            readDirectory(path);
            sort(dir);
        }
        
        
        if (command==cmdOk) eventOk();
        if (command==cmdSelect) {
            String f=((FileItem)getFocusedObject()).name;
            if (f.endsWith("/")) {
                if (browserListener==null) return;
                destroyView();
                browserListener.BrowserFilePathNotify(path+f);
                return;
            }
            //todo: choose directory here
        }
        if (command==cmdCancel) { destroyView(); }
    }
    
    
    private boolean chDir(String relativePath) {
        if (relativePath.equals("../")) {
            if (path.length()<2) return false;
            path=path.substring(0, 1+path.lastIndexOf('/', path.length()-2));
        } else {
            path+=relativePath;
        }
        return true;
    }
    
    private void readDirectory(String name) {
        getTitleItem().setElementAt(path, 0);
        
        dir=new Vector();
        
        try {
            FileIO f=io.file.FileIO.createConnection(name);
            
            Enumeration files=f.fileList(false).elements();
            
            while (files.hasMoreElements() )
                dir.addElement( new FileItem((String) files.nextElement()) );
            
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    
    public void eventOk() {
        String f=((FileItem)getFocusedObject()).name;
        if (!f.endsWith("/")) {
            if (browserListener==null) return;
            destroyView();
            browserListener.BrowserFilePathNotify(path+f);
            return;
        }
        if (!chDir(f)) { 
            destroyView(); 
            return; 
        }
        readDirectory(path);
        sort(dir);
        redraw();
    }
    
    
    public final void sort(Vector sortVector){
        synchronized (sortVector) {
            int f, i;
            FileItem temp, temp2;
            
            for (f = 1; f < sortVector.size(); f++) {
                temp=(FileItem)sortVector.elementAt(f);
                temp2=(FileItem)sortVector.elementAt(f-1);
                if ( temp.compare(temp2) >=0 ) continue;
                i = f-1;
                while (i>=0){
                    temp2=(FileItem)sortVector.elementAt(i);
                    if (temp2.compare(temp) <0) break;
                    sortVector.setElementAt(temp2,i+1);
                    i--;
                }
                sortVector.setElementAt(temp,i+1);
            }
        }
    }
    
    private class FileItem extends IconTextElement {
        
        public String name;
        private int iconIndex;
        
        public FileItem(String name) {
            super(RosterIcons.getInstance());
            this.name=name;
            //TODO: file icons
            iconIndex=name.endsWith("/")? RosterIcons.ICON_COLLAPSED_INDEX: RosterIcons.ICON_PRIVACY_ACTIVE;
        }
        protected int getImageIndex() { return iconIndex; }
        
        public int getColor() { return 0; }
        
        public String toString() { return name; }
        
        private int compare(FileItem fileItem) {
            int cpi=iconIndex-fileItem.iconIndex;
            if (cpi==0) cpi=name.compareTo(fileItem.name);
            return cpi;
        }
        
        
    }
}
/*
 * BrowserListener.java
 *
 * Created on 2 Октябрь 2006 г., 1:44
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */

package io.file.browse;

/**
 *
 * @author evgs
 */
public interface BrowserListener {
    public void BrowserFilePathNotify(String pathSelected);
}
/*
 * SR.java
 *
 * Created on March 19, 2006, 3:06 PM
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 * (c) Alexey V.Lubimov <avl@l14.ru>, 2006.
 */

package locale;

import Client.Config;
import java.util.Hashtable;
import util.StringLoader;

public class SR {
    
    public   static String MS_JID = loadString( "Jid" );
    public   static String MS_LOADING = loadString( "Loading" );
    public   static String MS_PRIVACY_LISTS = loadString( "Privacy Lists" );
    public   static String MS_EXISTING_GROUPS = loadString( "Existing groups" );
    public   static String MS_MESSAGE_FONT = loadString( "Message font" );
    public   static String MS_ROSTER_FONT = loadString( "Roster font" );
    public   static String MS_PASTE_BODY = loadString( "Paste Body" );
    public   static String MS_CONFIG_ROOM = loadString( "Configure Room" );
    public   static String MS_PASTE_SUBJECT = loadString( "Paste Subject" );
    public   static String MS_DISCO = loadString( "Service Discovery" );
    public   static String MS_USER_JID = loadString( "User JID" );
    public   static String MS_NEW_LIST = loadString( "New list" );
    public   static String MS_NOLOGIN = loadString( "Select (no login)" );
    public   static String MS_PRIVACY_RULE = loadString( "Privacy rule" );
    public   static String MS_SSL = loadString( "use SSL" );
    public   static String MS_MODIFY = loadString( "Modify" );
    public   static String MS_UPDATE = loadString( "Update" );
    public   static String MS_ACCOUNT_NAME = loadString( "Account name" );
    public   static String MS_GMT_OFFSET = loadString( "GMT offset" );
    public   static String MS_TIME_SETTINGS = loadString( "Time settings (hours)" );
    public   static String MS_CONNECTED = loadString( "Connected" );
    public   static String MS_CONNECT_TO = loadString( "Connect to " );
    public   static String MS_ALERT_PROFILE = loadString( "Alert Profile" );
    public   static String MS_MOVE_UP = loadString( "Move Up" );
    public   static String MS_OWNERS = loadString( "Owners" );
    public   static String MS_OK = loadString( "Ok" );
    public   static String MS_APP_MINIMIZE = loadString( "Minimize" );
    public   static String MS_ROOM = loadString( "Room" );
    public   static String MS_MESSAGES = loadString( "Messages" );
    public   static String MS_REFRESH = loadString( "Refresh" );
    public   static String MS_RESOLVE_NICKNAMES = loadString( "Resolve Nicknames" );
    public   static String MS_PRIVACY_ACTION = loadString( "Action" );
    public   static String MS_BAN = loadString( "Ban" );
    public   static String MS_LEAVE_ROOM = loadString( "Leave Room" );
    public   static String MS_PASSWORD = loadString( "Password" );
    public   static String MS_ITEM_ACTIONS = loadString( "Actions >" );
    public   static String MS_ACTIVATE = loadString( "Activate" );
    public   static String MS_AFFILIATION = loadString( "Affiliation" );
    public   static String MS_ACCOUNTS = loadString( "Accounts" );
    public   static String MS_DELETE_LIST = loadString( "Delete list" );
    public   static String MS_ACCOUNT_= loadString( "Account >" );
    public   static String MS_SHOWOFFLINES = loadString( "Show Offlines" );
    public   static String MS_SELECT = loadString( "Select" );
    public   static String MS_SUBJECT = loadString( "Subject" );
    public   static String MS_GROUP_MENU = loadString( "Group menu" );
    public   static String MS_APP_QUIT = loadString( "Quit" );
    public   static String MS_ROSTERADD = loadString( "Add to roster" );
    public   static String MS_EDIT_LIST = loadString( "Edit list" );
    public   static String MS_REGISTERING = loadString( "Registering" );
    public   static String MS_DONE = loadString( "Done" );
    public   static String MS_ERROR_ = loadString( "Error: " );
    public   static String MS_BROWSE = loadString( "Browse" );
    public   static String MS_SAVE_LIST = loadString( "Save list" );
    public   static String MS_KEEPALIVE_PERIOD = loadString( "Keep-Alive period" );
    public   static String MS_NEWGROUP = loadString( "<New Group>" );
    public   static String MS_SEND = loadString( "Send" );
    public   static String MS_PRIORITY = loadString( "Priority" );
    public   static String MS_FAILED = loadString( "Failed" );
    public   static String MS_SET_PRIORITY = loadString( "Set Priority" );
    public   static String MS_DELETE_RULE = loadString( "Delete rule" );
    public   static String MS_IGNORE_LIST = loadString( "Ignore-List" );
    public   static String MS_ROSTER_REQUEST = loadString( "Roster request" );
    public   static String MS_PRIVACY_TYPE = loadString( "Type" );
    public   static String MS_NAME = loadString( "Name" );
    public   static String MS_USERNAME = loadString( "Username" );
    public   static String MS_FULLSCREEN = loadString( "fullscreen" );
    public   static String MS_ALL_PRIORITIES = loadString( "All Priorities" );
    public   static String MS_ADD_BOOKMARK = loadString( "Add bookmark" );
    public   static String MS_CONFERENCES_ONLY = loadString( "conferences only" );
    public   static String MS_CLIENT_INFO = loadString( "Client Version" );
    public   static String MS_DISCARD = loadString( "Discard Search" );
    public   static String MS_SEARCH_RESULTS = loadString( "Search Results" );
    public   static String MS_GENERAL = loadString( "General" );
    public   static String MS_MEMBERS = loadString( "Members" );
    public   static String MS_ADD_CONTACT = loadString( "Add Contact" );
    public   static String MS_SUBSCRIPTION = loadString( "Subscription" );
    public   static String MS_STATUS_MENU = loadString( "Status >" );
    public   static String MS_JOIN = loadString( "Join" );
    public   static String MS_STARTUP_ACTIONS = loadString( "Startup actions" );
    public   static String MS_SERVER = loadString( "Server" );
    public   static String MS_ADMINS = loadString( "Admins" );
    public   static String MS_MK_ILIST = loadString( "Make Ignore-List" );
    public   static String MS_OPTIONS = loadString( "Options" );
    public   static String MS_DELETE = loadString( "Delete" );
    public   static String MS_DELETE_ASK = loadString( "Delete contact?" );
    public   static String MS_SUBSCRIBE = loadString( "Authorize" );
    public   static String MS_NICKNAMES = loadString( "Nicknames" );
    public   static String MS_ENT_SETUP = loadString( "Entering setup" );
    public   static String MS_ADD_ARCHIVE = loadString( "to Archive" );
    public   static String MS_BACK = loadString( "Back" );
    public   static String MS_HEAP_MONITOR = loadString( "heap monitor" );
    public   static String MS_HIDE_SPLASH = loadString( "Hide Splash" );
    public   static String MS_MESSAGE = loadString( "Message" );
    public   static String MS_OTHER = loadString( "<Other>" );
    public   static String MS_HISTORY = loadString( "history -" );
    public   static String MS_APPEND = loadString( "Append" );
    public   static String MS_ACTIVE_CONTACTS = loadString( "Active Contacts" );
    public   static String MS_SELECT_NICKNAME = loadString( "Select nickname" );
    public   static String MS_GROUP = loadString( "Group" );
    public   static String MS_JOIN_CONFERENCE = loadString( "Join conference" );
    public   static String MS_NO = loadString( "No" );
    public   static String MS_REENTER = loadString( "Re-Enter Room" );
    public   static String MS_NEW_MESSAGE = loadString( "New Message" );
    public   static String MS_ADD = loadString( "Add" );
    public   static String MS_LOGON = loadString( "Logon" );
    public   static String MS_LOGINPGS = loadString( "Login in progress" );
    public   static String MS_STANZAS = loadString( "Stanzas" );
    public   static String MS_AT_HOST = loadString( "at Host" );
    public   static String MS_AUTO_CONFERENCES = loadString( "join conferences" );
    public   static String MS_STATUS = loadString( "Status" );
    public   static String MS_SMILES_TOGGLE = loadString( "Smiles" );
    public   static String MS_CONTACT = loadString( "Contact >" );
    public final static String MS_SLASHME = "/me";
    public   static String MS_ORDER = loadString( "Order" );
    public   static String MS_OFFLINE_CONTACTS = loadString( "offline contacts" );
    public   static String MS_TRANSPORT = loadString( "Transport" );
    public   static String MS_COMPOSING_EVENTS = loadString( "composing events" );
    public   static String MS_ADD_SMILE = loadString( "Add Smile" );
    public   static String MS_NICKNAME = loadString( "Nickname" );
    public   static String MS_REVOKE_VOICE = loadString( "Revoke Voice" );
    public   static String MS_NOT_IN_LIST = loadString( "Not-in-list" );
    public   static String MS_COMMANDS = loadString( "Commands" );
    public   static String MS_CHSIGN = loadString( "- (Sign)" );
    public   static String MS_SETDEFAULT = loadString( "Set default" );
    public   static String MS_BANNED = loadString( "Outcasts (Ban)" );
    public   static String MS_SET_AFFILIATION = loadString( "Set affiliation to" );
    public   static String MS_HIDE_OFFLINES = loadString( "Hide Offlines" );
    public   static String MS_REGISTER_ACCOUNT = loadString( "Register Account" );
    public   static String MS_AUTOLOGIN = loadString( "autologin" );
    public   static String MS_LOGOFF = loadString( "Logoff" );
    public   static String MS_PUBLISH = loadString( "Publish" );
    public   static String MS_SUBSCR_REMOVE = loadString( "Remove subscription" );
    public   static String MS_SET = loadString( "Set" );
    public   static String MS_APPLICATION = loadString( "Application" );
    public   static String MS_BOOKMARKS = loadString( "Bookmarks" );
    public   static String MS_TEST_SOUND = loadString( "Test sound" );
    public   static String MS_STARTUP = loadString( "Startup" );
    public   static String MS_EDIT_RULE = loadString( "Edit rule" );
    public   static String MS_CANCEL = loadString( "Cancel" );
    public   static String MS_CLOSE = loadString( "Close" );
    public   static String MS_ARCHIVE = loadString( "Archive" );
    public   static String MS_FREE = loadString( "free " );
    public   static String MS_CONFERENCE = loadString( "Conference" );
    public   static String MS_SOUND = loadString( "Sound" );
    public   static String MS_LOGIN_FAILED = loadString( "Login failed" );
    public   static String MS_DISCOVER = loadString( "Browse" ); //"Discover"
    public   static String MS_NEW_JID = loadString( "New Jid" );
    public   static String MS_PLAIN_PWD = loadString( "plain-text password" );
    public   static String MS_PASTE_NICKNAME = loadString( "Paste Nickname" );
    public   static String MS_KICK = loadString( "Kick" );
    public   static String MS_CLEAR_LIST = loadString( "Clear List" );
    public   static String MS_GRANT_VOICE = loadString( "Grant Voice" );
    public   static String MS_MOVE_DOWN = loadString( "Move Down" );
    public   static String MS_QUOTE = loadString( "Quote" );
    public   static String MS_ROSTER_ELEMENTS = loadString( "Roster elements" );
    public   static String MS_ENABLE_POPUP = loadString( "popup from background" );
    public   static String MS_SMILES = loadString( "smiles" );
    public   static String MS_ABOUT = loadString( "About" );
    public   static String MS_RESOURCE = loadString( "Resource" );
    public   static String MS_DISCONNECTED = loadString( "Disconnected" );
    public   static String MS_EDIT = loadString( "Edit" );
    public   static String MS_HOST_IP = loadString( "Host name/IP (optional)" );
    public   static String MS_ADD_RULE = loadString( "Add rule" );
    public   static String MS_ALL_STATUSES = loadString( "for all status types" );
    public   static String MS_PASTE_JID = loadString( "Paste Jid" );
    public   static String MS_GOTO_URL = loadString( "Goto URL" );
    public   static String MS_CLOCK = loadString( "Clock -" );
    public   static String MS_LOGIN = loadString( "Login" );
    public   static String MS_CLOCK_OFFSET = loadString( "Clock offset" );
    public   static String MS_YES = loadString( "Yes" );
    public   static String MS_FLASHBACKLIGHT = loadString( "flash backlight" );
    public   static String MS_SUSPEND = loadString( "Suspend" );
    public   static String MS_ALERT_PROFILE_CMD = loadString( "Alert Profile >" );
    public   static String MS_MY_VCARD = loadString( "My vCard" );
    public   static String MS_TRANSPORTS = loadString( "transports" );
    public   static String MS_NEW_ACCOUNT = loadString( "New Account" );
    public   static String MS_SELF_CONTACT = loadString( "self-contact" );
    public   static String MS_VCARD = loadString( "vCard" );
    public   static String MS_SET_SUBJECT = loadString( "Set Subject" );
    public   static String MS_TOOLS = loadString( "Tools" );
    public   static String MS_JABBER_TOOLS = loadString( "Jabber Tools" );
    public   static String MS_PORT = loadString( "Port" );
    public   static String MS_RESUME = loadString( "Resume Message" );
    public   static String MS_PROXY_ENABLE = loadString( "proxy CONNECT" );
    public   static String MS_PROXY_HOST = loadString( "Proxy name/IP" );
    public   static String PROXY_PORT = loadString( "Proxy port" );
    public   static String MS_ARE_YOU_SURE_WANT_TO_DISCARD = loadString( "Are You sure want to discard " );
    public   static String MS_FROM_OWNER_TO = loadString( " from OWNER to " );
    public   static String MS_MODIFY_AFFILIATION = loadString( "Modify affiliation" );
    public   static String MS_AUTOFOCUS = loadString( "Autofocus" );
    public   static String MS_ADD_TO_ROSTER = loadString( "Add to roster" );
    public   static String MS_CLEAR=loadString( "Clear" );
    public   static String MS_ALT_LANG="langfile";
    public   static String MS_GRANT_MEMBERSHIP = "Grant Membership";
    public   static String MS_SELLOGIN = loadString( "Connect" );
//--toon
    public   static String MS_UNAFFILIATE = loadString("Unaffiliate");
    public   static String MS_GRANT_MODERATOR = loadString("Grant Moderator");
    public   static String MS_REVOKE_MODERATOR = loadString("Revoke Moderator");
    public   static String MS_GRANT_ADMIN = loadString("Grant Admin");
    public   static String MS_GRANT_OWNERSHIP = loadString("Grant Ownership");
//--toon
    
    public   static String MS_VIZITORS_FORBIDDEN=loadString("Visitors are not allowed to send messages to all occupants");
    public   static String MS_IS_INVITING_YOU=loadString(" is inviting You to ");
    public   static String MS_ASK_SUBSCRIPTION=loadString( "Ask subscription");
    public   static String MS_GRANT_SUBSCRIPTION=loadString("Grant subscription");
    public   static String MS_INVITE=loadString("Invite to conference");
    public   static String MS_INVITE_REASON=loadString("Reason");
    public   static String MS_YOU_HAVE_BEEN_INVITED=loadString("You have been invited to ");
    public final static String MS_SURE_CLEAR="Are You sure want to clear messagelist?";
    public   static String MS_DISCO_ROOM=loadString("Participants");
    public   static String MS_CAPS_STATE=loadString("Abc");
    
    public   static String MS_STORE_PRESENCE = loadString( "room presences" );
    
    public   static String MS_IS_NOW_KNOWN_AS=loadString(" is now known as ");
    public   static String MS_WAS_BANNED=loadString(" was banned ");
    public   static String MS_WAS_KICKED=loadString(" was kicked ");
    public   static String MS_HAS_BEEN_KICKED_BECAUSE_ROOM_BECAME_MEMBERS_ONLY=loadString(" has been kicked because room became members-only");
    public   static String MS_HAS_LEFT_CHANNEL=loadString(" has left the channel");
    public   static String MS_HAS_JOINED_THE_CHANNEL_AS=loadString(" has joined the channel as ");
    public   static String MS_AND=loadString(" and ");
    public   static String MS_IS_NOW=loadString(" is now ");    
    
    public   static String MS_TOKEN=loadString("Google token request");
    
    public final static String MS_SASL="SASL login";
    public final static String MS_FEATURES="Features";
    public final static String MS_SHOWPWD="Show password";
    public final static String MS_NO_VERSION_AVAILABLE="No client version available";
    public final static String MS_MSG_LIMIT="Message limit";
    
    public final static String MS_OPENING_STREAM="Opening stream";
    public final static String MS_SASL_STREAM="SASL handshake";
    public final static String MS_ZLIB="Using compression";
    public final static String MS_AUTH="Authenticating";
    public final static String MS_RESOURCE_BINDING="Resource binding";
    public final static String MS_SESSION="Initiating session";
    
    public final static String MS_TEXTWRAP="Text wrapping";
    public final static String MS_TEXTWRAP_CHARACTER="by chars";
    public final static String MS_TEXTWRAP_WORD="by words";

    public static String MS_XMLLANG;
    public static String MS_IFACELANG;


    private SR() { }
    
    private static Hashtable lang;
    
    private static String loadString(String key) {
        if (lang==null) {
            String langFile=Config.getInstance().langFileName();
            if (langFile==null) lang=new Hashtable(); 
            else lang=new StringLoader().hashtableLoader(langFile);
            System.out.print("Loading locale ");
            System.out.println(langFile);
            MS_XMLLANG=(String)lang.get("xmlLang");
            
            MS_IFACELANG=MS_XMLLANG;
            if (MS_IFACELANG==null) MS_IFACELANG="en";
        }
        String value=(String)lang.get(key);
//#if LOCALE_DEBUG
        if (value==null) {
            if (Config.getInstance().lang!=0) {
                System.out.print("Can't find local string for <");
                System.err.print(key);
                System.err.println('>');
            }
        }
//#endif
        return (value==null)?key:value;
    }

    public static void loaded() {
        lang=null;
    }
}
/*
 * LoginListener.java
 *
 * Created on 8 Июль 2006 г., 22:40
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package login;

/**
 *
 * @author evgs
 */
public interface LoginListener {
    public void loginFailed(String error);
    public void loginSuccess();
    public void loginMessage(String msg);
}
/*
 * NonSASLAuth.java
 *
 * Created on 8 Июль 2006 г., 22:16
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package login;

import Client.Account;
import com.alsutton.jabber.JabberBlockListener;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.JabberStream;
import com.alsutton.jabber.datablocks.Iq;
import com.ssttr.crypto.SHA1;
import locale.SR;
import util.strconv;

/**
 *
 * @author evgs
 */
public class NonSASLAuth implements JabberBlockListener{
    
    private LoginListener listener;
    
    /** Creates a new instance of NonSASLAuth */
    public NonSASLAuth(Account account, String sessionId, LoginListener listener, JabberStream stream) {
        this.listener=listener;
        stream.addBlockListener(this);
        
        Iq auth= new Iq(account.getServer(), Iq.TYPE_SET, "auth-s" );
        
        JabberDataBlock queryBlock = auth.addChild("query", null );
        queryBlock.setNameSpace( "jabber:iq:auth" );
        
        queryBlock.addChild( "username", account.getUserName() );
        
        if (account.getPlainAuth()) {
            // plain text
            queryBlock.addChild("password", account.getPassword() );
        } else {
            //digest
            SHA1 sha=new SHA1();
                sha.init();
                sha.updateASCII(sessionId);
                sha.updateASCII(strconv.wCharToUTF(account.getPassword()) );
                sha.finish();
            queryBlock.addChild("digest", sha.getDigestHex() );
        }
        
        queryBlock.addChild( "resource", account.getResource() );
        
        listener.loginMessage(SR.MS_AUTH);
        
        stream.send(auth);
    }

    public int blockArrived(JabberDataBlock data) {
        try {
            if( data instanceof Iq ) {
                String type = (String) data.getTypeAttribute();
                String id=(String) data.getAttribute("id");
                if ( id.equals("auth-s") ) {
                    if (type.equals( "error" )) {
                        // Authorization error
                        listener.loginFailed( data.getChildBlock("error").toString() );
                        return JabberBlockListener.NO_MORE_BLOCKS;
                    } else if (type.equals( "result")) {
                        listener.loginSuccess();
                        return JabberBlockListener.NO_MORE_BLOCKS;
                    }
                }
            }
            
        } catch (Exception e) { }
        return JabberBlockListener.BLOCK_REJECTED;        
    }
    
}
/*
 * SASLAuth.java
 *
 * Created on 8 Июль 2006 г., 23:34
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package login;

import Client.Account;
import com.alsutton.jabber.JabberBlockListener;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.JabberStream;
import com.alsutton.jabber.datablocks.Iq;
import com.ssttr.crypto.MD5;
import java.io.IOException;
import locale.SR;

import util.strconv;
//#if SASL_XGOOGLETOKEN
import java.io.InputStream;
import javax.microedition.io.Connector;
import javax.microedition.io.HttpConnection;
//#endif

/**
 *
 * @author evgs
 */
public class SASLAuth implements JabberBlockListener{
    
    private LoginListener listener;
    private Account account;
    private JabberStream stream;
    private String sessionId;
    /** Creates a new instance of SASLAuth */
    public SASLAuth(Account account, String sessionId, LoginListener listener, JabberStream stream) {
        this.listener=listener;
        this.account=account;
        this.sessionId=sessionId;
        this.stream=stream;
        if (stream!=null) stream.addBlockListener(this);
        listener.loginMessage(SR.MS_SASL_STREAM);
    }
    
//#if SASL_XGOOGLETOKEN
    private String token;
    public void setToken(String token) { this.token=token; }
//#endif

    public int blockArrived(JabberDataBlock data) {
        //System.out.println(data.toString());
        if (data.getTagName().equals("stream:features")) {
//#if ZLIB
            JabberDataBlock compr=data.getChildBlock("compression");
            if (compr!=null) {
                if (compr.getChildBlockByText("zlib")!=null) {
                    // negotiating compression
                    JabberDataBlock askCompr=new JabberDataBlock("compress", null, null);
                    askCompr.setNameSpace("http://jabber.org/protocol/compress");
                    askCompr.addChild("method", "zlib");
                    stream.send(askCompr);
                    listener.loginMessage(SR.MS_ZLIB);
                    return JabberBlockListener.BLOCK_PROCESSED;
                }
            }
//#endif            
            JabberDataBlock mech=data.getChildBlock("mechanisms");
            if (mech!=null) {
                // first stream - step 1. selecting authentication mechanism
                //common body
                JabberDataBlock auth=new JabberDataBlock("auth", null,null);
                auth.setNameSpace("urn:ietf:params:xml:ns:xmpp-sasl");
                
                // DIGEST-MD5 mechanism
                if (mech.getChildBlockByText("DIGEST-MD5")!=null) {
                    auth.setAttribute("mechanism", "DIGEST-MD5");
                    
                    //System.out.println(auth.toString());
                    
                    stream.send(auth);
                    listener.loginMessage(SR.MS_AUTH);
                    return JabberBlockListener.BLOCK_PROCESSED;
                }
                
//#if SASL_XGOOGLETOKEN
                // X-GOOGLE-TOKEN mechanism
                if (mech.getChildBlockByText("X-GOOGLE-TOKEN")!=null) {
                    auth.setAttribute("mechanism", "X-GOOGLE-TOKEN");
                    auth.setText(token);
                    
                    //System.out.println(auth.toString());
                    
                    stream.send(auth);
                    listener.loginMessage(SR.MS_AUTH);
                    return JabberBlockListener.BLOCK_PROCESSED;
                    
                }
//#endif

                if (mech.getChildBlockByText("PLAIN")!=null) {
                    auth.setAttribute("mechanism", "PLAIN");
                    String plain=
                            strconv.wCharToUTF(account.getJid())
                            +(char)0x00
                            +strconv.wCharToUTF(account.getUserName())
                            +(char)0x00
                            +strconv.wCharToUTF(account.getPassword());
                    auth.setText(strconv.toBase64(plain));
                    
                    stream.send(auth);
                    listener.loginMessage(SR.MS_AUTH);
                    return JabberBlockListener.BLOCK_PROCESSED;
                }
                // no more method found
                listener.loginFailed("SASL: Unknown mechanisms");
                return JabberBlockListener.NO_MORE_BLOCKS;
                
            } 
            // second stream - step 1. binding resource
            else if (data.getChildBlock("bind")!=null) {
                JabberDataBlock bindIq=new Iq(null, Iq.TYPE_SET, "bind");
                JabberDataBlock bind=bindIq.addChild("bind",null);
                bind.setNameSpace("urn:ietf:params:xml:ns:xmpp-bind");
                bind.addChild("resource", account.getResource());
                stream.send(bindIq);

                listener.loginMessage(SR.MS_RESOURCE_BINDING);
                
                return JabberBlockListener.BLOCK_PROCESSED;
            }
        } else if (data.getTagName().equals("challenge")) {
            // first stream - step 2,3. reaction to challenges
            
            String challenge=decodeBase64(data.getText());
            //System.out.println(challenge);
            
            JabberDataBlock resp=new JabberDataBlock("response", null, null);
            resp.setNameSpace("urn:ietf:params:xml:ns:xmpp-sasl");
            
            int nonceIndex=challenge.indexOf("nonce=");
                // first stream - step 2. generating DIGEST-MD5 response due to challenge
            if (nonceIndex>=0) {
                nonceIndex+=7;
                String nonce=challenge.substring(nonceIndex, challenge.indexOf('\"', nonceIndex));
                String cnonce="123456789abcd";
                
                resp.setText(responseMd5Digest(
                        strconv.wCharToUTF(account.getUserName()),
                        strconv.wCharToUTF(account.getPassword()),
                        account.getServer(),
                        "xmpp/"+account.getServer(),
                        nonce,
                        cnonce ));
                //System.out.println(resp.toString());
            }
                // first stream - step 3. sending second empty response due to second challenge
            //if (challenge.startsWith("rspauth")) {}
                
            stream.send(resp);
            return JabberBlockListener.BLOCK_PROCESSED;
        }
//#if ZLIB
        else if ( data.getTagName().equals("compressed")) {
            stream.setZlibCompression();
            try {
                stream.initiateStream(account.getServer(), true);
            } catch (IOException ex) { }
            return JabberBlockListener.NO_MORE_BLOCKS;
        }
        
//#endif
            
        else if ( data.getTagName().equals("failure")) {
            // first stream - step 4a. not authorized
            listener.loginFailed( data.getText() );  
        } else if ( data.getTagName().equals("success")) {
            // first stream - step 4b. success.
            try {
                stream.initiateStream(account.getServer(), true);
            } catch (IOException ex) { }
            return JabberBlockListener.NO_MORE_BLOCKS; // at first stream
        }

        if (data instanceof Iq) {
            if (data.getTypeAttribute().equals("result")) {
                // second stream - step 2. resource binded - opening session
                if (data.getAttribute("id").equals("bind")) {
                    //TODO: get assigned resource from result
                    JabberDataBlock session=new Iq(null, Iq.TYPE_SET, "sess");
                    session.addChild("session",null).setNameSpace("urn:ietf:params:xml:ns:xmpp-session");
                    stream.send(session);
                    listener.loginMessage(SR.MS_SESSION);
                    return JabberBlockListener.BLOCK_PROCESSED;
                    
                // second stream - step 3. session opened - reporting success login
                } else if (data.getAttribute("id").equals("sess")) {
                    listener.loginSuccess();
                    return JabberBlockListener.NO_MORE_BLOCKS;
                    //return JabberBlockListener.BLOCK_PROCESSED;
                }
            }
        }
        return JabberBlockListener.BLOCK_REJECTED;
    }
    
    private String decodeBase64(String src)  {
        int len=0;
        int ibuf=1;
        StringBuffer out=new StringBuffer();
        
        for (int i=0; i<src.length(); i++) {
            int nextChar = src.charAt(i);
            int base64=-1;
            if (nextChar>'A'-1 && nextChar<'Z'+1) base64=nextChar-'A';
            else if (nextChar>'a'-1 && nextChar<'z'+1) base64=nextChar+26-'a';
            else if (nextChar>'0'-1 && nextChar<'9'+1) base64=nextChar+52-'0';
            else if (nextChar=='+') base64=62;
            else if (nextChar=='/') base64=63;
            else if (nextChar=='=') {base64=0; len++;} else if (nextChar=='<') break;
            if (base64>=0) ibuf=(ibuf<<6)+base64;
            if (ibuf>=0x01000000){
                out.append( (char)((ibuf>>16) &0xff) );
                if (len<2) out.append( (char)((ibuf>>8) &0xff) );
                if (len==0) out.append( (char)(ibuf &0xff) );
                //len+=3;
                ibuf=1;
            }
        }
        return out.toString();
    }

    /**
     * This routine generates MD5-DIGEST response via SASL specification
     * @param user
     * @param pass
     * @param realm
     * @param digest_uri
     * @param nonce
     * @param cnonce
     * @return
     */
    private String responseMd5Digest(String user, String pass, String realm, String digestUri, String nonce, String cnonce) {

        MD5 hUserRealmPass=new MD5();
        hUserRealmPass.init();
        hUserRealmPass.updateASCII(user);
        hUserRealmPass.update((byte)':');
        hUserRealmPass.updateASCII(realm);
        hUserRealmPass.update((byte)':');
        hUserRealmPass.updateASCII(pass);
        hUserRealmPass.finish();
        
        MD5 hA1=new MD5();
        hA1.init();
        hA1.update(hUserRealmPass.getDigestBits());
        hA1.update((byte)':');
        hA1.updateASCII(nonce);
        hA1.update((byte)':');
        hA1.updateASCII(cnonce);
        hA1.finish();
        
        MD5 hA2=new MD5();
        hA2.init();
        hA2.updateASCII("AUTHENTICATE:");
        hA2.updateASCII(digestUri);
        hA2.finish();
        
        MD5 hResp=new MD5();
        hResp.init();
        hResp.updateASCII(hA1.getDigestHex());
        hResp.update((byte)':');
        hResp.updateASCII(nonce);
        hResp.updateASCII(":00000001:");
        hResp.updateASCII(cnonce);
        hResp.updateASCII(":auth:");
        hResp.updateASCII(hA2.getDigestHex());
        hResp.finish();
        
        String out = "username=\""+user+"\",realm=\""+realm+"\"," +
                "nonce=\""+nonce+"\",nc=00000001,cnonce=\""+cnonce+"\"," +
                "qop=auth,digest-uri=\""+digestUri+"\"," +
                "response=\""+hResp.getDigestHex()+"\",charset=utf-8";
        String resp = strconv.toBase64(out);
        //System.out.println(decodeBase64(resp));
        
        return resp;
    }
    
    
//#if SASL_XGOOGLETOKEN
    private String readLine(InputStream is) {
        StringBuffer buf = new StringBuffer();
        try {
            while(true) {
                int ch = is.read();
                if (ch==-1 || ch == '\n') break;
                buf.append((char)ch);
            }
        } catch (Exception e) {}
        return buf.toString();
    }
    
    /**
     * Generates X-GOOGLE-TOKEN response by communication with http://www.google.com
     * (algorithm from MGTalk/NetworkThread.java)
     * @param userName
     * @param passwd
     * @return
     */
    public String responseXGoogleToken() {
        try {
            String firstUrl = "https://www.google.com:443/accounts/ClientAuth?Email="
                    + strconv.wCharToUTF(account.getUserName()) + "%40"+ account.getServer()
                    + "&Passwd=" + strconv.wCharToUTF(account.getPassword()) 
                    + "&PersistentCookie=false&source=googletalk";
            
            //log.addMessage("Connecting to www.google.com");
            HttpConnection c = (HttpConnection) Connector.open(firstUrl.toString());
            InputStream is = c.openInputStream();
            
            
            String sid = readLine(is);
            if(!sid.startsWith("SID=")) {
                listener.loginFailed(sid);
                return null;
            }
            
            String lsid = readLine(is);
            
            String secondUrl = "https://www.google.com:443/accounts/IssueAuthToken?"
                    + sid + "&" + lsid + "&service=mail&Session=true";
            is.close();
            c.close();
            //log.addMessage("Next www.google.com connection");
            c = (HttpConnection) Connector.open(secondUrl);
            is = c.openInputStream();
            //str = readLine(dis);
            String token = "\0"+strconv.wCharToUTF(account.getUserName())+"\0"+readLine(is);
            is.close();
            c.close();
            return strconv.toBase64(token);
            
        } catch(Exception e) {
            e.printStackTrace();
            listener.loginFailed("Google token error");
        }
        return null;
    }
//#endif
    
}
/*
 * MessageItem.java
 *
 * Created on 21 Январь 2006 г., 23:17
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Messages;

import Client.Msg;
import images.RosterIcons;
import images.SmilesIcons;
import java.util.Enumeration;
import java.util.Vector;
import javax.microedition.lcdui.Graphics;
import ui.Colors;
import ui.ComplexString;
import ui.Time;
import ui.VirtualElement;
import ui.VirtualList;

/**
 *
 * @author Evg_S
 */
public class MessageItem implements 
	VirtualElement,
	MessageParser.MessageParserNotify
{
    
    Msg msg;
    Vector msgLines;
    private VirtualList view;
    private boolean even;
    private boolean smiles;
    private boolean partialParse=false;
    
    /** Creates a new instance of MessageItem */
    public MessageItem(Msg msg, VirtualList view, boolean showSmiles) {
	this.msg=msg;
	this.view=view;
        this.smiles=showSmiles;
    }

    public int getVHeight() { return msg.itemHeight; }
    
    public int getVWidth() { return 0; }
    
    public int getColorBGnd() {
        return (even)?
            Colors.LIST_BGND_EVEN:
            Colors.LIST_BGND;
    }
    
    public int getColor() { return msg.getColor(); }
    
    public void drawItem(Graphics g, int ofs, boolean selected) {
        /*if (selected)*/
        g.translate(1,0);
        if (msgLines==null) {
            MessageParser.getInstance().parseMsg(this, view.getListWidth(), smiles);
            return;
        }
        int y=0;
        for (Enumeration e=msgLines.elements(); e.hasMoreElements(); ) {
            ComplexString line=(ComplexString) e.nextElement();
            if (line.isEmpty()) break;
            int h=line.getVHeight();
            if (y>=0 && y<g.getClipHeight()) {
                if (msg.itemCollapsed) if (msgLines.size()>1) {
                    RosterIcons.getInstance().drawImage(g, RosterIcons.ICON_MSGCOLLAPSED_INDEX, 0,0);
                    g.translate(8,0); //FIXME: хардкод
                }
                line.drawItem(g, 0, selected);
            }
            g.translate(0, h);
            if (msg.itemCollapsed) break;
        }
    }
    
    public void onSelect() {
        msg.itemCollapsed=!msg.itemCollapsed;
        updateHeight();
        if (partialParse) {
            partialParse=false;
            MessageParser.getInstance().parseMsg(this, view.getListWidth(), smiles);
        }
    }
    
    byte repaintCounter;
    public void notifyRepaint(Vector v, Msg parsedMsg, boolean finalized) {
        msgLines=v;
        updateHeight();
        partialParse=!finalized;
        if (!finalized && !msg.itemCollapsed) if ((--repaintCounter)>=0) return;
        repaintCounter=5;
        view.redraw();
    }
    
    private void updateHeight() {
        int height=0;
        for (Enumeration e=msgLines.elements(); e.hasMoreElements(); ) {
            ComplexString line=(ComplexString) e.nextElement();
            height+=line.getVHeight();
            if (msg.itemCollapsed) break;
        }
        msg.itemHeight=height;
    }
    
    /*public void notifyUrl(String url) { 
        //if (urlList==null) urlList=new Vector();
        //urlList.addElement(url);
    }*/
    
    public Vector getUrlList() { 
        Vector urlList=new Vector();
        addUrls(msg.getBody(), urlList);
        return (urlList.size()==0)? null: urlList;
    }

    private void addUrls(String text, Vector urlList) {
        int pos=0;
        int len=text.length();
        while (pos<len) {
            int head=text.indexOf("http://", pos);
            if (head>=0) {
                pos=head;
                
                while (pos<len) {
                    char c=text.charAt(pos);
                    if (c==' ' || c==0x09 || c==0x0d || c==0x0a || c==0xa0 || c==')' )  
                        break;
                    pos++;
                }
                urlList.addElement(text.substring(head, pos));
                
            } else break;
        }
    }
    
    public void setEven(boolean even) {
        this.even = even;
    }

    public String getTipString() {
        if (Time.localTime() - msg.dateGmt> (24*60*60*1000)) return msg.getDayTime();
        return msg.getTime();
    }

    void toggleSmiles() {
        smiles=!smiles;
        MessageParser.getInstance().parseMsg(this, view.getListWidth(), smiles);    
    }
}
/*
 * MessageList.java
 *
 * Created on 11 Декабрь 2005 г., 3:02
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Messages;

import Client.Config;
import Client.Msg;
//import Messages.MessageView;
import images.SmilesIcons;
import java.util.Vector;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import locale.SR;
import ui.ComplexString;
import ui.VirtualElement;
import ui.VirtualList;

/**
 *
 * @author EvgS
 */
public abstract class MessageList 
    extends VirtualList
    implements CommandListener
{
    
    protected Vector messages;
    
    protected Command cmdBack = new Command(SR.MS_BACK, Command.BACK, 99);
    protected Command cmdUrl = new Command(SR.MS_GOTO_URL, Command.SCREEN, 80);

    protected Command cmdSmiles = new Command(SR.MS_SMILES_TOGGLE, Command.SCREEN, 50);
    
    /** Creates a new instance of MessageList */
  
    public MessageList() {
        super();
	messages=new Vector();
        smiles=Config.getInstance().smiles;
        //sd.config.updateTime();
    
	enableListWrapping(false);
	
        cursor=0;//activate
        
        addCommand(cmdSmiles);
        addCommand(cmdBack);
        addCommand(cmdUrl);
    }

    public MessageList(Display display) {
        this();
        attachDisplay(display);
    }
    
    
    public abstract int getItemCount(); // из protected сделали public

    protected VirtualElement getItemRef(int index) {
	if (messages.size()<getItemCount()) messages.setSize(getItemCount());
	MessageItem mi=(MessageItem) messages.elementAt(index);
	if (mi==null) {
	    mi=new MessageItem(getMessage(index), this, smiles);
            mi.setEven( (index & 1) == 0);
	    messages.setElementAt(mi, index);
	}
	return mi;
    }
    
    public abstract Msg getMessage(int index);
	//public Element getItemRef(int Index){ return (Element) contact.msgs.elementAt(Index); }

    // overriden, т.к. элементы списка - строки.
    /*public Object getFocusedObject(){
        try {
            return getMessage(cursor);
        } catch (Exception e) {}
        return null;
    }*/
    
    public void markRead(int msgIndex) {}
    
    protected boolean smiles;

    public void commandAction(Command c, Displayable d) {
        if (c==cmdBack) destroyView();
        if (c==cmdUrl) {
            try {
                Vector urls=((MessageItem) getFocusedObject()).getUrlList();
                new MessageUrl(display, urls); //throws NullPointerException if no urls
            } catch (Exception e) {/* no urls found */}
        }
        if (c==cmdSmiles) {
            try {
                ((MessageItem)getFocusedObject()).toggleSmiles();
            } catch (Exception e){}
        }
    }

    protected void keyPressed(int keyCode) { // overriding this method to avoid autorepeat
        super.keyPressed(keyCode);
        if (keyCode=='*') 
            try {
                ((MessageItem)getFocusedObject()).toggleSmiles();
            } catch (Exception e){}
    }

    public void keyGreen() { eventOk(); }
   
}
/*
 * SmileTree.java
 *
 * Created on 6 Февраль 2005 г., 19:38
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Messages;

import images.SmilesIcons;
import java.io.*;
import java.util.Vector;
import javax.microedition.lcdui.Font;

import ui.*;
import Client.Msg;
import Client.Config;
/**
 *
 * @author Eugene Stahov
 */
public final class MessageParser implements Runnable{
    
    private final static int URL=-2;
    private final static int NOSMILE=-1;
    private Vector smileTable;
    
    private Leaf root;

    // Singleton
    private static MessageParser instance=null;
    
    private int width; // window width
    
    private ImageList il;
    boolean enableSmiles;
    
    private Vector tasks=new Vector();
    
    private Thread thread;
    boolean wordsWrap;
    private static String wrapSeparators=" .,-=/\\;:+*()[]<>~!@#%^_&";
    
    public static MessageParser getInstance() {
        if (instance==null) instance=new MessageParser("/images/smiles.txt");
        return instance;
    }
    /**
     * Smile table loader
     * @param resource - path to smiles-description text file
     * @param smileTable - (result) Vector of smile's string-representations
     */
    
    public Vector getSmileTable() { return smileTable; }
    
    private class Leaf {
        public int Smile=NOSMILE;   // нет смайлика в узле
        public String smileChars;     // символы смайликов
        public Vector child;

        public Leaf() {
            child=new Vector();
            smileChars=new String();
        }
        
        public Leaf findChild(char c){
            int index=smileChars.indexOf(c);
            return (index==-1)?null:(Leaf)child.elementAt(index);
        }

        private void addChild(char c, Leaf child){
            this.child.addElement(child);
            smileChars=smileChars+c;
        }
    }
    
    private void addSmile(String smile, int index) {
	Leaf p=root;   // этой ссылкой будем ходить по дереву
	Leaf p1;
	
	int len=smile.length();
	for (int i=0; i<len; i++) {
	    char c=smile.charAt(i);
	    p1=p.findChild(c);
	    if (p1==null) {
		p1=new Leaf();
		p.addChild((char)c,p1);
	    }
	    p=p1;
	}
	p.Smile=index;
    }
    
    private MessageParser(String resource) {
        
        smileTable=new Vector();
        root=new Leaf();
        // opening file;
        try { // generic errors
            
            // счёт номера строки, он же номер смайла
            int strnumber=0;
            // вложение
            // int level=0; 
            boolean strhaschars=false;
            boolean endline=false;
            
            InputStream in=this.getClass().getResourceAsStream(resource);
            //DataInputStream f=new DataInputStream(in);
            
            StringBuffer s=new StringBuffer(10);
            boolean firstSmile=true;
            
            //try { // eof
                int c;
                while (true) {
                    c=in.read();
                    //System.out.println(c);
                    if (c<0) break;
                    switch (c) {
                        case 0x0d:
                        case 0x0a:
                            if (strhaschars) endline=true; else break;
                        case 0x09:
                        //case 0x20:
                            // конец строки смайлика
                            
			    String smile=s.toString();
                            if (firstSmile) smileTable.addElement(smile);
			    
			    addSmile(smile,strnumber);
			    
                            s.setLength(0);
                            //s=new StringBuffer(6);
                            firstSmile=false;
                            
                            break;
                        default:
                            s.append((char)c);
                            strhaschars=true;
                    }
                    if (endline) {
                        endline=strhaschars=false;
                        strnumber++;
                        firstSmile=true;
                    }
                }
            //} catch (Exception e) { /* неправильный файл смайлов */ }
            in.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
	addSmile("http://",URL);
    }

    public void parseMsg(MessageItem messageItem,  int width, boolean smiles)
    {
	wordsWrap=Config.getInstance().textWrap==1;
        messageItem.msgLines=new Vector();
        this.il=(smiles)? SmilesIcons.getInstance() : null;
        this.width=width;
        this.enableSmiles=smiles;
        
        synchronized (tasks) {
            tasks.addElement(messageItem);
            if (thread==null) {
                thread=new Thread(this);
                thread.setPriority(Thread.MAX_PRIORITY);
                thread.start();
            }
        }
        return;
    }
    
    public void run() {
        while(true) {
            
            MessageItem task=null;
            synchronized (tasks) {
                if (tasks.size()==0) {
                    thread=null;
                    return;
                }
                task=(MessageItem) tasks.lastElement();
                tasks.removeElement(task);
            }
            parseMessage(task);
        }
    }

    private void parseMessage(final MessageItem task) {
        
        Vector lines=task.msgLines;
        boolean singleLine=task.msg.itemCollapsed;
        
        //boolean noWrapSpace=false;
        boolean underline=false;
        
        int state=0;
        if (task.msg.subject==null) state=1;
        while (state<2) {
            int w=0;
            StringBuffer s=new StringBuffer();
	    int wordWidth=0;
	    int wordStartPos=0;
            
            ComplexString l=new ComplexString(il);
            lines.addElement(l);
            
            Font f=(task.msg.isHighlited())? FontCache.getMsgFontBold(): FontCache.getMsgFont();
            l.setFont(f);
            
            String txt=(state==0)? task.msg.subject: task.msg.toString();
            
            int color=(state==0)?
                Colors.MSG_SUBJ:
                Colors.LIST_INK;
            l.setColor(color);
           
            if (txt==null) {
                state++;
                continue;
            }
            
            int pos=0;
            while (pos<txt.length()) {
                Leaf smileLeaf=root;
                int smileIndex=-1;
                int smileStartPos=pos;
                int smileEndPos=pos;
                
                while (pos<txt.length()) {
                    char c=txt.charAt(pos);
                    
                    if (underline) {
                        switch (c) {
                            case ' ':
                            case 0x09:
                            case 0x0d:
                            case 0x0a:
                            case 0xa0:
                            case ')':
                                underline=false;
                                if (wordStartPos!=pos) {
                                    s.append(txt.substring(wordStartPos,pos));
                                    wordStartPos=pos;
				    w+=wordWidth;
                                    wordWidth=0;
                                }
                                if (s.length()>0) {
                                    l.addUnderline();
                                    l.addElement(s.toString());
                                }
                                s.setLength(0);
                        }
                        break; // не смайл
                    }
                    
                    smileLeaf=smileLeaf.findChild(c);
                    if (smileLeaf==null) {
                        break;    //этот символ c не попал в смайл
                    }
                    if (smileLeaf.Smile!=-1) {
                        // нашли смайл
                        smileIndex=smileLeaf.Smile;
                        smileEndPos=pos;
                    }
                    pos++; // продолжаем поиск смайла
                    
                } //while (i<txt.length())
                
                if (smileIndex==URL) {
                    if (s.length()>0) l.addElement(s.toString());
                    s.setLength(0);
                    underline=true;
                }
                
                if (smileIndex>=0 && enableSmiles) {
                    // есть смайлик
                    
                    // слово перед смайлом в буфер
 		    if (wordStartPos!=smileStartPos) {
 			s.append(txt.substring(wordStartPos, smileStartPos));
                        w+=wordWidth;
                        wordWidth=0;
 		    }
                    // добавим строку
                    if (s.length()>0) {
                        if (underline) l.addUnderline();
                        l.addElement(s.toString());
                    }
                    // очистим
                    s.setLength(0);
                    // добавим смайлик
                    int iw=il.getWidth();
                    if (w+iw>width) {
                        task.notifyRepaint(lines, task.msg, false);
                        l=new ComplexString(il);     // новая строка
                        lines.addElement(l);    // добавим l в v
                        
                        if (singleLine) {
                            return;
                        }
                        
                        l.setColor(color);
                        l.setFont(f);
                        w=0;
                    }
                    l.addImage(smileIndex); w+=iw;
                    // передвинем указатель
                    pos=smileEndPos;
		    // next word will start after smile
		    wordStartPos=pos+1;
                } else {
                    pos=smileStartPos;
                    char c=txt.charAt(pos);
                    
                    int cw=f.charWidth(c);
                    if (c!=0x20) {
                        boolean newline= ( c==0x0d || c==0x0a /*|| c==0xa0*/ );
			if (wordWidth+cw>width || newline) {
			    // Add current oneWord buffer to s because:
			    // word is too long to fit in line or character is newline

			    s.append(txt.substring(wordStartPos,pos));
			    w+=wordWidth;
			    wordWidth=0;
			    wordStartPos=pos;
                            if (newline) wordStartPos++;
			}
                        if (w+wordWidth+cw>width || newline) {
                            if (underline) l.addUnderline();
                            l.addElement(s.toString());    // последняя подстрока в l
                            s.setLength(0); w=0;
                            
                            if (c==0xa0) l.setColor(Colors.MSG_HIGHLIGHT);
                            
                            l=new ComplexString(il);     // новая строка
                            lines.addElement(l);    // добавим l в v
                            task.notifyRepaint(lines, task.msg, false);

                            if (singleLine) {
                                return;
                            }
                            
                            l.setColor(color);
                            l.setFont(f);
                        }
                    }
		    if (c==0x09)
			c=0x20;
		    	    
                    if (c>0x1f) {
			wordWidth+=cw;
		    }
		    if (wrapSeparators.indexOf(c)>=0 || !wordsWrap) {
			if (pos>wordStartPos) 
                            s.append(txt.substring(wordStartPos,pos));
			s.append(c);
			w+=wordWidth;
			wordStartPos=pos+1;
			wordWidth=0;
		    }
                }
                pos++;
            }
	    if (wordStartPos!=pos)
		s.append(txt.substring(wordStartPos,pos));
            if (s.length()>0) {
                if (underline) {
                    l.addUnderline();
                }
                l.addElement(s.toString());
            }
            
            if (l.isEmpty()) lines.removeElementAt(lines.size()-1);  // последняя строка
            
            task.notifyRepaint(lines, task.msg, true);
            state++;
        }
    }

    public interface MessageParserNotify {
        void notifyRepaint(Vector v, Msg parsedMsg, boolean finalized);
	//void notifyUrl(String url);
    }
}
/*
 * MessageUrl.java
 *
 * Created on 22 Декабрь 2005 г., 3:01
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Messages;

import java.util.Vector;
import javax.microedition.io.ConnectionNotFoundException;
import javax.microedition.lcdui.Display;
import midlet.Bombus;
import ui.Menu;

/**
 *
 * @author EvgS
 */
public class MessageUrl extends Menu{
    
    private Vector urlList;
    /** Creates a new instance of MessageUrl */
    public MessageUrl(Display display, Vector urlList) {
	super("URLs");
	this.urlList=urlList;
	
	for (int i=0; i<urlList.size(); i++) { // throws exception
	    addItem((String)urlList.elementAt(i), i);
	}
	/*if (m.getItemCount()>0)*/
	attachDisplay(display);
    }
    
    public void eventOk() {
	String url=(String)urlList.elementAt(cursor);
//#if !(MIDP1)
	try {
	    Bombus.getInstance().platformRequest(url);
	} catch (Exception e) { e.printStackTrace(); }
//#endif
	destroyView();
    }
}
/*
 * MessageView.java
 *
 * Created on 20 Февраль 2005 г., 17:42
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package Messages;
import Client.*;
import images.RosterIcons;
import images.SmilesIcons;
import locale.SR;
import ui.*;
import javax.microedition.lcdui.*;
import java.util.*;

/**
 *
 * @author Eugene Stahov
 */
public class MessageView 
        extends ComplexStringList 
        implements 
            CommandListener, 
            Runnable
{

    int titlecolor; // зависит от типа сообщения
    boolean smiles;
    Thread t=null;
    
    Command cmdBack=new Command(SR.MS_BACK,Command.BACK,99);
    Command cmdTSM=new Command(SR.MS_SMILES_TOGGLE, Command.SCREEN,1);

    Command cmdSubscr=new Command(SR.MS_SUBSCRIBE /*"Authorize"*/, Command.SCREEN,2);
//#if !(MIDP1) 
    Command cmdUrl=new Command(SR.MS_GOTO_URL, Command.SCREEN,3);
//#endif

    private MessageList msglist;

    public int getTitleBGndRGB() {return 0x338888;} 
    public int getTitleRGB() {return titlecolor;} 
    
    int repaintCounter=5;
    
    private Vector urlList;
    
    public void keyLeft(){
        if (win_top==0) changeMsg(-1); else super.keyLeft();
    }
    
    public void keyRight(){
        if (atEnd) changeMsg(1); else super.keyRight();
    }
    
    private void changeMsg(int offset){
        int nextMsg=msgIndex+offset;
        if (nextMsg<0 || nextMsg>=nMsgs) return;
        msgIndex=nextMsg;
        lines=null;
        win_top=0;
        (t=new Thread(this)).start();
    }
    
    int msgIndex;
    Msg msg;
    int nMsgs;
   
    StaticData sd;
    
    public void run() {
//#if !(MIDP1)       
	removeCommand(cmdUrl);
//#endif
	urlList=null;
	
        msg=msglist.getMessage(msgIndex);

	msglist.markRead(msgIndex);

        titlecolor=msg.getColor();
        ComplexString title=new ComplexString(RosterIcons.getInstance());
        title.addElement(msg.getMsgHeader());
        title.addRAlign();
        title.addElement(null);
        setTitleItem(title);
        
        if (msg.messageType==Msg.MESSAGE_TYPE_AUTH) addCommand(cmdSubscr);
        else removeCommand(cmdSubscr);
        //if (msg.photo!=null) addCommand(cmdPhoto);
        //else removeCommand(cmdPhoto);
        
        //win_top=0;

        MessageParser.getInstance().parseMsg(
null,                                                 getWidth()-6, smiles);
    }

    protected void beginPaint(){
        int micon=0;
        if (msglist==null) return;
        if (title==null) return;
        
        nMsgs=msglist.getItemCount();
        if (nMsgs>1) {
            if (msgIndex==0) micon=1;
            if (msgIndex==nMsgs-1) micon=2;
            getTitleItem().setElementAt(new Integer(RosterIcons.ICON_MESSAGE_BUTTONS+micon),2);
        }
    }
    /** Creates a new instance of MessageView */
    public MessageView(Display display, int msgIndex, MessageList msglist) {
        super(display);
	
	enableListWrapping(false);

        sd=StaticData.getInstance();
        smiles=Config.getInstance().smiles;
        this.msgIndex=msgIndex;
        this.msglist=msglist;

        addCommand(cmdBack);
        addCommand(cmdTSM);
        setCommandListener(this);
        
        (t=new Thread(this)).start();

    }
    public void eventOk(){
        destroyView();
        if (msglist.getItemCount()>1)
        ((VirtualList)parentView).moveCursorTo(msgIndex, true);
    }
    
    public void commandAction(Command c, Displayable d){
        if (c==cmdBack) {
            eventOk();
            return;
        }
        if (c==cmdSubscr) {
            Jid j=new Jid(msg.from);
            sd.roster.sendPresence(j.getJid(), "subscribe", null);
            sd.roster.sendPresence(j.getJid(), "subscribed", null);
            msg.messageType=Msg.MESSAGE_TYPE_IN;
            destroyView();
        }
        if (c==cmdTSM) toggleSmiles();
//#if !(MIDP1)       
	if (c==cmdUrl) new MessageUrl(display, urlList);
//#endif
        //if (c==cmdPhoto) new PhotoView(display, msg.photo);
    }
    
    public void userKeyPressed(int KeyCode){
        if (KeyCode==KEY_STAR) toggleSmiles();
    }

    protected void keyGreen(){
	msglist.keyGreen();
    }
    
    private void toggleSmiles(){
        smiles=!smiles;
        while (t.isAlive());
        (t=new Thread(this)).start();
    }

    public void notifyUrl(String url) {
//#if !(MIDP1)       
	if (urlList==null) urlList=new Vector();
	urlList.addElement(url);
	addCommand(cmdUrl);
//#endif
    }
}

/*
 * Bombus.java
 *
 * Created on 5 Январь 2005 г., 21:46
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

/**
 *
 * @author Eugene Stahov
 */
package midlet;

import javax.microedition.midlet.*;
import javax.microedition.lcdui.*;
import locale.SR;

import ui.*;

import Client.*;
import Info.Version;


/** Entry point class
 *
 * @author  Eugene Stahov
 * @version
 */
public class Bombus extends MIDlet implements Runnable{
    
    private Display display;    // The display for this MIDlet
    private boolean isRunning;
    private boolean isMinimized;
    StaticData sd;
    
    public static Image programIcon;
    public static Image splash;
    //IconTextList l;
    
    private static Bombus instance; 
        
    /** Bombus constructor. starts splashscreen */
    public Bombus() {
	instance=this; 
        display = Display.getDisplay(this);
        SplashScreen s= SplashScreen.getInstance();
        display.setCurrent(s);
        s.setProgress(/*SR.MS_LOADING*/ "Loading",3); // this message will not be localized
        sd=StaticData.getInstance();
    }
    
    /** Entry point  */
    public void startApp() {
        
        if (isRunning) {
	    hideApp(false);
            return;
        }
        
        isRunning=true;

        new Thread(this).start();
    }
    
    
    /**
     * Pause is a no-op since there are no background activities or
     * record stores that need to be closed.
     */
    public void pauseApp() { }

    public void run(){
        
        SplashScreen s= SplashScreen.getInstance();
        s.setProgress(5);
        
        
        try {
            s.img=Image.createImage("/images/splash.png");
            
            if (Version.getPlatformName().startsWith("Nokia")) {
                splash=s.img;
                programIcon=Image.createImage("/_icon.png");
            }
            
            s.setProgress("Bombus "+Version.version,7);
        } catch (Exception e) {
            e.printStackTrace();
        }

        s.setProgress(10);
	Config cf=Config.getInstance();

	s.setProgress(17);
        boolean selAccount=( (cf.accountIndex<0) || s.keypressed!=0);
        if (selAccount) s.setProgress("Entering setup",20);

        s.setProgress(23);
        sd.roster=new Roster(display);
        
        if (!selAccount) {
            // connect whithout account select
	    boolean autologin=cf.autoLogin;
            selAccount=(Account.loadAccount(autologin)==null);
	    if (!autologin) s.close();
        }
        if (selAccount) { new AccountSelect(display, true); }
    }
    
    /**
     * Destroy must cleanup everything not handled by the garbage collector.
     * In this case there is nothing to cleanup.
     */
    public void destroyApp(boolean unconditional) {
    }

    public void hideApp(boolean hide) {
	if (hide) {
	    display.setCurrent(null);
	} else {
            if (isMinimized) {
                display.setCurrent(sd.roster);
            }
	}
        isMinimized=hide;
    }
    
    public static Bombus getInstance() {
        return instance;
    }
  
}
/*
 * PrivacyForm.java
 *
 * Created on 11 Сентябрь 2005 г., 2:32
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package PrivacyLists;
import Client.*;
import javax.microedition.lcdui.*;
import java.util.*;
import locale.SR;
import ui.ConstMIDP;

/**
 *
 * @author EvgS
 */
public class PrivacyForm
        implements
        CommandListener,
        ItemStateListener {
    
    private Display display;
    private Displayable parentView;
    private PrivacyItem item;
    
    private PrivacyList targetList;
    
    Form form=new Form(SR.MS_PRIVACY_RULE);
    ChoiceGroup choiceAction=new ChoiceGroup(SR.MS_PRIVACY_ACTION, ConstMIDP.CHOICE_POPUP, PrivacyItem.actions, null);
    ChoiceGroup choiseType=new ChoiceGroup(SR.MS_PRIVACY_TYPE, ConstMIDP.CHOICE_POPUP, PrivacyItem.types, null);
    ChoiceGroup choiseStanzas=new ChoiceGroup(SR.MS_STANZAS, ChoiceGroup.MULTIPLE, PrivacyItem.stanzas, null);
    TextField textValue;
    //TextField textOrder;
    ChoiceGroup choiceSubscr=new ChoiceGroup(SR.MS_SUBSCRIPTION, ConstMIDP.CHOICE_POPUP, PrivacyItem.subscrs, null);
    
    Command cmdCancel=new Command(SR.MS_CANCEL, Command.BACK, 99);
    Command cmdOk=new Command(SR.MS_OK, Command.OK, 1);
    /** Creates a new instance of PrivacyForm */
    public PrivacyForm(Display display, PrivacyItem item, PrivacyList plist) {
        this.display=display;
        parentView=display.getCurrent();
        this.item=item;
        targetList=plist;
        
        textValue=new TextField(null, item.value, 64, TextField.URL);
        
        form.append(choiceAction);
        choiceAction.setSelectedIndex(item.action, true);
        
        form.append(choiseType);
        
        form.append(textValue);
        choiseType.setSelectedIndex(item.type, true);
        switchType();
        
        form.append(choiseStanzas);
        choiseStanzas.setSelectedFlags(item.stanzasSet);
        
        //form.append("Order: "+item.order);
        
        form.setItemStateListener(this);
        form.setCommandListener(this);
        form.addCommand(cmdOk);
        form.addCommand(cmdCancel);
        display.setCurrent(form);
        
    }
    
    private void switchType() {
        int index=choiseType.getSelectedIndex();
        try {
            Object rfocus=StaticData.getInstance().roster.getFocusedObject();
            switch (index) {
                case 0: //jid
                    if (targetList!=null) if (rfocus instanceof Contact) {
                        textValue.setString(((Contact)rfocus).getBareJid());
                    }
                    form.set(2, textValue);
                    break;
                case 1: //group
                    if (targetList!=null) textValue.setString( ( (rfocus instanceof Group)?
                        (Group)rfocus : 
                        ((Contact)rfocus).getGroup()
                        ).getName());

                    form.set(2, textValue);
                    break;
                case 2: //subscription
                    form.set(2, choiceSubscr);
                    break;
                    
                case 3:
                    form.set(2, new StringItem(null,"(ANY)"));
            }
            /*if (index==2) {
                form.set(2, choiceSubscr);
            } else {
                textValue.setLabel(PrivacyItem.types[index]);
                form.set(2, textValue);
            }
             */
        } catch (Exception e) {/* При смене на самого себя */ }
    }
    
    public void commandAction(Command c, Displayable d) {
        if (c==cmdCancel) { destroyView(); return; }
        if (c==cmdOk) {
            try {
                int type=choiseType.getSelectedIndex();
                String value=textValue.getString();
                if (type==2) value=PrivacyItem.subscrs[choiceSubscr.getSelectedIndex()];
                if (type!=PrivacyItem.ITEM_ANY) 
                if (value.length()==0) return;
                //int order=Integer.parseInt(textOrder.getString());
                
                item.action=choiceAction.getSelectedIndex();
                item.type=type;
                item.value=value;
                //item.order=order;
                choiseStanzas.getSelectedFlags(item.stanzasSet);
                
                if (targetList!=null) 
                    if (!targetList.rules.contains(item)) {
                        targetList.addRule(item);
                        item.order=targetList.rules.indexOf(item)*10;
                    }
                destroyView();
            } catch (Exception e) {e.printStackTrace();}
        }
    }
    
    public void itemStateChanged(Item item){
        if (item==choiseType) switchType();
    }
    
    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView);
    }
}
/*
 * PrivacyItem.java
 *
 * Created on 10 Сентябрь 2005 г., 21:30
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package PrivacyLists;
import images.RosterIcons;
import ui.*;
import com.alsutton.jabber.*;
import Client.*;

/**
 *
 * @author EvgS
 */
public class PrivacyItem extends IconTextElement{
    
    public final static String types[]={"jid", "group", "subscription", "ANY"};
    public final static int ITEM_JID=0;
    public final static int ITEM_GROUP=1;
    public final static int ITEM_SUBSCR=2;
    public final static int ITEM_ANY=3;

    public final static String actions[]={"allow", "deny"};
    public final static int ITEM_ALLOW=0;
    public final static int ITEM_BLOCK=1;

    public final static String stanzas[]={"message", "presence-in", "presence-out", "iq"};
    public final static int STANZA_MSG=0;
    public final static int STANZA_PRESENCE_IN=1;
    public final static int STANZA_PRESENCE_OUT=2;
    public final static int STANZA_IQ=3;
    
    public final static String subscrs[]={"none", "from", "to", "both"};
    
    int type;    //jid|group|subscription|ANY
    String value=new String();
    int action=1;
    int order;
    boolean stanzasSet[]=new boolean[4];
    
    public int getImageIndex(){
        return action+ RosterIcons.ICON_PRIVACY_ALLOW;
    }
    
    public int getColor() { return Colors.LIST_INK; }
    
    public String toString() { return (type==ITEM_ANY)?"ANY":value; }
    
    /** Creates a new instance of PrivacyItem */
    public PrivacyItem() {
        super(RosterIcons.getInstance());
    }
    
    public PrivacyItem(JabberDataBlock item) {
        this();
        String t=item.getTypeAttribute();
        if (t==null) type=ITEM_ANY;
        else 
            for (type=0; type<2; type++) 
                if (t.equals(types[type])) break;
        value=item.getAttribute("value");
        action=item.getAttribute("action").equals("allow")?0:1;
        order=Integer.parseInt(item.getAttribute("order"));
        int index;
        for (index=0; index<4; index++) {
            if (item.getChildBlock(stanzas[index])!=null) stanzasSet[index]=true;
        }
    }
    
    public static PrivacyItem itemIgnoreList(){
        PrivacyItem item=new PrivacyItem();
        item.type=ITEM_GROUP;
        item.value=Groups.IGNORE_GROUP;
        item.stanzasSet[STANZA_IQ]=true;
        item.stanzasSet[STANZA_PRESENCE_OUT]=true;
        return item;
    }
    
    public JabberDataBlock constructBlock() {
        JabberDataBlock item=new JabberDataBlock("item", null, null);
        if (type!=ITEM_ANY) {
            item.setTypeAttribute(types[type]);
            item.setAttribute("value", value);
        }
        item.setAttribute("action", actions[action] );
        item.setAttribute("order", String.valueOf(order));
        int index;
        for (index=0; index<4; index++) {
            if (stanzasSet[index]) item.addChild(stanzas[index], null);
        }
        return item;
    }
}
/*
 * PrivacyList.java
 *
 * Created on 26 Август 2005 г., 23:08
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package PrivacyLists;
import com.alsutton.jabber.datablocks.Iq;
import images.RosterIcons;
import java.util.*;
import com.alsutton.jabber.*;
import ui.*;
import Client.*;
import com.alsutton.jabber.*;

/**
 *
 * @author EvgS
 */
public class PrivacyList extends IconTextElement{
    
    String name;
    boolean isActive;
    boolean isDefault;
    
    Vector rules=new Vector(); 
    
    /** Creates a new instance of PrivacyList */
    public PrivacyList(String name) {
        super(RosterIcons.getInstance());
        this.name=name;
    }
    
    public int getImageIndex() {return (isActive)?
        RosterIcons.ICON_PRIVACY_ACTIVE:
        RosterIcons.ICON_PRIVACY_PASSIVE; }
    public int getColor() {return Colors.LIST_INK; }
    
    public String toString() {
        StringBuffer result=new StringBuffer((name==null)? "<none>": name);
        result.append(' ');
        if (isDefault) result.append("(default)");
        return result.toString();
    }
    
    
    public void generateList(){
        int index=0;
        
        JabberDataBlock list = listBlock();
        for (Enumeration e=rules.elements(); e.hasMoreElements(); ) {
            
            PrivacyItem item=(PrivacyItem)e.nextElement();
            item.order=index++;
                        
            list.addChild( item.constructBlock() );
        }
        PrivacyList.privacyListRq(true, list, "storelst");
    }

    private JabberDataBlock listBlock() {
        JabberDataBlock list=new JabberDataBlock("list", null, null);
        list.setAttribute("name", name);
        return list;
    }
    
    public void deleteList(){
        JabberDataBlock list=listBlock();
        PrivacyList.privacyListRq(true, list, "storelst");
    }
  
    public void activate (String atr) {
        JabberDataBlock a=new JabberDataBlock(atr, null, null);
        a.setAttribute("name", name);
        privacyListRq(true, a, "plset");
    }
    
    public void addRule(PrivacyItem rule) {
        int index=0;
        while (index<rules.size()) {
            if ( rule.order <= ((PrivacyItem)rules.elementAt(index)).order ) break;
            index++;
        }
        rules.insertElementAt(rule, index);
    }
    
    public final static void privacyListRq(boolean set, JabberDataBlock child, String id){
        JabberDataBlock pl=new Iq(null, (set)? Iq.TYPE_SET: Iq.TYPE_GET, id);
        JabberDataBlock qry=pl.addChild("query", null);
        qry.setNameSpace("jabber:iq:privacy");
        if (child!=null) qry.addChild(child);
        
        //System.out.println(pl);
        StaticData.getInstance().roster.theStream.send(pl);
    }
}
/*
 * PrivacyModifyList.java
 *
 * Created on 11 Сентябрь 2005 г., 15:51
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package PrivacyLists;

import Client.Roster;
import Client.StaticData;
import Client.Title;
import images.RosterIcons;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.*;
import java.util.*;
import com.alsutton.jabber.*;

/**
 *
 * @author EvgS
 */
public class PrivacyModifyList 
        extends VirtualList 
        implements CommandListener,
        JabberBlockListener
{
    private PrivacyList plist;
    
    private Command cmdCancel=new Command (SR.MS_CANCEL, Command.BACK, 99);
    private Command cmdAdd=new Command (SR.MS_ADD_RULE, Command.SCREEN, 10);
    private Command cmdDel=new Command (SR.MS_DELETE_RULE, Command.SCREEN, 11);
    private Command cmdEdit=new Command (SR.MS_EDIT_RULE, Command.SCREEN, 12);
    private Command cmdUp=new Command (SR.MS_MOVE_UP, Command.SCREEN, 13);
    private Command cmdDwn=new Command (SR.MS_MOVE_DOWN, Command.SCREEN, 14);
    private Command cmdSave=new Command (SR.MS_SAVE_LIST, Command.SCREEN, 16);
    
    JabberStream stream=StaticData.getInstance().roster.theStream;
    
    /** Creates a new instance of PrivacySelect */
    public PrivacyModifyList(Display display, PrivacyList privacyList) {
        super(display);
        setTitleItem(new Title(2, null, SR.MS_PRIVACY_LISTS));
        addCommand(cmdCancel);
        addCommand(cmdEdit);
        addCommand(cmdAdd);
        addCommand(cmdDel);
        addCommand(cmdUp);
        addCommand(cmdDwn);
        addCommand(cmdSave);
        
        setCommandListener(this);

        plist=privacyList;
        getList();
    }
    
    private void processIcon(boolean processing){
        getTitleItem().setElementAt((processing)?(Object)new Integer(RosterIcons.ICON_PROGRESS_INDEX):(Object)null, 0);
        redraw();
    }

    private void getList(){
        processIcon(true);
        stream.addBlockListener(this);
        JabberDataBlock list=new JabberDataBlock("list", null, null);
        list.setAttribute("name", plist.name);
        PrivacyList.privacyListRq(false, list, "getlistitems");
    }
    
    protected int getItemCount() { return plist.rules.size(); }
    protected VirtualElement getItemRef(int index) { return (VirtualElement) plist.rules.elementAt(index); }
    
    public void commandAction(Command c, Displayable d) {
        if (c==cmdCancel) {
            stream.cancelBlockListener(this);
            destroyView();
        }
        if (c==cmdAdd) {
            new PrivacyForm(display, new PrivacyItem(), plist);
        }
        if (c==cmdEdit) eventOk();
        if (c==cmdDel) {
            Object del=getFocusedObject();
            if (del!=null) plist.rules.removeElement(del);
        }
        if (c==cmdSave) {
            plist.generateList();
            stream.cancelBlockListener(this);
            PrivacyList.privacyListRq(false, null, "setplists");
            destroyView();
        }
        
        if (c==cmdUp) { move(-1); keyUp(); }
        if (c==cmdDwn) { move(+1); keyDwn(); }
        redraw();
    }
    
    public void move(int offset){
        try {
            int index=cursor;
            PrivacyItem p1=(PrivacyItem)plist.rules.elementAt(index);
            PrivacyItem p2=(PrivacyItem)plist.rules.elementAt(index+offset);
            
            plist.rules.setElementAt(p1, index+offset);
            plist.rules.setElementAt(p2, index);
            
            int tmpOrder=p1.order;
            p1.order=p2.order;
            p2.order=tmpOrder;
            
        } catch (Exception e) {/* IndexOutOfBounds */}
    }

    public void eventOk(){
        PrivacyItem pitem=(PrivacyItem) getFocusedObject();
        if (pitem!=null) {
            new PrivacyForm(display, pitem, null);
        }
    }
    
    public int blockArrived(JabberDataBlock data){
        if (data.getTypeAttribute().equals("result"))
            if (data.getAttribute("id").equals("getlistitems")) {
                data=data.findNamespace("jabber:iq:privacy");
                try {
                    data=data.getChildBlock("list");
                    plist.rules=new Vector();
                    for (Enumeration e=data.getChildBlocks().elements(); e.hasMoreElements();) {
                        JabberDataBlock item=(JabberDataBlock) e.nextElement();
                        plist.addRule(new PrivacyItem(item));
                    }
                } catch (Exception e) {}
                
                processIcon(false);
                return JabberBlockListener.NO_MORE_BLOCKS;
            } //id, result
        return JabberBlockListener.BLOCK_REJECTED;
    }

}
/*
 * PrivacySelect.java
 *
 * Created on 26 Август 2005 г., 23:04
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package PrivacyLists;

import Client.Groups;
import Client.Roster;
import Client.StaticData;
import Client.Title;
import images.RosterIcons;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.*;
import java.util.*;
import com.alsutton.jabber.*;

/**
 *
 * @author EvgS
 */
public class PrivacySelect 
        extends VirtualList 
        implements CommandListener,
        JabberBlockListener,
        MIDPTextBox.TextBoxNotify
{
    private Vector list=new Vector();
    
    private Command cmdCancel=new Command (SR.MS_BACK, Command.BACK, 99);
    private Command cmdActivate=new Command (SR.MS_ACTIVATE, Command.SCREEN, 10);
    private Command cmdDefault=new Command (SR.MS_SETDEFAULT, Command.SCREEN, 11);
    private Command cmdNewList=new Command (SR.MS_NEW_LIST, Command.SCREEN, 12);
    private Command cmdDelete=new Command (SR.MS_DELETE_LIST, Command.SCREEN, 13);
    //private Command cmdEdit=new Command (SR.MS_EDIT_LIST, Command.SCREEN, 14);
    private Command cmdIL=new Command (SR.MS_MK_ILIST, Command.SCREEN, 16);
    
    JabberStream stream=StaticData.getInstance().roster.theStream;
    
    /** Creates a new instance of PrivacySelect */
    public PrivacySelect(Display display) {
        super(display);
        
        setTitleItem(new Title(2, null, SR.MS_PRIVACY_LISTS));
        addCommand(cmdActivate);
        addCommand(cmdDefault);
        addCommand(cmdCancel);
        addCommand(cmdNewList);
        addCommand(cmdDelete);
        //addCommand(cmdEdit);
        addCommand(cmdIL);
        setCommandListener(this);
        list.addElement(new PrivacyList(null));//none
        
        getLists();
    }

    private void processIcon(boolean processing){
        getTitleItem().setElementAt((processing)?(Object)new Integer(RosterIcons.ICON_PROGRESS_INDEX):(Object)null, 0);
        redraw();
    }
   
    private void getLists(){
        stream.addBlockListener(this);
        processIcon(true);
        PrivacyList.privacyListRq(false, null, "getplists");
    }
    
    protected int getItemCount() { return list.size(); }
    protected VirtualElement getItemRef(int index) { return (VirtualElement) list.elementAt(index); }
    public void commandAction(Command c, Displayable d) {
        if (c==cmdCancel) {
            destroyView();
            stream.cancelBlockListener(this);
        }
        if (c==cmdActivate || c==cmdDefault) {
            PrivacyList active=((PrivacyList)getFocusedObject());
            for (Enumeration e=list.elements(); e.hasMoreElements(); ) {
                PrivacyList pl=(PrivacyList)e.nextElement();
                boolean state=(pl==active);
                if (c==cmdActivate) pl.isActive=state; else pl.isDefault=state;
            }
            ((PrivacyList)getFocusedObject()).activate( (c==cmdActivate)? "active":"default" ); 
            getLists();
        }
        if (c==cmdIL) {
            generateIgnoreList();
            //new PrivacyForm(display, PrivacyItem.itemIgnoreList());
            getLists();
        }
        if (c==cmdDelete) {
            PrivacyList pl=(PrivacyList) getFocusedObject();
            if (pl!=null) {
                if (pl.name!=null) pl.deleteList();
                getLists();
            }
        }
        if (c==cmdNewList) new MIDPTextBox(display, "New list name", "", this, TextField.URL);
    }
    
    // MIDPTextBox interface
    public void OkNotify(String listName) {
        if (listName.length()>0) (new PrivacyModifyList(display, new PrivacyList(listName))).setParentView(parentView);
    }
    
    public int blockArrived(JabberDataBlock data){
        try {
            if (data.getTypeAttribute().equals("result"))
                if (data.getAttribute("id").equals("getplists")) {
                data=data.findNamespace("jabber:iq:privacy");
                if (data!=null) {
                    list=new Vector();
                    String activeList="";
                    String defaultList="";
                    try {
                        for (Enumeration e=data.getChildBlocks().elements(); e.hasMoreElements();) {
                            JabberDataBlock pe=(JabberDataBlock) e.nextElement();
                            String tag=pe.getTagName();
                            String name=pe.getAttribute("name");
                            if (tag.equals("active")) activeList=name;
                            if (tag.equals("default")) defaultList=name;
                            if (tag.equals("list")) {
                                PrivacyList pl=new PrivacyList(name);
                                pl.isActive=(name.equals(activeList));
                                pl.isDefault=(name.equals(defaultList));
                                list.addElement(pl);
                            }
                        }
                    } catch (Exception e) {}
                    PrivacyList nullList=new PrivacyList(null);
                    nullList.isActive=activeList.length()==0;
                    nullList.isDefault=defaultList.length()==0;
                    list.addElement(nullList);//none
                }
                
                processIcon(false);
                
                return JabberBlockListener.NO_MORE_BLOCKS;
                }
        } catch (Exception e) { e.printStackTrace(); }
        return JabberBlockListener.BLOCK_REJECTED;
    }

    public void eventOk(){
        PrivacyList pl=(PrivacyList) getFocusedObject();
        if (pl!=null) {
            if (pl.name!=null) new PrivacyModifyList(display, pl);
        }
    }
    private void generateIgnoreList(){
        JabberDataBlock ignoreList=new JabberDataBlock("list", null, null);
        ignoreList.setAttribute("name", Groups.IGNORE_GROUP);
        JabberDataBlock item=PrivacyItem.itemIgnoreList().constructBlock();
        ignoreList.addChild(item);
        PrivacyList.privacyListRq(true, ignoreList, "ignlst");
    }
}
/*
 * DiscoContact.java
 *
 * Created on 7 Июнь 2006 г., 22:41
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;

import Client.Contact;

public class DiscoContact extends Contact{
    public DiscoContact(final String Nick, final String sJid, final int Status) {
        super(Nick, sJid, Status, null);
    }
    public String toString() { return (nick==null)?getJid():nick; }

    public int compare(Contact c) {
        return this.toString().compareTo( c.toString() );
    }

    public String getTipString() {
        return getJid();
    }
}
/*
 * DiscoFeatures.java
 *
 * Created on 6 Июль 2006 г., 23:30
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;

import java.util.Enumeration;
import java.util.Vector;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.Form;
import javax.microedition.lcdui.List;
import locale.SR;

/**
 *
 * @author Eugene Stahov
 */
public class DiscoFeatures implements CommandListener{
    
    Command cmdBack=new Command(SR.MS_BACK, Command.BACK, 99);
    Command cmdOk=new Command(SR.MS_OK, Command.OK, 1);
    
    List list;

    private Display display;
    private Displayable parentView;
    
    /** Creates a new instance of DiscoFeatures */
    public DiscoFeatures(Display display, String entity, Vector features) {
        if (features.isEmpty()) return;
        
        list=new List(entity, List.IMPLICIT);
        for (Enumeration i=features.elements(); i.hasMoreElements(); ) {
            String feature=(String) (i.nextElement());
            list.append(feature, null);
        }
        
        list.addCommand(cmdBack);
        list.addCommand(cmdOk);
        parentView=display.getCurrent();
        this.display=display;
        
        list.setCommandListener(this);
        display.setCurrent(list);
    }

    public void commandAction(Command command, Displayable displayable) {
        display.setCurrent(parentView);
    }
}
/*
 * RegForm.java
 *
 * Created on 5 Июнь 2005 г., 20:04
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;
import java.util.*;
import javax.microedition.lcdui.*;
import com.alsutton.jabber.*;
import com.alsutton.jabber.datablocks.*;
//import Client.*;


/**
 *
 * @author Evg_S
 */
public class DiscoForm implements CommandListener{
    
    private Display display;
    private Displayable parentView;
    
    private Vector fields;
    private String xmlns;
    private String service;
    
    private String node;
    private String sessionId;
    
    private String childName;
    
    //private Form form;
    
    private boolean xData;
    
    private Command cmdOk=new Command("Send", Command.OK /*Command.SCREEN*/, 1);
    private Command cmdCancel=new Command("Cancel", Command.BACK, 99);
    
    private String id;
    
    //Roster roster=StaticData.getInstance().roster;
    JabberStream stream;
    
    //private JabberBlockListener listener;
    
    /** Creates a new instance of RegForm */
    public DiscoForm(Display display, JabberDataBlock regform, JabberStream stream, String resultId, String childName) {
        service=regform.getAttribute("from");
        this.childName=childName;
        JabberDataBlock query=regform.getChildBlock(childName);
        xmlns=query.getAttribute("xmlns");
        node=query.getAttribute("node");
        sessionId=query.getAttribute("sessionid");
        JabberDataBlock x=query.getChildBlock("x");
        this.id=resultId;
        //this.listener=listener;
        // todo: обработать ошибку query
        fields=new Vector();
        Form form=new Form(service);

        // for instructions
        
        Vector vFields=(xData=(x!=null))? x.getChildBlocks() : query.getChildBlocks();

	Enumeration e;        
        
        if (vFields!=null) {
            for (e=vFields.elements(); e.hasMoreElements(); ){
                FormField field=new FormField((JabberDataBlock)e.nextElement());
                if (field.instructions) {
                    fields.insertElementAt(field, 0);
                } else { fields.addElement(field); }
            }
            
            for (e=fields.elements(); e.hasMoreElements(); ){
                FormField field=(FormField) e.nextElement();
                if (!field.hidden) form.append(field.formItem);
            }
        }
       
        form.setCommandListener(this);
        
        if (childName.equals("command")) {
            if (query.getAttribute("status").equals("completed")) {
                form.append("Complete.");
            } else form.addCommand(cmdOk);
        } else form.addCommand(cmdOk);
        form.addCommand(cmdCancel);
        
        this.display=display;
        this.parentView=display.getCurrent();
        this.stream=stream;
        display.setCurrent(form);
    }
    
    private void sendForm(String id){
        JabberDataBlock req=new Iq(service, Iq.TYPE_SET, id);
        JabberDataBlock qry=req.addChild(childName,null);
        qry.setNameSpace(xmlns);
        //qry.setAttribute("action", "complete");
        qry.setAttribute("node", node);
        qry.setAttribute("sessionid", sessionId);
        
        if (xData) {
            JabberDataBlock x=qry.addChild("x", null);
            x.setNameSpace("jabber:x:data");
            x.setAttribute("type", "submit");
            qry=x;
        }
        
        for (Enumeration e=fields.elements(); e.hasMoreElements(); ) {
            FormField f=(FormField) e.nextElement();
            if (f==null) continue;
            JabberDataBlock ch=f.constructJabberDataBlock();
            if (ch!=null) {
                if (ch.getTagName().equals("remove")) {
                    qry.getChildBlocks().removeAllElements();
                }
                qry.addChild(ch);
            }
        }
        
        //System.out.println(req.toString());
        //if (listener!=null) stream.addBlockListener(listener);
        stream.send(req);
    }

    
    public void commandAction(Command c, Displayable d){
        if (c==cmdCancel) destroyView();
        if (c==cmdOk) { 
            sendForm(id);
            destroyView();
        }
    }

    public void destroyView(){
        display.setCurrent(parentView);
    }
}
/*
 * FormField.java
 *
 * Created on 5 Июнь 2005 г., 20:30
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;
import javax.microedition.lcdui.*;
import com.alsutton.jabber.*;
import java.util.*;
import ui.ConstMIDP;
/**
 *
 * @author Evg_S
 */
public class FormField {
    
    public String label;
    public String type;
    public String name;
    public Item formItem;
    boolean hidden;
    //TODO: boolean required;
    public boolean instructions;
    private Vector optionsList;
    private boolean numericBoolean;
    private boolean registered;
    /** Creates a new instance of FormField */
    public FormField(JabberDataBlock field) {
        name=field.getTagName();
        label=name;
        String body=field.getText();
        if (name.equals("field")) {
            // x:data
            type=field.getAttribute("type");
            name=field.getAttribute("var");
            label=field.getAttribute("label");
            if (label==null) label=name;
            body=field.getChildBlockText("value");
	    hidden= type.equals("hidden"); 
            if (type.equals("fixed")) formItem=new StringItem(label, body); 
            else if (type.equals("boolean")) {
                ChoiceGroup ch=new ChoiceGroup(null,ChoiceGroup.MULTIPLE);
                formItem=ch;
                ch.append(label, null);
                boolean set=false;
                if (body.equals("1")) set=true;
                if (body.equals("true")) set=true;
                numericBoolean=body.length()==1;
                ch.setSelectedIndex(0, set);
            }
            else if (type.equals("list-single") || type.equals("list-multi")) {
                
                int choiceType=(type.equals("list-single"))? 
                    ConstMIDP.CHOICE_POPUP : ChoiceGroup.MULTIPLE;
                ChoiceGroup ch=new ChoiceGroup(label, choiceType);
                formItem=ch;
                
                optionsList=new Vector();
                for (Enumeration e=field.getChildBlocks().elements(); e.hasMoreElements();) {
                    JabberDataBlock option=(JabberDataBlock)e.nextElement();
                    if (option.getTagName().equals("option")) {
                        String value=option.getChildBlockText("value");
                        String label=option.getAttribute("label");
                        if (label==null) label=value;
                        optionsList.addElement(value);
                        int index=ch.append(label, null);
                        if (body.equals(value)) ch.setSelectedIndex(index, true);
                    }
                }
            }
	    // text-single, text-private
            else {
                if (body.length()>=200) {
                    body=body.substring(0,198);
                }
                int constrains=(type.equals("text-private"))? TextField.PASSWORD: TextField.ANY;
                formItem=new TextField(label, body, 200, constrains);
            }
        } else {
            // not x-data
            if ( instructions=name.equals("instructions") )
                formItem=new StringItem("Instructions", body);
            else if ( name.equals("title") )
                formItem=new StringItem(null, body);
            else if ( name.equals("registered") ) {
                ChoiceGroup cg=new ChoiceGroup("Registration", ChoiceGroup.MULTIPLE);
                cg.append("Remove registration", null);
                formItem=cg;
                registered=true;
            }
            else
                formItem=new TextField(label, body, 64, 0);
        }
        
        if (name!=null)
        if ( name.equals("key") ) hidden=true; 
    }
    JabberDataBlock constructJabberDataBlock(){
        JabberDataBlock j=null;
        if (formItem instanceof TextField) {
            String value=((TextField)formItem).getString();
            if (type==null) {
                j=new JabberDataBlock(null, name, value);
            } else {
                // x:data
                j=new JabberDataBlock("field", null, null);
                j.setAttribute("var", name);
                j.setAttribute("type", type);
                j.addChild("value", value);
            }
        }
        if (formItem instanceof ChoiceGroup) {
            if (registered) {
                boolean unregister=((ChoiceGroup)formItem).isSelected(0);
                if (unregister) return new JabberDataBlock("remove", null, null);
                return null;
            }
                
            //only x:data
                j=new JabberDataBlock("field", null, null);
                j.setAttribute("var", name);
                j.setAttribute("type", type);
                if (optionsList==null) {
                    boolean set=((ChoiceGroup)formItem).isSelected(0);
                    String result=String.valueOf(set);
                    if (numericBoolean) result=set?"1":"0";
                    j.addChild("value", result);
                } else 
                if (type.equals("list-multi")) {
                    ChoiceGroup ch=(ChoiceGroup) formItem;
                    int count=ch.size();
                    for (int i=0; i<count; i++) {
                        if (ch.isSelected(i))  
                            j.addChild("value", (String)optionsList.elementAt(i));                    
                    }
                } else /* list-single */ {
                    int index=((ChoiceGroup) formItem).getSelectedIndex();
                    if (index>=0)  j.addChild("value", (String)optionsList.elementAt(index));
                }
        }
        return j;
    }
}
/*
 * Item.java
 *
 * Created on 19 Октябрь 2005 г., 22:27
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;

import Client.StaticData;
import images.RosterIcons;
import ui.Colors;
import ui.IconTextElement;
import ui.ImageList;

/**
 *
 * @author EvgS
 */
public class Node extends IconTextElement{

    private String node;
    private String name;
    
    public int getImageIndex() { return RosterIcons.ICON_COLLAPSED_INDEX; }
    public int getColor() { return Colors.LIST_INK; }
    /** Creates a new instance of Item */
    public Node(String name, String node) {
        super(RosterIcons.getInstance());
        this.name=name;
        this.node=node;
    }
    
    public String getName() { return name; }
    public String getNode() { return node; }

    public String toString() { return (name!=null)? name:node; }
    
}
/*
 * SearchResult.java
 *
 * Created on 10 Июль 2005 г., 21:40
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;
import images.RosterIcons;
import java.util.*;
import javax.microedition.lcdui.*;
import ui.*;
import com.alsutton.jabber.*;
import com.alsutton.jabber.datablocks.*;
import Client.*;

/**
 *
 * @author EvgS
 */
public class SearchResult
        extends VirtualList
        implements CommandListener {
    
    StaticData sd=StaticData.getInstance();
    private Command cmdBack=new Command("Back", Command.BACK, 98);
    private Command cmdAdd=new Command("Add", Command.SCREEN, 1);
    
    private Vector items;
    boolean xData;
    
    /** Creates a new instance of SearchResult */
    public SearchResult(Display display, JabberDataBlock result) {
        super(display);
        
        String service=result.getAttribute("from");
        
        setTitleItem(new Title(2, null, service));
        
        setCommandListener(this);
        addCommand(cmdBack);
        
        items=new Vector();
        
        JabberDataBlock query=result.getChildBlock("query");
        if (query==null) return;
        
        addCommand(cmdAdd);

        
        JabberDataBlock x=query.getChildBlock("x");
        if (x!=null) { query=x; xData=true; }
        
        sd.roster.cleanupSearch();
        
        for (Enumeration e=query.getChildBlocks().elements(); e.hasMoreElements(); ){
            JabberDataBlock child=(JabberDataBlock) e.nextElement();
	    
            if (child.getTagName().equals("item")) {
                StringBuffer vcard=new StringBuffer();
                String jid=null;
		
	        int status=Presence.PRESENCE_ONLINE;

                // Form vcard=new Form(null);
                if (!xData) { jid=child.getAttribute("jid"); }
                // пїЅпїЅпїЅпїЅ item
                for (Enumeration f=child.getChildBlocks().elements(); f.hasMoreElements(); ){
                    JabberDataBlock field=(JabberDataBlock) f.nextElement();
                    String name;
                    String value;
                    if (xData) {
                        name=field.getAttribute("var");
                        value=field.getChildBlockText("value");
                    } else {
                        name=field.getTagName();
                        value=field.getText();
                    }
                    if (name.equals("jid")) jid=value;
                    if (value.length()>0)
                    {
                        //vcard.append(new StringItem(name,value+"\n"));
                        vcard.append(name);
                        vcard.append((char)0xa0);
                        vcard.append(value);
                        vcard.append((char)'\n');
                    }
		    // пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ jit
		    if (name.equals("status")) if (value.equals("offline")) status=Presence.PRESENCE_OFFLINE;
                }
                Contact serv=new DiscoContact(null, jid, status);
                serv.setGroup(sd.roster.groups.getGroup(Groups.TYPE_SEARCH_RESULT));
                Msg m=new Msg(Msg.MESSAGE_TYPE_IN, jid, "Short info", vcard.toString());
                m.unread=false;
                serv.addMessage(m);
                
                items.addElement(serv);
                sd.roster.addContact(serv);
            }
        }
        sd.roster.reEnumRoster();
    }
    
    public int getItemCount(){ return items.size();}
    public VirtualElement getItemRef(int index) { return (VirtualElement) items.elementAt(index);}

    public void commandAction(Command c, Displayable d){
        if (c==cmdAdd){
            destroyView();
            new ContactEdit(display, (Contact)getFocusedObject());
            return;
        }
        
        if (c==cmdBack) destroyView(); 
    }
    
    public void eventOk(){
        /*Form f=(Form)vcards.elementAt(cursor);
        
        display.setCurrent(f);
        f.setCommandListener(this);
        f.addCommand(cmdBack);
        f.addCommand(cmdAdd);*/
        new ContactMessageList((Contact) getFocusedObject(), display);
    }
}
/*
 * ServerBox.java
 *
 * Created on 8 Июль 2005 г., 1:09
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;

import javax.microedition.lcdui.*;
import ui.VirtualList;
/**
 *
 * @author EvgS
 */
public class ServerBox implements CommandListener {
    
    private Display display;
    private TextBox t;
    
    private ServiceDiscovery sd;
    
    private Command cmdCancel=new Command("Cancel",Command.BACK,99);
    private Command cmdSend=new Command("Discover",Command.OK /*Command.SCREEN*/,1);
    
    /** Creates a new instance of ServerBox */
    public ServerBox(Display display, String service, ServiceDiscovery sd) {
        this.display=display;
        this.sd=sd;
        
        t=new TextBox("Address",service,500,TextField.URL);
        t.addCommand(cmdSend);
        t.addCommand(cmdCancel);
        t.setCommandListener(this);
        
        //t.setInitialInputMode("MIDP_LOWERCASE_LATIN");
        display.setCurrent(t);
    }
    
    public void commandAction(Command c, Displayable d){
        String server=t.getString();
        if (server.length()==0) server=null;
        
        if (c==cmdCancel) {
            /*destroyView(); return;*/
        }
        if (c==cmdSend && server!=null) { sd.browse(server, null); }
        
        display.setCurrent(sd);
        return;
    }
}

/*
 * ServiceDiscovery.java
 *
 * Created on 4 Июнь 2005 г., 21:12
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ServiceDiscovery;
import Conference.ConferenceForm;
import images.RosterIcons;
import java.util.*;
import javax.microedition.lcdui.*;
import locale.SR;
import ui.*;
import com.alsutton.jabber.*;
import com.alsutton.jabber.datablocks.*;
import Client.*;

/**
 *
 * @author Evg_S
 */
public class ServiceDiscovery 
        extends VirtualList
        implements CommandListener,
        JabberBlockListener
{
    private final static String NS_ITEMS="http://jabber.org/protocol/disco#items";
    private final static String NS_INFO="http://jabber.org/protocol/disco#info";
    private final static String NS_REGS="jabber:iq:register";
    private final static String NS_SRCH="jabber:iq:search";
    private final static String NS_MUC="http://jabber.org/protocol/muc";
    private final static String NODE_CMDS="http://jabber.org/protocol/commands";
    
    
    private final static String strJoin="Join Conference";
    private final static String strReg="Register";
    private final static String strSrch="Search";
    private final static String strCmds="Execute";
    private final int AD_HOC_INDEX=17;
    
    private Command cmdOk=new Command(SR.MS_BROWSE, Command.SCREEN, 1);
    private Command cmdRfsh=new Command(SR.MS_REFRESH, Command.SCREEN, 2);
    private Command cmdFeatures=new Command(SR.MS_FEATURES, Command.SCREEN, 3);
    private Command cmdSrv=new Command(SR.MS_SERVER, Command.SCREEN, 10);
    //private Command cmdAdd=new Command(SR.MS_ADD_TO_ROSTER, Command.SCREEN, 11);
    private Command cmdBack=new Command(SR.MS_BACK, Command.BACK, 98);
    private Command cmdCancel=new Command(SR.MS_CANCEL, Command.EXIT, 99);

    private StaticData sd=StaticData.getInstance();
    
    private Vector items;
    private Vector stackItems=new Vector();
    
    private Vector features;
    
    private Vector cmds;
    
    private String service;
    private String node;

    private int discoIcon;

    private JabberStream stream;

    
    /** Creates a new instance of ServiceDiscovery */
    public ServiceDiscovery(Display display, String service, String node) {
        super(display);

        setTitleItem(new Title(3, null, null));
        getTitleItem().addRAlign();
        getTitleItem().addElement(null);
        
        stream=sd.roster.theStream;
        stream.cancelBlockListenerByClass(this.getClass());
        stream.addBlockListener(this);
        //sd.roster.discoveryListener=this;
        
        setCommandListener(this);
        addCommand(cmdRfsh);
        addCommand(cmdSrv);
        addCommand(cmdFeatures);
        //addCommand(cmdAdd);
        addCommand(cmdCancel);
        

        addCommand(cmdBack);

        this.node=node;
        this.service=(service!=null)?service:sd.account.getServer();
        
        items=new Vector();
        features=new Vector();
        
        requestQuery(NS_INFO, "disco");
    }
    
    private String discoId(String id) {
        return id+service.hashCode();
    }
    
    public int getItemCount(){ return items.size();}
    public VirtualElement getItemRef(int index) { return (VirtualElement) items.elementAt(index);}
    
    protected void beginPaint(){ getTitleItem().setElementAt(sd.roster.messageIcon,4); }
    
    
    private void titleUpdate(){
        
        getTitleItem().setElementAt(new Integer(discoIcon), 0);
        getTitleItem().setElementAt(service, 2);
        getTitleItem().setElementAt(sd.roster.messageIcon, 4);
	
	int size=0;
	try { size=items.size(); } catch (Exception e) {}
	String count=null;
	if (size>0) {
	    addCommand(cmdOk); 
	    count=" ("+size+") ";
	} else {
	    removeCommand(cmdOk);
	}
        getTitleItem().setElementAt(count,1);	    
    }
    
    private void requestQuery(String namespace, String id){
        discoIcon=RosterIcons.ICON_PROGRESS_INDEX; titleUpdate(); redraw();
        JabberDataBlock req=new Iq(service, Iq.TYPE_GET, discoId(id));
        JabberDataBlock qry=req.addChild("query",null);
        qry.setNameSpace(namespace);
        qry.setAttribute("node", node);

        //stream.addBlockListener(this);
        //System.out.println(">> "+req.toString());
        stream.send(req);
    }
    
    private void requestCommand(String namespace, String id){
        discoIcon=RosterIcons.ICON_PROGRESS_INDEX; titleUpdate(); redraw();
        JabberDataBlock req=new Iq(service, Iq.TYPE_SET, id);
        JabberDataBlock qry=req.addChild("command",null);
        qry.setNameSpace(namespace);
        qry.setAttribute("node", node);
        qry.setAttribute("action", "execute");

        //stream.addBlockListener(this);
        //System.out.println(req.toString());
        stream.send(req);
    }
    
    public int blockArrived(JabberDataBlock data) {
        //System.out.println("<< "+data.toString());
        
        if (!(data instanceof Iq)) return JabberBlockListener.BLOCK_REJECTED;
        String id=data.getAttribute("id");
        if (!id.startsWith("disco")) return JabberBlockListener.BLOCK_REJECTED;
        
        if (data.getTypeAttribute().equals("error")) {
            System.out.println(data.toString());
            discoIcon=RosterIcons.ICON_ERROR_INDEX;
            titleUpdate();
            //redraw();
            
            String err=((JabberDataBlock)(data.getChildBlock("error").getChildBlocks().firstElement())).getTagName();
            Alert alert=new Alert(SR.MS_ERROR_, err, null, null /*AlertType.ALARM*/);
            
            display.setCurrent(alert, this);

            return JabberBlockListener.BLOCK_PROCESSED;
        }

        JabberDataBlock query=data.getChildBlock((id.equals("discocmd"))?"command":"query");
        Vector childs=query.getChildBlocks();
        //System.out.println(id);
        if (id.equals(discoId("disco2"))) {
            Vector items=new Vector();
            if (childs!=null)
            for (Enumeration e=childs.elements(); e.hasMoreElements(); ){
                JabberDataBlock i=(JabberDataBlock)e.nextElement();
                if (i.getTagName().equals("item")){
                    String name=i.getAttribute("name");
                    String jid=i.getAttribute("jid");
                    String node=i.getAttribute("node");
                    Object serv=null;
                    if (node==null) { 
                        serv=new DiscoContact(name,jid,0);
                    } else {
                        serv=new Node(name, node);
                    }
                    items.addElement(serv);
                }
                
                
            }
            
            try { 
                Contact.sort(items);
            } catch (Exception e) { e.printStackTrace(); };
            
            /*if (data.getAttribute("from").equals(service)) - jid hashed in id attribute*/ {
                for (Enumeration e=cmds.elements(); e.hasMoreElements();) 
                    items.insertElementAt(e.nextElement(),0);
                this.items=items;
                moveCursorHome();
                discoIcon=0; titleUpdate(); 
            }
        } else if (id.equals(discoId("disco"))) {
            Vector cmds=new Vector();
            if (childs!=null)
            for (Enumeration e=childs.elements(); e.hasMoreElements();) {
                JabberDataBlock i=(JabberDataBlock)e.nextElement();
                if (i.getTagName().equals("feature")) {
                    String var=i.getAttribute("var");
                    features.addElement(var);
                    if (var.equals(NS_MUC)) { cmds.addElement(new DiscoCommand(RosterIcons.ICON_GCJOIN_INDEX, strJoin)); }
                    if (var.equals(NS_SRCH)) { cmds.addElement(new DiscoCommand(RosterIcons.ICON_SEARCH_INDEX, strSrch)); }
                    if (var.equals(NS_REGS)) { cmds.addElement(new DiscoCommand(RosterIcons.ICON_REGISTER_INDEX, strReg)); }
                    //if (var.equals(NODE_CMDS)) { cmds.addElement(new DiscoCommand(AD_HOC_INDEX,strCmds)); } 
                }
		if (i.getTagName().equals("identity")) {
		    String category=i.getAttribute("category");
		    String type=i.getAttribute("type");
		    if (category.equals("automation") && type.equals("command-node"))  { 
			cmds.addElement(new DiscoCommand(RosterIcons.ICON_AD_HOC, strCmds)); 
		    } 
		}
            }
            /*if (data.getAttribute("from").equals(service)) */ { //FIXME!!!
                this.cmds=cmds;
                requestQuery(NS_ITEMS, "disco2");
            }
        } else if (id.startsWith ("discoreg")) {
            discoIcon=0;
            new DiscoForm(display, data, stream, "discoResult", "query");
        } else if (id.startsWith("discocmd")) {
            discoIcon=0;
            new DiscoForm(display, data, stream, "discocmd", "command");
        } else if (id.startsWith("discosrch")) {
            discoIcon=0;
            new DiscoForm(display, data, stream, "discoRSearch", "query");
        } else if (id.startsWith("discoR")) {
            String text="Successful";
            String title=data.getAttribute("type");
            if (title.equals("error")) {
                text=data.getChildBlockText("error");
            }
            Alert alert=new Alert(title, text, null, null /*AlertType.ALARM*/);
            alert.setTimeout(15*1000);
            if (text=="Successful" && id.endsWith("Search") ) {
                new SearchResult(display, data);
            } else display.setCurrent(alert, this);
        }
        redraw();
        return JabberBlockListener.BLOCK_PROCESSED;
    }
    
    public void eventOk(){
        super.eventOk();
        Object o= getFocusedObject();
        if (o!=null) 
        if (o instanceof Contact) {
            browse( ((Contact) o).jid.getJid(), null );
        }
        if (o instanceof Node) {
            browse( service, ((Node) o).getNode() );
        }
    }
    
    public void browse(String service, String node){
            State st=new State();
            st.cursor=cursor;
            st.items=items;
            st.service=this.service;
            st.node=this.node;
            st.features=features;
            stackItems.addElement(st);
            
            items=new Vector();
            features=new Vector();
            addCommand(cmdBack);
            this.service=service;
            this.node=node;
            requestQuery(NS_INFO,"disco");
    }
    
    public void commandAction(Command c, Displayable d){
	if (c==cmdOk) eventOk();
        if (c==cmdBack){ 
            if (stackItems.isEmpty()) { 
                exitDiscovery();
                return;
            }
            
            State st=(State)stackItems.lastElement();
            stackItems.removeElement(st);
            
            service=st.service;
            items=st.items;
            features=st.features;
            discoIcon=0;
            
            titleUpdate();
            moveCursorTo(st.cursor, true);
            redraw();
            
        }
        /*if (c==cmdAdd){
            exitDiscovery();
            Contact j=(Contact)getFocusedObject();
            new ContactEdit(display, j);
            return;
        }*/
        if (c==cmdRfsh) {requestQuery(NS_INFO, "disco"); }
        if (c==cmdSrv) { new ServerBox(display, service, this); }
        if (c==cmdFeatures) {new DiscoFeatures(display, service, features); }
        if (c==cmdCancel) exitDiscovery();
    }
    
    private class DiscoCommand extends IconTextElement {
        String name;
        int index;
        int icon;
        
        public DiscoCommand(int icon, String name) {
            super(RosterIcons.getInstance());
            this.icon=icon; this.name=name;
        }
        public int getColor(){ return Colors.DISCO_CMD; }
        public int getImageIndex() { return icon; }
        public String toString(){ return name; }
        public void onSelect(){
            switch (icon) {
                case RosterIcons.ICON_GCJOIN_INDEX: {
                    int rp=service.indexOf('@');
                    String room=null;
                    String server=service;
                    if (rp>0) {
                        room=service.substring(0,rp);
                        server=service.substring(rp+1);
                    }
                    new ConferenceForm(display, room, server, null, null);
                    break;
                }
                case RosterIcons.ICON_SEARCH_INDEX:
                    requestQuery(NS_SRCH, "discosrch");
                    break;
                case RosterIcons.ICON_REGISTER_INDEX:
                    requestQuery(NS_REGS, "discoreg");
                    break;
                    
                case RosterIcons.ICON_AD_HOC:
                    requestCommand(NODE_CMDS, "discocmd");
                default:
            }
        }
    }
    private void exitDiscovery(){
        stream.cancelBlockListener(this);
        destroyView();
    }
}
class State{
    public String service;
    public String node;
    public Vector items;
    public Vector features;
    public int cursor;
}
/*
 * Colors.java
 *
 * Created on 4 Февраль 2006 г., 22:26
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

/**
 *
 * @author Evg_S
 */
public class Colors {
    public final static int BALLOON_INK          =0x000000;
    public final static int BALLOON_BGND         =0xffffe0;
    
//#if (!INVCOLORS)
    public static final int LIST_BGND           =0xFFFFFF;
    public static final int LIST_BGND_EVEN      =0xffeeff;
    public final static int LIST_INK            =0x000000;
    public final static int MSG_SUBJ            =0xa00000;
    public final static int MSG_HIGHLIGHT       =0x904090;
    
    public final static int DISCO_CMD           =0x000080;
    
    public static final int HEADER_BGND         =0x0033ff;
    public static final int HEADER_INK          =0x33ffff;
    
    public final static int CONTACT_DEFAULT     =0x000000;
    public final static int CONTACT_CHAT        =0x39358b;
    public final static int CONTACT_AWAY        =0x008080;
    public final static int CONTACT_XA          =0x535353;
    public final static int CONTACT_DND         =0x800000;
    
    public final static int GROUP_INK           =0x000080;
    
    public final static int BLK_INK             =0xffffff;
    public final static int BLK_BGND            =0x000000;

    public final static int MESSAGE_IN      =0x0000b0;
    public final static int MESSAGE_OUT     =0xb00000;
    public final static int MESSAGE_PRESENCE=0x006000;
    public final static int MESSAGE_AUTH    =0x400040;
    public final static int MESSAGE_HISTORY =0x535353;

    public final static int PGS_REMAINED        =0xffffff;
    public final static int PGS_COMPLETE        =0x0000ff;
    public final static int PGS_BORDER          =0x808080;
    public final static int PGS_BGND            =0x000000;
    
    public final static int HEAP_TOTAL          =0xffffff;
    public final static int HEAP_FREE           =0x00007f;
//#else
//#     public static final int LIST_BGND           =0x000000;
//#     public static final int LIST_BGND_EVEN      =0x111111;
//#     public final static int LIST_INK            =0xffffff;
//#     public final static int MSG_SUBJ            =0x00FFFF;
//#     public final static int MSG_HIGHLIGHT       =0xFF80FF;
//#     
//#     public final static int DISCO_CMD           =0x00ffff;
//#     
//#     public static final int HEADER_BGND         =0x000080;
//#     public static final int HEADER_INK          =0x33ffff;
//#     
//#     public final static int CONTACT_DEFAULT     =0xFFFFFF;
//#     public final static int CONTACT_CHAT        =0x39358b;
//#     public final static int CONTACT_AWAY        =0x808080;
//#     public final static int CONTACT_XA          =0x535353;
//#     public final static int CONTACT_DND         =0xff0000;
//#     
//#     public final static int GROUP_INK           =0x00ffff;
//#     
//#     public final static int BLK_INK             =0xffffff;
//#     public final static int BLK_BGND            =0x000000;
//# 
//#     public final static int MESSAGE_IN          =0x8080FF;
//#     public final static int MESSAGE_OUT         =0xFF8080;
//#     public final static int MESSAGE_PRESENCE    =0x00FF80;
//#     public final static int MESSAGE_AUTH        =0x3070FF;
//#     public final static int MESSAGE_HISTORY     =0xA0A0A0;
//# 
//#     public final static int PGS_REMAINED        =0xffffff;
//#     public final static int PGS_COMPLETE        =0x0000ff;
//#     public final static int PGS_BORDER          =0x808080;
//#     public final static int PGS_BGND            =0x000000;
//#     
//#     public final static int HEAP_TOTAL          =0xffffff;
//#     public final static int HEAP_FREE           =0x00007f;    
//#endif

//#if (INVCOLORS)
//#     public static final int CURSOR_BGND    =0x101030;
//#     public static final int CURSOR_OUTLINE =0x8080ff;
//#elif !(MIDP1) 
    public static final int CURSOR_BGND    =0xC8D7E6;
    public static final int CURSOR_OUTLINE =0x000066;
//#else
//#     public static final int CURSOR_BGND    =0x00ff00;
//#     public static final int CURSOR_OUTLINE =CURSOR_BGND;
//#endif

//#if !(MIDP1)
    public static final int SCROLL_BRD     =0x000000;
    public static final int SCROLL_BAR     =0xBBBBBB;
    public static final int SCROLL_BGND    =0xDDDDDD;
//#else
//#     public static final int SCROLL_BRD     =0x0033ff;
//#     public static final int SCROLL_BAR     =0xBBBBBB;
//#     public static final int SCROLL_BGND    =0xBBBBBB;
//#endif
    
}
/*
 * ComplexString.java
 *
 * Created on 12 Март 2005 г., 0:35
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import java.util.*;
import javax.microedition.lcdui.*;
import ui.VirtualElement;

/**
 *
 * @author Eugene Stahov
 */
public class ComplexString extends Vector implements VirtualElement{

    //private Vector v;
    public final static int IMAGE=0x00000000;
    public final static int COLOR=0x01000000;
    public final static int RALIGN=0x02000000;
    public final static int UNDERLINE=0x03000000;

    protected Font font=FontCache.getMsgFont();
    private int height;
    private int width;
    private ImageList imageList;
    private int colorBGnd=Colors.LIST_BGND;
    private int color=Colors.LIST_INK;
    
    /** Creates a new instance of ComplexString */
    public ComplexString() {
        super();
    }

    /** Creates a new instance of ComplexString */
    public ComplexString(ImageList imageList) {
        this();
        this.imageList=imageList;
    }

    private int imgHeight(){
        return (imageList==null)?0:imageList.getHeight();
    }
    private int imgWidth(){
        return (imageList==null)?0:imageList.getWidth();
    }
    
    public int getColor() {return color;}
    public int getColorBGnd() {return colorBGnd;}
    
    public void setColorBGnd(int color){ colorBGnd=color;}
    public void setColor(int color){ this.color=color;}
    
    public void onSelect(){};
    
    public void drawItem(Graphics g, int offset, boolean selected){
        //g.setColor(0);
        boolean ralign=false;
	boolean underline=false;
        
        int w=0;
        int dw;
        int imageYOfs=( getVHeight()-imgHeight() )>>1;
//#if ALCATEL_FONT
//#         int fontYOfs=(( getVHeight()-font.getHeight() )>>1) +1;
//#else
        int fontYOfs=(( getVHeight()-font.getHeight() )>>1);
//#endif
        int imgWidth=imgWidth();
        
        g.setFont(font);
        for (int index=0; index<elementCount;index++) {
            Object ob=elementData[index];
            if (ob!=null) {
                
                if (ob instanceof String ){
                    // string element
                    dw=font.stringWidth((String)ob);
                    if (ralign) w-=dw; 
                    g.drawString((String)ob,w,fontYOfs,Graphics.LEFT|Graphics.TOP);
		    if (underline) {
			int y=getVHeight()-1;
			g.drawLine(w, y, w+dw, y);
			underline=false;
		    }
                    if (!ralign) w+=dw;

                } else if ((ob instanceof Integer)) {
                    // image element or color
                    int i=((Integer)ob).intValue();
                    switch (i&0xff000000) {
                        case IMAGE:
                            if (imageList==null) break;
                            if (ralign) w-=imgWidth;
                            imageList.drawImage(g, ((Integer)ob).intValue(), w, imageYOfs);
                            if (!ralign) w+=imgWidth;
                            break;
                        case COLOR:
                            g.setColor(0xFFFFFF&i);
                            break;
                        case RALIGN:
                            ralign=true;
                            w=g.getClipWidth()-1;
			    break;
			case UNDERLINE:
			    underline=true;
			    break;
                    }
                } /* Integer*/ else if (ob instanceof VirtualElement) { 
                    int clipw=g.getClipWidth(); 
                    int cliph=g.getClipHeight();
                    ((VirtualElement)ob).drawItem(g,0,false);
                    g.setClip(g.getTranslateX(), g.getTranslateY(), clipw, cliph);
                    //TODO: рисование не с нулевой позиции и вычисление ширины
                }

            } // if ob!=null
        } // for
        
    }

    public int getVWidth() {
        //g.setColor(0);
        if (width>0) return width;  // cached
        
        int w=0;
        int imgWidth=imgWidth();
        
        for (int index=0; index<elementCount;index++) {
            Object ob=elementData[index];
            if (ob!=null) {
                
                if (ob instanceof String ){
                    // string element
                    w+=font.stringWidth((String)ob);
                } else if ((ob instanceof Integer)&& imageList!=null) {
                    // image element or color
                    int i=(((Integer)ob).intValue());
                    switch (i&0xff000000) {
                        case IMAGE:
                            w+=imgWidth;
                            break;
                    }
                } // Integer
            } // if ob!=null
        } // for
        return width=w;
    }


    /*public Object elementAt(int index) {
        if (index<elementCount) return super.elementAt(index);
        return null;
    }*/

    
    /**
     * Safe version of setElementAt
     * Sets the component at the specified index of this vector to be the 
     * specified object. The previous component at that position is discarded.
     * If index is greater or equal to the current size of the vector, 
     * size will be automatically enlarged
     * 
     * @param obj 
     * @param index 
     */
    public void setElementAt(Object obj, int index) {
        height=width=0; // discarding cached values
        if (index>=elementCount) this.setSize(index+1);
        super.setElementAt(obj, index);
    }
    
    public int getVHeight(){
        if (height!=0) return height;
        for (int i=0;i<elementCount;i++){
            int h=0;
            Object o=elementData[i];
            if (o==null) continue;
            if (o instanceof String) { h=font.getHeight(); } else
            if (o instanceof Integer) {
                int a=((Integer)o).intValue();
                if ((a&0xff000000) == 0) { h=imageList.getWidth(); }
            } else
            if (o instanceof VirtualElement) { h=((VirtualElement)o).getVHeight(); }
            if (h>height) height=h;
        }
        return height;
    }

    public void addElement(Object obj) {
        height=width=0; // discarding cached values
        super.addElement(obj);
    }

    public void addImage(int imageIndex){ addElement(new Integer(imageIndex)); }
    public void addColor(int colorRGB){ addElement(new Integer(COLOR | colorRGB)); }
    public void addRAlign(){ addElement(new Integer(RALIGN)); }
    public void addUnderline(){ addElement(new Integer(UNDERLINE)); }
    
    public Font getFont() {
        return font;
    }

    public void setFont(Font font) {
        this.font = font;
    }

    public String getTipString() { return null; }

}
/*
 * ComplexIconTextList.java
 *
 * Created on 6 Февраль 2005 г., 17:56
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import ui.ImageList;
import javax.microedition.lcdui.*;
import java.util.*;

/**
 *
 * @author Eugene Stahov
 */
public class ComplexStringList extends VirtualList
{

    protected Vector lines;
    //private ComplexStringDraw cld;
    
    /** Creates a new instance of ComplexIconTextList */
    public ComplexStringList(Display display) {
        super(display);
        cursor=-1;
        //cld=new ComplexStringDraw(il);
    }
    
    public void attachList(Vector list) {
        lines=list;
    }
    
    //public Font getFont() { return f;}
    // overriding base class methods
    protected int getItemCount(){
        if (lines==null) return 0;
        return lines.size();
    }
    
    protected VirtualElement getItemRef(int index){
       return getLine(index); 
    }
    
    protected int getItemHeight(int index){ 
        return getLine(index).getVHeight();
    }
    protected ComplexString cacheUpdate(int index) {return null;}
    
    protected int getItemWidth(int index){ 
        return getLine(index).getVWidth();
    }        

    protected void drawItem(int index, Graphics g, int ofs, boolean selected){
        getLine(index).drawItem(g, ofs, false);
    }

    private ComplexString getLine(int index){
        ComplexString line;
        try {
            line=(ComplexString)lines.elementAt(index);
        } catch (Exception e) { line=null; }
        if (line==null) line=cacheUpdate(index);
        return line;
    }
}
/*
 * ConstMIDP.java
 *
 * Created on 22 Октябрь 2005 г., 19:14
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

import javax.microedition.lcdui.ChoiceGroup;
import javax.microedition.lcdui.TextField;

/**
 *
 * @author EvgS
 */
public class ConstMIDP {
    
//#if !(MIDP1)
    public final static int TEXTFIELD_DECIMAL=	TextField.DECIMAL;
    public final static int CHOICE_POPUP=	ChoiceGroup.POPUP;
    public final static int TEXTFIELD_SENSITIVE=TextField.SENSITIVE;
//#else
//--    public final static int TEXTFIELD_DECIMAL=	TextField.ANY;
//--    public final static int CHOICE_POPUP=	ChoiceGroup.EXCLUSIVE;
//--    public final static int TEXTFIELD_SENSITIVE=0;
//#endif

//#if (!MIDP1)
    public final static String MIDP=		"MIDP2";
//#elif (USE_SIEMENS_API) 
//#     public final static String MIDP=		"MIDP1(Siemens)";
//#elif (RIM)
//#     public final static String MIDP=		"MIDP1(RIM)";
//#else
//#     public final static String MIDP=		"MIDP1";
//#endif
}
/*
 * EventNotify.java
 *
 * Created on 3 Март 2005 г., 23:37
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import javax.microedition.lcdui.*;
import java.io.InputStream;

//#if !(MIDP1)
import javax.microedition.media.*;
import javax.microedition.media.PlayerListener;
import javax.microedition.media.control.VolumeControl;
//#endif

//#if USE_SIEMENS_API
//--import com.siemens.mp.game.*;
//--import com.siemens.mp.media.*;
//--import com.siemens.mp.media.control.VolumeControl;
//--import com.siemens.mp.m55.*;
//#endif

/**
 *
 * @author Eugene Stahov
 */
public class EventNotify 
        implements Runnable
//#if USE_SIEMENS_API || !(MIDP1)
	,PlayerListener
//#endif
{
    
    private int lenVibra;
    private boolean enableLights;
    private boolean toneSequence;
    private String soundName;
    private String soundType;
    
    private Display display;

//#if USE_SIEMENS_API || !(MIDP1)
    private static Player player;
//#endif
    
    private final static String tone="A6E6J6";
    //private int sndVolume;
    
    /** Creates a new instance of EventNotify */
    public EventNotify(
	Display display, 
	String soundMediaType, 
	String soundFileName, 
	//int sndVolume,
	int vibraLength, 
	boolean enableLights
    ) {
        this.display=display;
	this.soundName=soundFileName;
	this.soundType=soundMediaType;
	this.lenVibra=vibraLength;
	this.enableLights=enableLights;
	if (soundType!=null) toneSequence= soundType.equals("tone");
	//this.sndVolume=100;
    }
    
    public void startNotify (){
        release();
        if (soundName!=null)
        try {
//#if !(MIDP1)        
            InputStream is = getClass().getResourceAsStream(soundName);
            //Player p = Manager.createPlayer(is, "audio/X-wav");
            player = Manager.createPlayer(is, soundType);
//#elif USE_SIEMENS_API
//--            player = Manager.createPlayer(soundName);
//#endif

//#if USE_SIEMENS_API || !(MIDP1)
            player.addPlayerListener(this);
	    player.realize();
	    player.prefetch();
	    

//	    try {
//		VolumeControl vol=(VolumeControl) player.getControl("VolumeControl");
//		vol.setLevel(sndVolume);
//	    } catch (Exception e) { e.printStackTrace(); }

	    player.start();
//#endif
        } catch (Exception e) { }

//#if !(MIDP1)        
	if (enableLights) display.flashBacklight(1000);
//#endif

    if (lenVibra>0)
//#if !(MIDP1)
         display.vibrate(lenVibra);
//#elif USE_SIEMENS_API
//--        Vibrator.triggerVibrator(lenVibra);
//#endif
        
	if (toneSequence 
//#if USE_SIEMENS_API
//--	|| enableLights
//#endif
	) new Thread(this).start();
    }
    
    public void run(){
        try {
//#if USE_SIEMENS_API
//--	    if (enableLights) { new Light(); Light.setLightOn(); }
//#endif

	    if (toneSequence) {
		for (int i=0; i<tone.length(); ) {
//#if USE_SIEMENS_API || !(MIDP1)
		    int note=(tone.charAt(i++)-'A')+12*(tone.charAt(i++)-'0');
		    int duration=150;
		    Manager.playTone(note, duration, 100);
		    Thread.sleep(duration);
//#endif
		}
	    }
//#if USE_SIEMENS_API
//--            Thread.sleep(1500);
//--	    if (enableLights) { Light.setLightOff(); }
//#endif
        } catch (Exception e) { e.printStackTrace();}
    }
    
    public synchronized void release(){
//#if USE_SIEMENS_API || !(MIDP1)
        if (player!=null) {
	    player.removePlayerListener(this);
	    player.close();
	}
        player=null;
//#endif
    }
    
//#if USE_SIEMENS_API || !(MIDP1)
    public void playerUpdate(Player player, String string, Object object) {
	if (string.equals(PlayerListener.END_OF_MEDIA)) {    release(); }
    }
//#endif

//#if USE_LED_PATTERN
//--    public static void leds(int pattern, boolean state){
//--        if (state) Ledcontrol.playPattern(pattern);
//--        else       Ledcontrol.stopPattern();
//--    }
//#endif

}
/*
 * FontCache.java
 *
 * Created on 5 Февраль 2006 г., 3:15
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

import javax.microedition.lcdui.Font;

/**
 *
 * @author Evg_S
 */
public class FontCache {

    private static Font normal;
    private static Font bold;
    private static Font msgFont;
    private static Font msgFontBold;
    private static Font balloonFont;
    private static Font clockFont;
    
    public static int rosterFontSize=Font.SIZE_MEDIUM;
    public static int msgFontSize=Font.SIZE_MEDIUM;
    public static int balloonFontSize=Font.SIZE_SMALL;
    public static int clockFontSize=Font.SIZE_LARGE;

    public static Font getRosterNormalFont() {
        if (normal==null) {
            normal=Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_PLAIN, rosterFontSize);
        }
        return normal;
    }
    
    public static Font getRosterBoldFont() {
        if (bold==null) {
            bold=Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_BOLD, rosterFontSize);
        }
        return bold;
    }

    public static Font getMsgFont() {
        if (msgFont==null) {
            msgFont=Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_PLAIN, msgFontSize);
        }
        return msgFont;
    }

    public static Font getMsgFontBold() {
        if (msgFontBold==null) {
            msgFontBold=Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_BOLD, msgFontSize);
        }
        return msgFontBold;
    }

    public static Font getBalloonFont() {
        if (balloonFont==null) {
            balloonFont=Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_PLAIN, balloonFontSize);
        }
        return balloonFont;
    }

    public static void resetCache() {
        normal=bold=msgFont=msgFontBold=balloonFont=null;
    }
    

    public static Font getClockFont() {
        if (clockFont==null) {
            clockFont=Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_BOLD, clockFontSize);
        }
        return clockFont;
    }
}
/*
 * IconTextList.java
 *
 * Created on 30 Январь 2005 г., 18:19
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import ui.ImageList;
import javax.microedition.lcdui.*;
import java.util.*;


/**
 *
 * @author Eugene Stahov
 */
abstract public class IconTextElement implements VirtualElement 
{
    
    int itemHeight;
    int imageYOfs;
    int fontYOfs;
    int imgWidth;
    
    ImageList il;
    
    abstract protected int getImageIndex();
    //abstract public void onSelect();

    public int getBGndRGB(){ return 0xffffff;}
    public int getFontIndex() { return 0;}
    private Font getFont() { 
        //return Font.getFont(Font.FACE_PROPORTIONAL, getFontIndex(), Font.SIZE_MEDIUM);
        return (getFontIndex()==0)?
            FontCache.getRosterNormalFont():
            FontCache.getRosterBoldFont();
    }
    public void drawItem(Graphics g,int ofs,boolean sel){
        
       //Image img=il.getImage(_callback.getImage(index));
        String str=null;
        str=toString();
       
       g.setFont(getFont());
       if (il!=null) il.drawImage(g, getImageIndex(), 2, imageYOfs);
       //g.drawImage(img,2, imageYOfs, Graphics.TOP|Graphics.LEFT);
       g.clipRect(4+imgWidth, 0, 255, itemHeight);
       g.drawString(str,4+imgWidth-ofs, fontYOfs, Graphics.TOP|Graphics.LEFT);
    }
    public int getVWidth(){ 
        try {
            return getFont().stringWidth(toString())+imgWidth+4;            
        } catch (Exception e) {
            return 0;
        }
    }
    //public int getItemCount()
    public int getVHeight(){ return itemHeight;}
    public int getColorBGnd(){ return Colors.LIST_BGND;}
    public void onSelect(){};
    
    /*public void eventOk(){
        if (atCursor!=null) atCursor.onSelect();
    }
     */
/** Creates a new instance of IconTextList */
    public IconTextElement(ImageList il) {
        super();
        this.il=il;
        //f=Font.getDefaultFont();
        int hf=FontCache.getRosterNormalFont().getHeight();
        int hi=0;
	if (il!=null){
	    hi=il.getHeight();
            imgWidth=il.getWidth();
	}
        itemHeight=(hi>hf)?hi:hf;
        imageYOfs=(itemHeight-hi)/2;
//#if ALCATEL_FONT
//#         fontYOfs=1+(itemHeight-hf)/2;
//#else
        fontYOfs=(itemHeight-hf)/2;
//#endif
    }
    
    public String getTipString() {
        return null;
    }
}
/*
 * ImageListC.java
 *
 * Created on 31 Январь 2005 г., 0:06
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

/**
 *
 * @author Eugene Stahov
 */

package ui;
import javax.microedition.lcdui.Image;
import javax.microedition.lcdui.Graphics;

public class ImageList {

    //public final static int ICON_ASK_INDEX=0x06;
    
    
    protected Image resImage;
    protected int height,width;
    //int count,total;
    /** Creates a new instance of ImageListC */
    public ImageList(String resource, int rows, int columns) {
        try {
            resImage = Image.createImage(resource);
            width = resImage.getWidth()/columns;
            height = (rows==0)? width : resImage.getHeight()/rows;
        } catch (Exception e) { 
            System.out.print("Can't load ");
            System.out.println(resource);
        }
    }
    
    public void drawImage(Graphics g, int index, int x, int y){
        int ho=g.getClipHeight();
        int wo=g.getClipWidth();
        int xo=g.getClipX();
        int yo=g.getClipY();
        
        int iy=y-height*(int)(index>>4);
        int ix=x-width*(index&0x0f);
        g.clipRect(x,y, width,height);
        try {
            g.drawImage(resImage,ix,iy,Graphics.TOP|Graphics.LEFT);
        } catch (Exception e) {}
        g.setClip(xo,yo, wo, ho);
    };
    
    public int getHeight() {return height;}
    public int getWidth() {return width;}
    //public int getCount() {return total;}
}
/*
 * KeyBlock.java
 *
 * Created on 15 Май 2005 пїЅ., 3:08
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

import Client.Config;
import images.RosterIcons;
import javax.microedition.lcdui.*;
import java.util.*;
import midlet.Bombus;

/**
 *
 * @author Eugene Stahov
 */
public class KeyBlock extends Canvas implements Runnable{
    
    private int width;
    private int height;
    
    private Display display;
    private Displayable parentView;
    
    private Image img;
    
    private ComplexString status;
    
    private char exitKey;
    private int kHold;
    
    private TimerTaskClock tc;
    
    boolean motorola_backlight;
    boolean singleflash;
    
    /** Creates a new instance */
    public KeyBlock(
            Display display, 
            ComplexString status, 
            char exitKey, 
            boolean motorola_backlight) 
    {
        this.status=status;
        this.display=display;
        kHold=this.exitKey=exitKey;
        this.motorola_backlight=motorola_backlight;
        
        parentView=display.getCurrent();
        status.setElementAt(new Integer(RosterIcons.ICON_KEYBLOCK_INDEX),6);
        repaint();
        
        singleflash=true;

        new Thread(this).start();
        
        tc=new TimerTaskClock();
        
        
//#if !(MIDP1)
        setFullScreenMode(Config.getInstance().fullscreen);
//#elif USE_SIEMENS_API
//--	com.siemens.mp.game.Light.setLightOff();
//#endif
        //System.gc();   // heap cleanup
    }
    
    public void run(){
        try {
            img=Bombus.splash;
            if (img==null) img=Image.createImage("/images/splash.png");
        } catch (Exception e) {};
        
        display.setCurrent(this);
    }
    
    public void paint(Graphics g){
        width=getWidth();
        height=getHeight();
        Font f=FontCache.getClockFont();
        
        g.setColor(Colors.BLK_BGND);
        g.fillRect(0,0, width, height);
        
        if (img!=null) g.drawImage(img, width/2, 0, Graphics.TOP|Graphics.HCENTER);
        
        int h=f.getHeight()+1;
//#if ALCATEL_FONT
//#         int y=height-h-4;
//#else
        int y=height-h;
//#endif
        g.setColor(Colors.BLK_INK);
        g.translate(0, y);
        status.drawItem(g, 0, false);
        
        String time=Time.timeString(Time.localTime());
        int tw=f.stringWidth(time);
        
        g.translate(width/2, -h);
        g.setColor(Colors.BLK_BGND);
        g.fillRect(-tw/2-5, -h, tw+10, h);

        g.setColor(Colors.BLK_INK);
        g.setFont(f);
        g.drawString(time, 0, 0, Graphics.BOTTOM | Graphics.HCENTER);
//#if !(MIDP1)
	//display.flashBacklight(0); // тест на самсунгах
        if (motorola_backlight) 
            if (singleflash) display.flashBacklight(1);
        singleflash=false;
//#endif
    }
    
    public void keyPressed(int keyCode) { 
        //System.out.println("blocked press"+(char) keyCode);
        kHold=0; 
    }
    public void keyReleased(int keyCode) { 
        //System.out.println("blocked released"+(char) keyCode); kHold=0; 
    }
    protected void keyRepeated(int keyCode) { 
        //System.out.println("blocked repeat"+(char) keyCode);
        if (kHold==0)
        if (keyCode==exitKey) destroyView(); 
    }

    private void destroyView(){
        status.setElementAt(null,6);
//#if !(MIDP1)
        if (motorola_backlight) display.flashBacklight(Integer.MAX_VALUE);
//#endif
        if (display!=null)   display.setCurrent(parentView);
        img=null;
        tc.stop();
//#if USE_SIEMENS_API
//--	com.siemens.mp.game.Light.setLightOn();
//#endif
        System.gc();
    }
    
    private class TimerTaskClock extends TimerTask {
        private Timer t;
        public TimerTaskClock(){
            t=new Timer();
            t.schedule(this, 10, 20000);
        }
        public void run() {
            repaint();
//#if USE_SIEMENS_API
//--	com.siemens.mp.game.Light.setLightOff();
//#endif
        }
        public void stop(){
            cancel();
            t.cancel();
        }
    }
}
/*
 * Menu.java
 *
 * Created on 1 Май 2005 г., 20:48
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import Client.Title;
import java.util.*;
import javax.microedition.lcdui.*;

/**
 *
 * @author Evg_S
 */
public class Menu extends VirtualList implements CommandListener
{
    Vector menuitems;
    /** Creates a new instance of Menu */
    Command cmdBack=new Command("Back",Command.BACK,99);
    Command cmdOk=new Command("Ok",Command.OK,1);
    
    public Menu(String title) {
        super();
        setTitleItem(new Title(title));
        menuitems=new Vector();
        addCommand(cmdBack);
        addCommand(cmdOk);
        setCommandListener(this);
    }
    
    public VirtualElement getItemRef(int index){ 
        return (VirtualElement)menuitems.elementAt(index); 
    }
    public int getItemCount() { return menuitems.size(); }
    
    public void addItem(MenuItem mi){
        menuitems.addElement(mi);
    }
    
    public void addItem(String label, int index){
        addItem(new MenuItem(label, index));
    }
    
    public void commandAction(Command c, Displayable d) {
        if (c==cmdBack) destroyView();
	if (c==cmdOk) eventOk();
    }
}
/*
 * MenuItem.java
 *
 * Created on 2 Апрель 2005 г., 13:22
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

/**
 *
 * @author Eugene Stahov
 */
public class MenuItem extends IconTextElement
{
    
    /** Creates a new instance of MenuItem */
    public int index;
    private String name;
    
    public MenuItem(String name, int index) {
	super(null);
        this.index=index;
	this.name=name;
    }

    protected int getImageIndex() { return -1;  }
    public int getColor() { return Colors.LIST_INK; }
    public String toString(){ return name; }
}
/*
 * MIDPTextBox.java
 *
 * Created on 26 Март 2005 г., 20:56
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

import javax.microedition.lcdui.*;

/**
 *
 * @author  Eugene Stahov
 * @version
 */
public class MIDPTextBox implements CommandListener {
    
    private Display display;
    private Displayable parentView;
    
    protected Command cmdCancel=new Command("Cancel", Command.BACK, 99);
    protected Command cmdOK=new Command("OK", Command.OK /*Command.SCREEN*/, 1);
    
    private TextBox t;
    
    private TextBoxNotify tbn;

    /**
     * constructor
     */
    public interface TextBoxNotify {
        void OkNotify(String text_return);
    }
   
    public MIDPTextBox(Display display, String title, String text, TextBoxNotify tbn , int constraints) {
        t=new TextBox(title, text, 50, constraints);
        
        this.display=display;
        this.tbn=tbn;
        
        t.addCommand(cmdOK);
        t.addCommand(cmdCancel);
        
        t.setCommandListener(this);
            

        parentView=display.getCurrent();
        display.setCurrent(t);
    }
    
    /**
     * Called when action should be handled
     */
    public void commandAction(Command command, Displayable displayable) {
        if (command==cmdCancel) { destroyView(); return;}
        if (command==cmdOK) { destroyView(); tbn.OkNotify(t.getString()); return;}
    }

    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView);
    }
}
/*
 * Screens.java
 *
 * Created on 1 Ноябрь 2005 г., 0:39
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

import java.util.Vector;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;

/**
 *
 * @author EvgS
 */
public class ScreenManager {
    
    private Display display;
    private Vector displayStack;
    
    private static ScreenManager instance;
    
    public static ScreenManager getInstance() {
	if (instance==null) instance=new ScreenManager();
	return instance;
    }
    /** Creates a new instance of Screens */
    private ScreenManager() {
	displayStack=new Vector();
    }

    public void setDisplay(Display display) {
        this.display = display;
    }
    
    public void setCurrent(Displayable displayable) {
	if (!displayStack.contains(displayable)) {
	    displayStack.addElement(displayable);
	}
	display.setCurrent(displayable);
    }
    
    public void destroyView(Displayable displayable){
	displayStack.removeElement(displayable);
        show();
    }

    public void show() {
	try {
	    display.setCurrent((Displayable)displayStack.lastElement());
	} catch (Exception e) { System.out.println("nothing to show"); }
    }

    /**
     * SonyEricsson method for minimize midlet
     */
    public void hide() {
	display.setCurrent(null);
    }
}
/*
 * SplashScreen.java
 *
 * Created on 9 Февраль 2005 г., 21:31
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;

import Client.NvStorage;
import javax.microedition.lcdui.*;

/**
 *
 * @author Eugene Stahov
 */
public class SplashScreen extends Canvas implements CommandListener{
    
    private String capt;
    private int pos=-1;
    
    private int width;
    private int height;
    
    public Image img;
    
    public int keypressed=0;
    
    /*protected void sizeChanged(int w, int h){
        width=w;height=h;
    }
     */
    
    private static SplashScreen instance;
    public static SplashScreen getInstance(){
        if (instance==null) instance=new SplashScreen();
        return instance;
    }
    
    /** Creates a new instance of SplashScreen */
    private SplashScreen() {
    }
    
    public void paint(Graphics g){
        if (pos==-1) return;
        width=getWidth();
        height=getHeight();
        Font f=FontCache.getRosterNormalFont();
        
        int xp=pos*width/100;
        int xt=width/2;
        int h=f.getHeight()+1;

        int y=height-h-2;
        
        g.setColor(Colors.PGS_BGND);
        g.fillRect(0,0, width, height);
        
        if (img!=null) g.drawImage(img, width/2, 0, Graphics.TOP|Graphics.HCENTER);
        
        g.setColor(Colors.PGS_BORDER);
        g.drawRect(0, y, width-1, h-1);
        
        g.setColor(Colors.PGS_REMAINED);
        //g.setStrokeStyle(Graphics.DOTTED); <- не работает
        g.fillRect(1, y+1, width-2,h-2);
        //g.setStrokeStyle(Graphics.SOLID);
        
        g.setFont(f);
        g.setColor(Colors.PGS_COMPLETE);
//#if ALCATEL_FONT
//#         g.drawString(capt,xt,y+2, Graphics.TOP|Graphics.HCENTER);
//#else
        g.drawString(capt,xt,y+1, Graphics.TOP|Graphics.HCENTER);
//#endif
        
        g.setClip(1, y+1, xp, h-2);
        g.fillRect(1, y+1, width-2,h-2);
        
        g.setColor(Colors.PGS_REMAINED);
//#if ALCATEL_FONT
//#         g.drawString(capt,xt,y+2, Graphics.TOP|Graphics.HCENTER);
//#else
        g.drawString(capt,xt,y+1, Graphics.TOP|Graphics.HCENTER);
//#endif
    }
    
    public void setProgress(int progress) {
        pos=progress;
        repaint();
    }

    public void setFailed(){
        setProgress("Failed", 0);
    }
    public void setProgress(String caption, int progress){
        capt=caption;
        System.out.println(capt);
	setProgress(progress);
    }
    public int getProgress(){
        return pos;
    }

    protected void keyPressed(int keyCode) {
        keypressed=keyCode;
        //notifyAll();
    }
    
    // close splash
    private Display display;
    private Displayable parentView;
    private Command cmdExit=new Command("Hide Splash", Command.BACK, 99);
    
    public void setExit(Display display, Displayable nextDisplayable){
        this.display=display;
        parentView=nextDisplayable;
        setCommandListener(this);
        addCommand(cmdExit);
    }
    
    public void commandAction(Command c, Displayable d) {
        if (c==cmdExit) close();
    }
    
    public void close(){
        if (parentView!=null) display.setCurrent(parentView);
        parentView=null;
        repaint();
        img=null;
        instance=null; // освобождение памяти
        System.gc();
    }
}
/*
 * Time.java
 *
 * Created on 20 Февраль 2005 г., 13:03
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import java.util.*;

/**
 *
 * @author Eugene Stahov
 */
public class Time {
    
    private static Calendar c=Calendar.getInstance( TimeZone.getTimeZone("GMT") );
    private static long offset=0; 
    private static long locToGmtoffset=0;
    /** Creates a new instance of Time */
    private Time() { }
    
    public static void setOffset(int gmtOffset, int locOffset){
        offset=60*60*1000*gmtOffset;
        locToGmtoffset=((long)locOffset)*60*60*1000;
    }

    public static String lz2(int i){
        if (i<10) return "0"+i; else return String.valueOf(i);
    }
    public static String timeString(long date){
        Calendar c=calDate(date);
        return lz2(c.get(Calendar.HOUR_OF_DAY))+":"+lz2(c.get(Calendar.MINUTE));
    }
    
    private static Calendar calDate(long date){
        c.setTime(new Date(date+offset));
        return c;
    }
    
    public static String dayString(long date){
        Calendar c=calDate(date);
        return lz2(c.get(Calendar.DAY_OF_MONTH))+"."+
               lz2(c.get(Calendar.MONTH)+1)+"."+
               lz2(c.get(Calendar.YEAR) % 100)+" ";
    }

    public static long localTime(){
        return System.currentTimeMillis()+locToGmtoffset;
    }
    
    public static String utcLocalTime(){
        long date=localTime();
        c.setTime(new Date(date));
        return String.valueOf(c.get(Calendar.YEAR))+
                lz2(c.get(Calendar.MONTH))+
                lz2(c.get(Calendar.DAY_OF_MONTH)+1)+
                'T'+timeString(date)+':'+lz2(c.get(Calendar.SECOND));
    }
    
    public static String dispLocalTime(){
        long date=localTime();
        //Calendar c=calDate(date);
        return dayString(date)+timeString(date);
    }
    
    private final static int[] calFields=
    {Calendar.YEAR,         Calendar.MONTH,     Calendar.DATE, 
     Calendar.HOUR_OF_DAY,  Calendar.MINUTE,    Calendar.SECOND};
     
    private final static int[] ofsFieldsA=
    { 0, 4, 6, 9, 12, 15 } ;

    //private final static int[] ofsFieldsB=
    //{ 0, 4, 6, 9, 12, 15 } ;
    
    public static long dateIso8601(String sdate){
        try {
            int l=4;    // yearlen
            for (int i=0; i<calFields.length; i++){
                int begIndex=ofsFieldsA[i];
                int field=Integer.parseInt(sdate.substring(begIndex, begIndex+l));
                if (i==1) field--;
                l=2;
                c.set(calFields[i], field);
            }
        } catch (Exception e) {    }
        return c.getTime().getTime(); 
    }
}

/*
 * VirtualElement.java
 *
 * Created on 29 Март 2005 г., 0:13
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import javax.microedition.lcdui.*;

/**
 * интерфейс виртуального элемента списка.
 * @author Eugene Stahov
 */
public interface VirtualElement {
    
    /**
     * высота элемента
     * @return высота элемента в пикселах
     */
    public int getVHeight();
    
    /**
     * ширина элемента
     * @return ширина элемента в пикселах
     */
    public int getVWidth();
    
    /**
     * 
     * цвет заполнения фона элемента
     * фон закрашивается автоматически перед вызовом drawItem
     * @return RGB-цвет заполнения фона элемента
     */
    public int getColorBGnd(); 
    
    /**
     * цвет чернил элемента
     * устанавливается перед вызовом drawItem
     * @return RGB-цвет чернил элемента
     */
    public int getColor(); 
    
    /**
     * 
     * отрисовка элемента. перед вызовом устанавливаются 
     * трансляция экранных координат <i>translate(x,y)</i> в позицию элемента
     * и обрезание <i>setClip(0,0,width,height)</i>. 
     * 
     * фон закрашивается автоматически перед вызовом drawItem
     * @param g контекст отрисовки элемента
     * @param ofs горизонтальное смещение скроллируемой части элемента
     * @param selected признак выбранного курсором элемента
     */
    public void drawItem(Graphics g, int ofs, boolean selected);

    /**
     * информация для всплывающего окна
     */
    public String getTipString();
    /**
     * Callback-вызов, осуществляемый при выполнении OK для выделенного курсором элемента
     */
    public void onSelect();
}
/*
 * VirtualList.java
 *
 * Created on 30 Январь 2005 г., 14:46
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import javax.microedition.lcdui.*;
import java.util.*;
import Client.*;
import ui.controls.Balloon;
import ui.controls.ScrollBar;

/**
 * Вертикальный список виртуальных элементов.
 * класс реализует управление списком, скроллбар,
 * вызов отрисовки отображаемых на экране элементов.
 * @author Eugene Stahov
 */
public abstract class VirtualList         
        extends Canvas 
{
    
    /**
     * событие "Курсор выделил элемент"
     * в классе VirtualList вызываемая функция не выполняет действий, необходимо
     * переопределить (override) функцию для реализации необходимых действий
     * @param index индекс выделенного элемента
     */
    public void focusedItem(int index) {}


    /**
     * число элементов виртуального списка
     * эта функция абстрактная, должна быть переопределена при наследовании
     * @return число элементов списка, исключая заголовок
     */
    abstract protected int getItemCount();

    /**
     * элемент виртуального списка
     * эта функция абстрактная, должна быть переопределена при наследовании
     * @param index номер элемента списка. не превосходит значение, возвращённое getItemCount()
     * @return ссылка на элемент с номером index.
     */
    abstract protected VirtualElement getItemRef(int index);
    
    /**
     * цвет фона заголовка
     * @return RGB-цвет фона заголовка
     */
    protected int getTitleBGndRGB() {return Colors.HEADER_BGND;} 

    /**
     * цвет текста заголовка
     * @return RGB-цвет текста заголовка
     */
    protected int getTitleRGB() {return Colors.HEADER_INK;} 
    
    /**
     * событие "Нажатие кнопки ОК"
     * базовая реализация VirtualList вызывает функцию onSelect для выбранного элемента; 
     * необходимо переопределить (override) функцию для реализации желаемых действий
     */
    public void eventOk(){
        try {
            ((VirtualElement)getFocusedObject()).onSelect();
            updateLayout();
            fitCursorByTop();
        } catch (Exception e) { e.printStackTrace();} 
    }
    
    /**
     * Обработчик дополнительных кнопок. Вызывается в случае, если код кнопки 
     * не был обработан функцией key(keyCode)
     * необходимо переопределить (override) функцию для реализации необходимых действий     
     * @param keyCode код клавиши
     */
    public void userKeyPressed(int keyCode){}
    
    //////////////////////////////////

    public static final int SIEMENS_GREEN=-11;
    public static final int NOKIA_GREEN=-10;
    public static final int MOTOROLA_GREEN=-10;
    public final static int MOTOROLA_FLIP=-200;
    public static final int MOTOE680_VOL_UP=-9;
    public static final int MOTOE680_VOL_DOWN=-8;
    public static final int MOTOE680_REALPLAYER=-6;
    public static final int MOTOE680_FMRADIO=-7;
    public static final int SE_GREEN=0;
    
    private final static int STRING_SZ=15;

    public static int keyClear=-8;
    public static int keyVolDown=0x1000;
    public static int greenKeyCode=SIEMENS_GREEN;
    public static boolean fullscreen=false;
    public static boolean memMonitor;
    
    /** метрика экрана */
    int width;
    int height;
    
    /** экранный буфер для скрытой отрисовки. используется, если платформа 
     * не поддерживает двойную буферизацию экрана
     */
    private Image offscreen;
    
    /** признак положения курсора в конце списка */
    protected boolean atEnd; //FIXME: перенести поведение в функции keyRight();
    
    protected int cursor;
    
    /** 
     * окно приклеено к позиции курсора 
     * ПРИКЛЕИВАЕТСЯ:
     *   при нажатии кнопок перемещения курсора
     *   при выборе стилусом элемента списка
     * ОТКЛЕИВАЕТСЯ:
     *   при использовании скролбара
     */
    protected boolean stickyWindow=true;
    
    private int itemLayoutY[]=new int[1];
    private int listHeight;

    
    protected synchronized void updateLayout(){
        int size=getItemCount();
        if (size==0) {
            listHeight=0;
            return;
        }
        int layout[]=new int[size+1];
        int y=0;
        for (int index=0; index<size; index++){
            y+=getItemRef(index).getVHeight();
            layout[index+1]=y;
        };
        listHeight=y;
        itemLayoutY=layout;
    }
    protected int getElementIndexAt(int yPos){
        // деление пополам
        int end=getItemCount()-1;
        if (end<0) return -1;
        int begin=0;
        while (end-begin>1) {
            int index=(end+begin)/2;
            if (yPos<itemLayoutY[index]) end=index; else begin=index;
        }
        return (yPos<itemLayoutY[end])? begin:end;
    }
    
    public int win_top;    // верхняя граница окна относительно списка
    private int winHeight;  // отображаемый размер списка
    //int full_items; // полностью изображено в окне
    protected int offset;     // счётчик автоскроллинга
    
    protected boolean showBalloon;
    
    protected VirtualElement title;
    
    private boolean wrapping = true;

    /** видимые границы элементов списка - зоны срабатывания touchscreen */
    private int itemBorder[];
    /** обработка doubleclick */
    private int lastClickY;
    private int lastClickItem;
    private long lastClickTime;
    
    /**
     * Разрешает заворачивание списка в кольцо (перенос курсора через конец списка)
     * по умолчанию установлен true
     * @param wrap будучи переданным true, разрешает перенос курсора через конец списка
     */
    public void enableListWrapping(boolean wrap) { this.wrapping=wrap; }
    
    /**
     * ссылка на заголовок списка
     * @return объект типа ComplexString
     */
    public ComplexString getTitleItem() {return (ComplexString)title;}
    public void setTitleItem(ComplexString title) { this.title=title; }
    
    /**
     * возвращает ссылку на объект в фокусе. 
     * в классе VirtualList возвращает VirtualElement, на который указывает курсор,
     * однако, возможно переопределить функцию при наследовании
     * @return ссылка на объект в фокусе.
     */
    public Object getFocusedObject() { 
        try {
            return getItemRef(cursor);
        } catch (Exception e) { }
        return null;
    }    

    protected Display display;
    protected Displayable parentView;

    ScrollBar scrollbar;
    /** Creates a new instance of VirtualList */
    public VirtualList() {
        width=getWidth();
        height=getHeight();
        // rotator
        rotator=new TimerTaskRotate(0);
//#if !(MIDP1)
        //addCommand(cmdSetFullScreen);
        setFullScreenMode(fullscreen);
//#endif
	
	itemBorder=new int[32];
	
	scrollbar=new ScrollBar();
	scrollbar.setHasPointerEvents(hasPointerEvents());
    }

    /** Creates a new instance of VirtualList */
    public VirtualList(Display display) {
        this();

        attachDisplay(display);
    }
    
    /**
     * Запоминание предыдущего отображаемого объекта, подключенного к менеджеру
     * дисплея и подключение к дисплею виртуального списка (this) 
     * @param display менеджер дисплея мобильного устройства {@link }
     */
    public void attachDisplay (Display display) {
        if (this.display!=null) return;
        this.display=display;
        parentView=display.getCurrent();
        display.setCurrent(this);
        redraw();
    }


    /** запуск отложенной отрисовки активного Canvas */
    public void redraw(){
        //repaint(0,0,width,height);
        Displayable d=display.getCurrent();
        //System.out.println(d.toString());
        if (d instanceof Canvas) {
            ((Canvas)d).repaint();
        }
    }

    /** Вызывается после скрытия VirtualList. переопределяет наследуемый метод 
     * Canvas.hideNotify(). действие по умолчанию - освобождение экранного 
     * буфера offscreen, используемого при работе без автоматической двойной буферизации
     */
    protected void hideNotify() {
	offscreen=null;
    }
    
    /** Вызывается перед вызовом отрисовки VirtualList. переопределяет наследуемый метод 
     * Canvas.showNotify(). действие по умолчанию - создание экранного 
     * буфера offscreen, используемого при работе без автоматической двойной буферизации
     */
    protected void showNotify() {
	if (!isDoubleBuffered()) 
	    offscreen=Image.createImage(width, height);
    }
    
    /** Вызывается при изменении размера отображаемой области. переопределяет наследуемый метод 
     * Canvas.sizeChanged(int width, int heigth). сохраняет новые размеры области рисования.
     * также создаёт новый экранный буфер offscreen, используемый при работе без автоматической 
     * двойной буферизации
     */
//#if !(MIDP1)
    protected void sizeChanged(int w, int h) {
        width=w;
        height=h;
	if (!isDoubleBuffered()) 
	    offscreen=Image.createImage(width, height);
    }
//#endif
    
    /**
     * начало отрисовки списка.
     * функция вызывается перед отрисовкой списка, 
     * перед любыми обращениями к элементам списка.
     *
     * в классе VirtualList функция не выполняет никаких действий, необходимо
     * переопределить (override) функцию для реализации необходимых действий
     */
    protected void beginPaint(){};
    
    /**
     * отрисовка
     */
    public void paint(Graphics graphics) {
        width=getWidth();	// patch for SE
        height=getHeight();
	Graphics g=(offscreen==null)? graphics: offscreen.getGraphics();
        // заголовок окна
        
        beginPaint();
        
        int list_top=0; // верхняя граница списка
        updateLayout(); //fixme: только при изменении списка
        
        if (title!=null) {
            list_top=title.getVHeight();
            g.setClip(0,0, width, list_top);
            g.setColor(getTitleBGndRGB());
            g.fillRect(0,0, width, list_top);
            g.setColor(getTitleRGB());
            title.drawItem(g,0,false);
        }

        drawHeapMonitor(g);
        winHeight=height-list_top;


        itemBorder[0]=list_top;
        
        int count=getItemCount(); // размер списка
        
        boolean scroll=(listHeight>winHeight);

        if (count==0) {
            cursor=(cursor==-1)?-1:0; 
            win_top=0;
        } else if (cursor>=count) {
            cursor=count-1;
            stickyWindow=true;
        }
        if (count>0 && stickyWindow) fitCursorByTop();
        
        int itemMaxWidth=(scroll) ?(width-scrollbar.getScrollWidth()) : (width);
        // элементы окна
        // отрисовка
        int itemIndex=getElementIndexAt(win_top);
        int displayedIndex=0;
        int displayedBottom=list_top;
   
        int baloon=-1;
        atEnd=false;
        int itemYpos;
        try {
            // try вместо проверки на конец списка
            while ((itemYpos=itemLayoutY[itemIndex]-win_top)<winHeight) {
                
                VirtualElement el=getItemRef(itemIndex);
                
                boolean sel=(itemIndex==cursor);
                
                int lh=el.getVHeight();
                
                // окно списка
                setAbsOrg(g, 0, list_top);
                g.setClip(0,0, itemMaxWidth, winHeight);    
                
                g.translate(0,itemYpos);
                
                g.setColor(el.getColorBGnd());
                if (sel) {
                    drawCursor(g, itemMaxWidth, lh); 
                    baloon=g.getTranslateY();
                } else
                    g.fillRect(0,0, itemMaxWidth, lh);

                g.setColor(el.getColor());
                
                g.clipRect(0, 0, itemMaxWidth, lh);
                el.drawItem(g, (sel)?offset:0, sel);
                
                itemIndex++;
		displayedBottom=itemBorder[++displayedIndex]=list_top+itemYpos+lh;
            }
        } catch (Exception e) { atEnd=true; }

        // очистка остатка окна
        int clrH=height-displayedBottom;
        if (clrH>0) {
            setAbsOrg(g, 0,displayedBottom);
            g.setClip(0, 0, itemMaxWidth, clrH);
            g.setColor(Colors.LIST_BGND);
            //g.setColor(VL_CURSOR_OUTLINE);
            g.fillRect(0, 0, itemMaxWidth, clrH);
        }

        // рисование скроллбара
        //g.setColor(VL_BGND);
        if (scroll) {
	    
            setAbsOrg(g, 0, list_top);
            g.setClip(0, 0, width, winHeight);

	    scrollbar.setPostion(win_top);
	    scrollbar.setSize(listHeight);
	    scrollbar.setWindowSize(winHeight);
	    
	    scrollbar.draw(g);
        } else scrollbar.setSize(0);

        setAbsOrg(g, 0, 0);
        g.setClip(0,0, width, height);
        if (showBalloon) {
            String text=null;
            try {
                text=((VirtualElement)getFocusedObject()).getTipString();
            } catch (Exception e) { }
            if (text!=null)
                drawBalloon(g, baloon, text);
        }

	if (offscreen!=null) graphics.drawImage(offscreen, 0,0, Graphics.TOP | Graphics.LEFT );
	//full_items=fe;
    }

    protected void drawBalloon(final Graphics g, int balloon, final String text) {
        setAbsOrg(g,0,balloon);
        Balloon.draw(g, text);
    }

    private void drawHeapMonitor(final Graphics g) {
        if (memMonitor) {
            int ram=(int)((Runtime.getRuntime().freeMemory()*32)/Runtime.getRuntime().totalMemory());
            g.setColor(0xffffff);  g.fillRect(width-34,0,34,3);
            g.setColor(0x00007f);  g.fillRect(width-33,1,ram,2);
        }
    }
    
    
    /**
     * перенос координат (0.0) в абсолютные координаты (x,y)
     * @param g графический контекст отрисовки
     * @param x абсолютная x-координата нового начала координат 
     * @param y абсолютная y-координата нового начала координат
     */
    private void setAbsOrg(Graphics g, int x, int y){
        g.translate(x-g.getTranslateX(), y-g.getTranslateY());
    }
    
   
    /**
     * перемещение курсора в начало списка
     */
    public void moveCursorHome(){
        stickyWindow=true;
        //win_top=0;
        if (cursor>0) {
            cursor=0;
            //focusedItem(0);
        }
        setRotator();
    }

    /**
     * перемещение курсора в конец списка
     */
    public void moveCursorEnd(){
        stickyWindow=true;
        int count=getItemCount();
        //win_top=count-visibleItemsCnt(count-1, -1);
        if (cursor>=0) {
            cursor=(count==0)?0:count-1;
            //focusedItem(cursor);
        }
        //win_top=(listHeight>winHeight)? listHeight-winHeight:0;
        setRotator();
    }

    /**
     * перемещение курсора в индексированную позицию
     * @param index позиция курсора в списке
     */
    public void moveCursorTo(int index, boolean force){
        int count=getItemCount();
        if (index<0) index=0;
        if (index>=count) index=count-1;    // если за последним элементом, то переместить на него
        //else if ((!force) && stickyWindow) return;
        
        cursor=index;
        stickyWindow=true;
        
        repaint();
        //moveCursor(index-cursor, force); 
    }
    
    protected void fitCursorByTop(){
        try {
            //проверка по верхней границе
            int top=itemLayoutY[cursor];
            // если верхний край выше окна, выровнять по верху
            if (top<win_top) win_top=top;   
            if (((VirtualElement)getFocusedObject()).getVHeight()<=winHeight) {
                // объект помещается на экране - проверим и нижнюю границу
                int bottom=itemLayoutY[cursor+1]-winHeight;
                // если нижний край ниже окна, выровнять по низу
                if (bottom>win_top) win_top=bottom;  
            }
            // случай, когда курсор больше окна, и он НИЖЕ окна
            if (top>=win_top+winHeight) win_top=top; 
        } catch (Exception e) { e.printStackTrace(); }
    }
    
    protected void fitCursorByBottom(){
        //проверка по верхней границе
        try {
            int bottom=itemLayoutY[cursor+1]-winHeight;
            // если нижний край ниже окна, выровнять по низу
            if (bottom>win_top) win_top=bottom;
            if (((VirtualElement)getFocusedObject()).getVHeight()<=winHeight) {
                // объект помещается на экране - проверим и нижнюю границу
                int top=itemLayoutY[cursor];
                // если верхний край выше окна, выровнять по верху
                if (top<win_top) win_top=top;
            }
            // случай, когда курсор больше окна, и он ВЫШЕ окна
            if (itemLayoutY[cursor+1]<=win_top) win_top=bottom;
        } catch (Exception e) { e.printStackTrace(); }
    }

    /*public void moveCursorTo(Object focused){
        int count=getItemCount();
        for (int index=0;index<count;index++){
            if (focused==getItemRef(index)) {
                moveCursorTo(index);
                break;
            }
        }
    }
     */
    /** код удерживаемой кнопки */
    protected int kHold;
    
    protected void keyRepeated(int keyCode){ key(keyCode); }
    protected void keyReleased(int keyCode) { kHold=0; }
    protected void keyPressed(int keyCode) { kHold=0; key(keyCode);  }
    
    protected void pointerPressed(int x, int y) { 
	if (scrollbar.pointerPressed(x, y, this)) {
            stickyWindow=false;
            return;
        } 
	int i=0;
	while (i<32) {
	    if (y<itemBorder[i]) break;
	    i++;
	}
	if (i==0 || i==32) return;
	//System.out.println(i);
	if (cursor>=0) {
            moveCursorTo(getElementIndexAt(win_top)+i-1, true);
            setRotator();
        }
	
	long clickTime=System.currentTimeMillis();
	if (cursor==lastClickItem)
	    if (lastClickY-y<5 && y-lastClickY<5) 
		if (clickTime-lastClickTime<500){
		    y=0;    // запрет "тройного клика"
		    eventOk();
		}
	lastClickTime=clickTime;
	lastClickY=y;
	lastClickItem=cursor;
        
        // сделаем элемент максимально видимым
        int il=itemLayoutY[cursor+1]-winHeight;
        if (il>win_top) win_top=il;
        il=itemLayoutY[cursor];
        if (il<win_top) win_top=il;
        
	repaint();
    }
    protected void pointerDragged(int x, int y) { 
        if (scrollbar.pointerDragged(x, y, this)) stickyWindow=false; 
    }
    protected void pointerReleased(int x, int y) { scrollbar.pointerReleased(x, y, this); }
    
    /**
     * обработка кодов кнопок
     * @param keyCode код нажатой кнопки
     */
    private void key(int keyCode) {
        switch (keyCode) {
            case 0: break;
            case MOTOE680_VOL_UP:
            case KEY_NUM1:  { moveCursorHome();    break; }
            case KEY_NUM7:  { moveCursorEnd();     break; }
            case '5':{ eventOk(); break; }
            case MOTOROLA_FLIP: break;
            default:
                try {
                    switch (getGameAction(keyCode)){
                        case UP:    { keyUp(); break; }
                        case DOWN:  { keyDwn(); break; }
                        case LEFT:  { keyLeft(); break; }
                        case RIGHT: { keyRight(); break; }
                        case FIRE:  { eventOk(); break; }
                        default:
                            if (keyCode==greenKeyCode) { keyGreen(); break; }
			     if (keyCode==keyVolDown) { moveCursorEnd(); break; }
                            userKeyPressed(keyCode);
                    }
                } catch (Exception e) {/* IllegalArgumentException @ getGameAction */}
        }

        
        repaint();
    }
    
    /**
     * событие "Нажатие кнопки UP"
     * в классе VirtualList функция перемещает курсор на одну позицию вверх.
     * возможно переопределить (override) функцию для реализации необходимых действий
     */
    public void keyUp() {
	 
        if (cursor==0) {
            if (wrapping)  moveCursorEnd(); else itemPageUp();
            setRotator();
            return;
        }
        /*
        if (itemLayoutY[cursor]<win_top) {
            //верхняя граница элемента ещё не на экране
            win_top-=winHeight;
            if (win_top<0) win_top=0;
        } else {
            cursor--;
            if (getItemRef(cursor).getVHeight()>winHeight) {
                // если элемент не может поместиться на экране, вырвниваем по bottom
                win_top=itemLayoutY[cursor+1]-winHeight;
            } else if (win_top>itemLayoutY[cursor]) {
                win_top=itemLayoutY[cursor];
            }
        }
         */
        if (itemPageUp()) return;
        //stickyWindow=true;
        cursor--;
        fitCursorByBottom();
        setRotator();
    }
    
    /**
     * событие "Нажатие кнопки DOWN"
     * в классе VirtualList функция перемещает курсор на одну позицию вверх.
     * возможно переопределить (override) функцию для реализации необходимых действий
     */
    
    public void keyDwn() { 
	if (cursor==getItemCount()-1) 
        { 
            if (wrapping) moveCursorHome(); else itemPageDown();
            setRotator();
            return; 
        }
        /*if (itemLayoutY[cursor+1]>win_top+winHeight) {
            // нижняя граница текущего элемента ещё не на экране
            win_top+=winHeight; // пока - pagedown
        } else {
            cursor++;
            if (getItemRef(cursor).getVHeight()>winHeight) {
                // если элемент не может поместиться на экране, вырвниваем по top
                win_top=itemLayoutY[cursor];
            } else if (win_top+winHeight<itemLayoutY[cursor+1]) {
                win_top=itemLayoutY[cursor+1]-winHeight;
            }
        }*/
        if (itemPageDown()) return;
        stickyWindow=true; 
        cursor++;
        setRotator();
    }
    
    private boolean itemPageDown() {
        try {
            stickyWindow=false;
            // объект помещается полностью на экране?
            if (((VirtualElement)getFocusedObject()).getVHeight()<=winHeight) {
                stickyWindow=true;
                return false;
            }
            
            // объект на экране есть? (не смещён ли экран стилусом)
            if (!cursorInWindow()) return false;
            
            int remainder=itemLayoutY[cursor+1]-win_top;
            // хвост сообщения уже на экране?
            if (remainder<=winHeight) return false;
            // хвост сообщения на следующем экране?
            if (remainder<=2*winHeight) {
                win_top=remainder-winHeight+win_top+8;
                return true;
            }
            win_top+=winHeight-STRING_SZ;
            return true;
        } catch (Exception e) {}
        return false;
    }
    
    private boolean itemPageUp() {
        try {
            stickyWindow=false;
            // объект помещается полностью на экране?
            if (((VirtualElement)getFocusedObject()).getVHeight()<=winHeight) {
                //stickyWindow=true;
                return false;
            }
            
            // объект на экране есть? (не смещён ли экран стилусом)
            
            if (!cursorInWindow()) { return false; }
            
            int remainder=win_top-itemLayoutY[cursor];
            // голова сообщения уже на экране?
            if (remainder<=0) return false;
            // хвост сообщения на следующем экране?
            if (remainder<=winHeight) {
                win_top=itemLayoutY[cursor];
                return true;
            }
            win_top-=winHeight-STRING_SZ;
            return true;
        } catch (Exception e) {}
        return false;
    }
    /**
     * событие "Нажатие кнопки LEFT"
     * в классе VirtualList функция перемещает курсор на одну страницу вверх.
     * возможно переопределить (override) функцию для реализации необходимых действий
     */
    public void keyLeft() {
        try {
            stickyWindow=false;
            win_top-=winHeight;
            if (win_top<0) {
                win_top=0;
                cursor=0;
            }
            if (!cursorInWindow()) {
                cursor=getElementIndexAt(itemLayoutY[cursor]-winHeight);
                if (((VirtualElement)getFocusedObject()).getVHeight()<=winHeight) fitCursorByTop();
            }
            setRotator();
        } catch (Exception e) {};
    }

    /**
     * событие "Нажатие кнопки RIGHT"
     * в классе VirtualList функция перемещает курсор на одну страницу вниз.
     * возможно переопределить (override) функцию для реализации необходимых действий
     */
    public void keyRight() { 
        try {
            stickyWindow=false;
            win_top+=winHeight;
            int endTop=listHeight-winHeight;
            if (endTop<win_top) {
                win_top= (listHeight<winHeight)? 0 : endTop;
                cursor=getItemCount()-1;
            } else
                if (!cursorInWindow()) {
                    cursor=getElementIndexAt(itemLayoutY[cursor]+winHeight);
                    if (((VirtualElement)getFocusedObject()).getVHeight()<=winHeight) fitCursorByTop();
                }
            setRotator();
        } catch (Exception e) {};
    }
    
    public boolean cursorInWindow(){
        try {
            int y1=itemLayoutY[cursor]-win_top;
            int y2=itemLayoutY[cursor+1]-win_top;
            if (y1>=winHeight) return false;
            if (y2>=0) return true;
        } catch (Exception e) { }
        return false;
    }
    
    /**
     * событие "Нажатие ЗЕЛЁНОЙ КНОПКИ"
     * в классе VirtualList функция выполняет вызов eventOk().
     * возможно переопределить (override) функцию для реализации необходимых действий
     */
    protected void keyGreen() { eventOk(); }
    
    /** перезапуск ротации скроллера длинных строк */
    protected  void setRotator(){
        focusedItem(cursor);
        rotator.destroyTask();
        if (getItemCount()<1) return;
        if (cursor>=0) {
            int itemWidth=getItemRef(cursor).getVWidth();
            if (itemWidth>=width-scrollbar.getScrollWidth() ) itemWidth-=width/2; else itemWidth=0;
            rotator=new TimerTaskRotate( itemWidth );
        }
    }
    // cursor rotator
    
    private class TimerTaskRotate extends TimerTask{
        private Timer t;
        private int Max;
        private int balloon;
        
        public TimerTaskRotate(int max){
            offset=0;
            balloon=6;
            //if (max<1) return;
            Max=max;
            t=new Timer();
            t.schedule(this, 2000, 300);
        }
        public void run() {
            // прокрутка только раз
            //stickyWindow=false;
            
            if (Max==-1 && balloon==-1) cancel();
            if (offset>=Max) {
                Max=-1;
                offset=0;
            } else offset+=20;
            
            if (showBalloon=balloon>=0) balloon--;
            redraw();
            //System.out.println("Offset "+offset);
        }
        public void destroyTask(){
            offset=0;
            if (t!=null){
                this.cancel();
                t.cancel();
                t=null;
            }
        }
    }
    private TimerTaskRotate rotator;

    
    /**
     * рисование прямоугольного курсора
     * @param g графический контекст рисования
     * @param width ширина курсора
     * @param height высота курсора
     */
    protected void drawCursor (Graphics g, int width, int height){
        //g.setColor(VL_CURSOR_SHADE);   g.drawRoundRect(x+2, y+2, width-1, height-1, 3,3);
        g.setColor(Colors.CURSOR_BGND);    g.fillRect(1, 1, width-1, height-1);
        g.setColor(Colors.CURSOR_OUTLINE); g.drawRect(0, 0, width-1, height-1);
        /*
        g.drawLine(1,0,width-2,0);
        g.drawLine(0,1,0,height-2);
        g.drawLine(0,width-1,0,height-2);
        g.drawLine(1,height-1,width-2,height-1);
         */
    }

    public void setParentView(Displayable parentView){
        this.parentView=parentView;
    }
    
    /**
     * отсоединение от менеджера дисплея текущего виртуального списка, 
     * присоединение к менеджеру предыдущего Displayable
     */
    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView);
    }

    public int getListWidth() {
        return width-scrollbar.getScrollWidth();
    }

}
/*
 * YesNoAlert.java
 *
 * Created on 8 Май 2005 г., 23:19
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui;
import javax.microedition.lcdui.*;

/**
 *
 * @author Evg_S
 */
public abstract class YesNoAlert extends Form implements CommandListener{
    
    private Display display;
    private Displayable parentView;

    
    Command cmdYes=new Command("Yes", Command.OK, 1);
    Command cmdNo=new Command("No", Command.BACK, 99);
    /** Creates a new instance of YesNoAlert */
    public YesNoAlert(Display display, Displayable parentView, String title, String alertText) {
        super(title);
        addCommand(cmdYes);
        addCommand(cmdNo);
        setCommandListener(this);

        append("\n");
        append(alertText);
        
        this.display=display;
        this.parentView=parentView;//display.getCurrent();
        display.setCurrent(this);
        
    }
    public void commandAction(Command c, Displayable d ){
        destroyView();
        if (c==cmdYes) {
            yes();
        } else no();
    }
    abstract public void yes();
    public void no(){};
    
    public void destroyView(){
        if (display!=null)   display.setCurrent(parentView);
    }

}
/*
 * Baloon.java
 *
 * Created on 6 Февраль 2006 г., 23:09
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui.controls;

import javax.microedition.lcdui.Font;
import javax.microedition.lcdui.Graphics;
import ui.Colors;
import ui.FontCache;

/**
 *
 * @author Evg_S
 */
public class Balloon {
    
    public static int getHeight(){
        Font f=FontCache.getBalloonFont();
        return f.getHeight()+3;
    }
    
    public static void draw(Graphics g, String text) {
        Font f=FontCache.getBalloonFont();
        g.setFont(f);
        int height=getHeight();
        int width=f.stringWidth(text)+6;
        
        int y=height-g.getTranslateY();
        if (y<0) y=0;
        y-=height-1;
        g.translate(0, y);
        
        g.setColor(Colors.BALLOON_INK);
        g.fillRect(2, 0, width, height);

        g.setColor(Colors.BALLOON_BGND);
        g.fillRect(3, 1, width-2, height-2);
       
        g.setColor(Colors.BALLOON_INK);
        g.drawString(text, 5, 2, Graphics.TOP | Graphics.LEFT);
    }
}
/*
 * SignNumberField.java
 *
 * Created on 10 Декабрь 2005 г., 1:29
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui.controls;

import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.Item;
//#if !MIDP1
import javax.microedition.lcdui.ItemCommandListener;
//#endif
import javax.microedition.lcdui.TextField;
import locale.SR;
import ui.ConstMIDP;

/**
 *
 * @author EvgS
 */
public class NumberField extends TextField 
//#if !MIDP1
    implements ItemCommandListener 
//#endif
{
    private int initValue;
    private int minValue;
    private int maxValue;
    private Command sign;
    private Command clear;
    /** Creates a new instance of SignNumberField */
    public NumberField(String label, int initValue, int minValue, int maxValue) {
	super(label, String.valueOf(initValue), 6, 
	    (minValue<0)?ConstMIDP.TEXTFIELD_DECIMAL:NUMERIC );
	this.initValue=initValue;
	this.minValue=minValue;
	this.maxValue=maxValue;
	sign=new Command(SR.MS_CHSIGN, Command.ITEM, 1);
	clear=new Command(SR.MS_CLEAR, Command.ITEM, 2);
//#if !MIDP1
	if (minValue<0) addCommand(sign);
        addCommand(clear);
	setItemCommandListener(this);
//#endif
    }
    
    public int getValue() {
	try {
	    int value=Integer.parseInt(getString());
	    if (value>maxValue) return maxValue;
	    if (value<minValue) return maxValue;
	    return value;
	} catch (NumberFormatException e) { /* returning initValue */ }
	return initValue;
    }

//#if !MIDP1
    public void commandAction(Command command, Item item) {
	StringBuffer body=new StringBuffer( getString() );
	if (command==clear) body.setLength(0);
        if (command==sign) {
            if ( body.charAt(0)=='-' ) 
                body.deleteCharAt(0);
            else
                body.insert(0,'-');
            }
	setString(body.toString());
    }
//#endif
}
/*
 * ScrollBar.java
 *
 * Created on 19 Ноябрь 2005 г., 21:26
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package ui.controls;

import javax.microedition.lcdui.Graphics;
import ui.Colors;
import ui.VirtualList;

/**
 *
 * @author EvgS
 */
public class ScrollBar {
    
    private static final int WIDTH_SCROLL_1      =4;
    private static final int WIDTH_SCROLL_2      =10;
    
    private int yTranslate;
    
    private int size;
    private int windowSize;
    private int position;
    
    private int scrollerX;
    
    private int drawHeight;
    
    private int point_y;    // точка, за которую "держится" указатель
    
    private int scrollerSize;
    private int scrollerPos;
    
    private boolean hasPointerEvents;
    
    private int minimumHeight=3;
    private int scrollWidth=WIDTH_SCROLL_1;
    
    /** Creates a new instance of ScrollBar */
    public ScrollBar() {
        point_y=-1;
    }

    public void setWindowSize(int windowSize) {
        this.windowSize = windowSize;
    }

    public void setSize(int size) {
        this.size = size;
    }

    public int getPostion() {
        return position;
    }

    public void setPostion(int postion) {
        this.position = postion;
    }

    public void setHasPointerEvents(boolean hasPointerEvents) {
        this.hasPointerEvents = hasPointerEvents;
	scrollWidth=(hasPointerEvents)? WIDTH_SCROLL_2: WIDTH_SCROLL_1;
    }

    public int getScrollWidth() {
        return scrollWidth;
    }

    public boolean pointerPressed(int x, int y, VirtualList v) {
	if (size==0) return false;
	if (x<scrollerX) return false; // not in area
	y-=yTranslate;
	if (y<scrollerPos) { 
            // page up
            int pos=position-windowSize;
            if (pos<0) pos=0;
            v.win_top=pos;
            v.repaint(); 
            return true; 
        } 
	if (y>scrollerPos+scrollerSize) { 
            int pos=position+windowSize;
            int listEnd=size-windowSize;
            v.win_top=(pos<listEnd)?pos:listEnd;
            v.repaint(); 
            return true; 
        } // page down
	point_y=y-scrollerPos;
	return true;
    }
    public boolean pointerDragged(int x, int y, VirtualList v) {
	y-=yTranslate;
	if (point_y<0) return false;
	int new_top=y-point_y;
	int new_pos=(new_top*size)/drawHeight;
	if ((position-new_pos)==0) return true;
	if (new_pos<0) new_pos=0;
	if (new_pos+windowSize>size) new_pos=size-windowSize;
	v.win_top=new_pos; v.repaint();
	return true;
    }
    public void pointerReleased(int x, int y, VirtualList v) { point_y=-1; }
    
    public void draw(Graphics g) {
	
	yTranslate=g.getTranslateY();
	
	drawHeight=g.getClipHeight();
	int drawWidth=g.getClipWidth();
	
	scrollerX=drawWidth-scrollWidth;

	g.translate(scrollerX, 0);

        g.setColor(Colors.SCROLL_BGND);
	g.fillRect(1, 1, scrollWidth-2, drawHeight-2);
	
        g.setColor(Colors.LIST_BGND);
        g.drawRect(0,0,scrollWidth-1,drawHeight-1);
            
	drawHeight-=minimumHeight;
        
	scrollerSize=(drawHeight*windowSize)/size+minimumHeight;
	
	scrollerPos=(drawHeight*position)/size;
        g.setColor(Colors.SCROLL_BAR);
        g.fillRect(1, scrollerPos, scrollWidth-2, scrollerSize);
        
        g.setColor(Colors.SCROLL_BRD);
        g.drawRect(0, scrollerPos, scrollWidth-1, scrollerSize);
	
	//scrollerPos+=g.getTranslateY();
    }
}
/*
 * ArrayLoader.java
 *
 * Created on 24 Сентябрь 2006 г., 1:47
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package util;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.InputStream;
import java.util.Enumeration;

/*
import javax.microedition.io.Connector;
import javax.microedition.io.file.FileConnection;
import javax.microedition.io.file.FileSystemRegistry;
*/

/**
 *
 * @author evgs
 */
public class ArrayLoader {
    
    /** Creates a new instance of ArrayLoader */
    public ArrayLoader() {
    }
    public int[] readIntArray(String name) {
        try {
            InputStream in = this.getClass().getResourceAsStream(name);
            DataInputStream is=new DataInputStream(in);
            int len=is.readInt();
            int[] arrayInt=new int[len];
            
            for (int i=0; i<len;i++) {
                arrayInt[i]=is.readInt();
            }
            return arrayInt;
        } catch (Exception ex) { ex.printStackTrace(); }
        
        return null;
    }
    
    public short[] readShortArray(String name) {
        try {
            InputStream in = this.getClass().getResourceAsStream(name);
            DataInputStream is=new DataInputStream(in);
            int len=is.readInt();
            short[] arrayShort=new short[len];
            
            for (int i=0; i<len;i++) {
                arrayShort[i]=is.readShort();
            }
            return arrayShort;
        } catch (Exception ex) { ex.printStackTrace(); }
        
        return null;
    }
    public byte[] readByteArray(String name) {
        try {
            InputStream in = this.getClass().getResourceAsStream(name);
            DataInputStream is=new DataInputStream(in);
            int len=is.readInt();
            byte[] arrayByte=new byte[len];

            is.read(arrayByte, 0, len);
            return arrayByte;
        } catch (Exception ex) { ex.printStackTrace(); }
        
        return null;
    }

/*
    public static void writeIntArray(String name, int[] intArray) {
        try {
            for (Enumeration e=FileSystemRegistry.listRoots(); e.hasMoreElements(); ){
                String root = (String) e.nextElement();
                System.out.println(root);
            }
            FileConnection fc=(FileConnection)Connector.open("file:///root1/" + name);
            if (fc.exists()) return;
            fc.create();
            DataOutputStream os=fc.openDataOutputStream();
            os.writeInt(intArray.length);
            
            for (int i=0; i<intArray.length; i++) os.writeInt(intArray[i]);
            
            os.close();
            fc.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        

    }

    public static void writeShortArray(String name, short[] shortArray) {
        try {
            for (Enumeration e=FileSystemRegistry.listRoots(); e.hasMoreElements(); ){
                String root = (String) e.nextElement();
                System.out.println(root);
            }
            FileConnection fc=(FileConnection)Connector.open("file:///root1/" + name);
            if (fc.exists()) return;
            fc.create();
            DataOutputStream os=fc.openDataOutputStream();
            os.writeInt(shortArray.length);
            
            for (int i=0; i<shortArray.length; i++) os.writeShort(shortArray[i]);
            
            os.close();
            fc.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    
    public static void writeByteArray(String name, byte[] byteArray) {
        try {
            FileConnection fc=(FileConnection)Connector.open("file:///root1/" + name);
            if (fc.exists()) return;
            fc.create();
            DataOutputStream os=fc.openDataOutputStream();
            os.writeInt(byteArray.length);
            
            os.write(byteArray, 0, byteArray.length);
           
            os.close();
            fc.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
*/
}
/*
 * strconv.java
 *
 * Created on 12 Январь 2005 г., 1:25
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

/**
 *
 * @author Eugene Stahov
 */
package util;
import java.lang.*;

public class strconv {
    
    /** Creates a new instance of strconv */
    private strconv() {
    }
    
    public static final String convCp1251ToUnicode(final String s){
        if (s==null) return null;
        StringBuffer b=new StringBuffer(s.length());
        for (int i=0;i<s.length();i++){
            char ch=s.charAt(i);
            if (ch>0xbf) ch+=0x410-0xc0;
            if (ch==0xa8) ch=0x401;
            if (ch==0xb8) ch=0x451;
            b.append(ch);
            //setCharAt(i, ch);
        }
        return b.toString();
    }
    
    public static final String convUnicodeToCp1251(final String s){
        if (s==null) return null;
        StringBuffer b=new StringBuffer(s.length());
        for (int i=0;i<s.length();i++){
            char ch=s.charAt(i);
            if (ch==0x401) ch=0xa8; //Ё
            if (ch==0x451) ch=0xb8; //ё
            if (ch>0x409) ch+=0xc0-0x410;
            b.append(ch);
            //setCharAt(i, ch);
        }
        return b.toString();
    }
    
    public final static String toBase64( String source) {
        String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        
        int len=source.length();
        char[] out = new char[((len+2)/3)*4];
        for (int i=0, index=0; i<len; i+=3, index +=4) {
            boolean trip=false;
            boolean quad=false;
            
            int val = (0xFF & source.charAt(i))<<8;
            if ((i+1) < len) {
                val |= (0xFF & source.charAt(i+1));
                trip = true;
            }
            val <<= 8;
            if ((i+2) < len) {
                val |= (0xFF & source.charAt(i+2));
                quad = true;
            }
            out[index+3] = alphabet.charAt((quad? (val & 0x3F): 64));
            val >>= 6;
            out[index+2] = alphabet.charAt((trip? (val & 0x3F): 64));
            val >>= 6;
            out[index+1] = alphabet.charAt(val & 0x3F);
            val >>= 6;
            out[index+0] = alphabet.charAt(val & 0x3F);
        }
        return new String(out);
    }
    
    public final static String toBase64( byte source[]) {
        String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        
        int len=source.length;
        char[] out = new char[((len+2)/3)*4];
        for (int i=0, index=0; i<len; i+=3, index +=4) {
            boolean trip=false;
            boolean quad=false;
            
            int val = (0xFF & source[i])<<8;
            if ((i+1) < len) {
                val |= (0xFF & source[i+1]);
                trip = true;
            }
            val <<= 8;
            if ((i+2) < len) {
                val |= (0xFF & source[i+2]);
                quad = true;
            }
            out[index+3] = alphabet.charAt((quad? (val & 0x3F): 64));
            val >>= 6;
            out[index+2] = alphabet.charAt((trip? (val & 0x3F): 64));
            val >>= 6;
            out[index+1] = alphabet.charAt(val & 0x3F);
            val >>= 6;
            out[index+0] = alphabet.charAt(val & 0x3F);
        }
        return new String(out);
    }
    
    public static StringBuffer toUTFSb(StringBuffer str) {
        int srcLen = str.length();
        StringBuffer outbuf=new StringBuffer( srcLen );
        for(int i=0; i < srcLen; i++) {
            int c = (int)str.charAt(i);
            //TODO: ескэйпить коды <0x20
            if ((c >= 1) && (c <= 0x7f)) {
                outbuf.append( (char) c);
                
            }
            if (((c >= 0x80) && (c <= 0x7ff)) || (c==0)) {
                outbuf.append((char)(0xc0 | (0x1f & (c >> 6))));
                outbuf.append((char)(0x80 | (0x3f & c)));
            }
            if ((c >= 0x800) && (c <= 0xffff)) {
                outbuf.append(((char)(0xe0 | (0x0f & (c >> 12)))));
                outbuf.append((char)(0x80 | (0x3f & (c >>  6))));
                outbuf.append(((char)(0x80 | (0x3f & c))));
            }
        }
        return outbuf;
    }
    
    
    public static String wCharToUTF(String src) {
        return toUTFSb(new StringBuffer(src)).toString();
    }
}
/*
 * StringLoader.java
 *
 * Created on 25 Ноябрь 2005 г., 1:25
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */
package util;

import java.io.IOException;
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Vector;

public class StringLoader {
    
    int afterEol;
    
    public Vector[] stringLoader(String resource, int columns) {
	StringBuffer buf = new StringBuffer();
	Vector table[] = new Vector[columns];
	for (int i = 0; i<columns; i++) {
	    table[i]=new Vector();
	}
	
	afterEol=0;
	InputStream in = this.getClass().getResourceAsStream(resource);
	try {
	    while (true) {
		String line=readLine(in);
		if (line==null)  break;
		
		if (line.startsWith("//")) continue; // skip all remarks

		int indexFrom=0;
		
		for (int i = 0; i<columns; i++) {
		    String cell=null;
		    try {
			int indexTo=line.indexOf(0x09, indexFrom);
			
			if (indexTo<0) indexTo=line.length();
			if (indexFrom<indexTo) cell=line.substring(indexFrom, indexTo);
			indexFrom=indexTo+1;
		    } catch (Exception e) { e.printStackTrace(); }
		    
		    table[i].addElement( cell );
		}
	    }
	    in.close();
	} catch (Exception e)	{ e.printStackTrace();}
	return table;
    }
    
    public Hashtable hashtableLoader(String resource) {
	Hashtable hash = new Hashtable();
	
	afterEol=0;
	InputStream in = this.getClass().getResourceAsStream(resource);
	try {
	    while (true) {
		String line=readLine(in);
                String key, value;
		if (line==null)  break;
		
		if (line.startsWith("//")) continue; // skip all remarks

                String cell=null;
                try {
                    int indexTab=line.indexOf(0x09);
                    
                    if (indexTab<=0) continue; // process next line
                    
                    key=line.substring(0, indexTab);
                    value=line.substring(indexTab+1, line.length() );
                    hash.put(key, value);
                } catch (Exception e) { e.printStackTrace(); }
	    }
	    in.close();
	} catch (Exception e)	{ /* Empty file or not found */}
	return hash;
    }
    
    String readLine(InputStream inputstream) throws IOException {
	StringBuffer buf=new StringBuffer();
	if (afterEol>0) {
	    buf.append(afterEol);
	    afterEol=0;
	}
	
	boolean eol=false;
	while (true) {
	    int c = getUtfChar(inputstream);
	    if (c<0) { 
		eol=true;
		if (buf.length()==0) return null;
		break;
	    }
	    if (c==0x0d || c==0x0a) {
		eol=true;
		//inputstream.mark(2);
		if (c==0x0a) break;
	    }
	    else {
		if (eol) {
		    afterEol=c;
		    //inputstream.reset();
		    break;
		}
		buf.append((char) c);
	    }
	}
	return buf.toString();
    }

    int getUtfChar(InputStream is) throws IOException {
        int chr = is.read();
        if( chr == 0xff ) return -1; // end of stream

	if (chr<0x80) return chr;
	if (chr<0xc0) throw new IOException("Bad UTF-8 Encoding encountered");
        int chr2= is.read() &0xff;
        if (chr2==0xff) return -1;
        if (chr2<0x80) throw new IOException("Bad UTF-8 Encoding encountered");
	
	if (chr<0xe0) {
	    // cx, dx 
	    return ((chr & 0x1f)<<6) | (chr2 &0x3f);
	}
	if (chr<0xf0) {
	    // cx, dx 
	    int chr3= is.read() &0xff;
	    if (chr3==0xff) return -1;
	    if (chr3<0x80) throw new IOException("Bad UTF-8 Encoding encountered");
	    else return ((chr & 0x0f)<<12) | ((chr2 &0x3f) <<6) | (chr3 &0x3f);
	}
	
	//System.out.print((char)j);
	return -1;            
    }
}
/*
 * vCard.java
 *
 * Created on 24 Сентябрь 2005 г., 1:24
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package vcard;
import Client.StaticData;
import com.alsutton.jabber.JabberDataBlock;
import com.alsutton.jabber.datablocks.Iq;
import java.util.*;
import java.io.*;
import javax.microedition.lcdui.Image;
import util.StringLoader;
import util.strconv;

/**
 *
 * @author EvgS
 */
public class VCard {

    public final static int NICK_INDEX=1;
    
    public static Vector vCardFields;
    public static Vector vCardFields2;
    public static Vector vCardLabels;
    
    private Vector vCardData;
    private String jid;
    
    byte photo[];
    
    /** Creates a new instance of vCard */
    public VCard() {
        if (vCardFields==null) fieldsLoader();
    }
    
    public VCard(JabberDataBlock data) {
        this();
        jid=data.getAttribute("from");
        int itemsCount=getCount();
        vCardData=new Vector(itemsCount);
        vCardData.setSize(itemsCount);
        
        if (data==null) return; //"No vCard available";
        JabberDataBlock vcard=data.findNamespace("vcard-temp");
        if (vcard==null) return;
        
        for (int i=0; i<itemsCount; i++){
            try {
                String f1=(String)VCard.vCardFields.elementAt(i);
                String f2=(String)VCard.vCardFields2.elementAt(i);
                
                JabberDataBlock d2=
                        (f2==null) ? vcard : vcard.getChildBlock(f2);
                
                String field=d2.getChildBlockText(f1);
                
                if (field.length()>0) setVCardData(i, field);
            } catch (Exception e) {/**/}
        }
        
       try {
           JabberDataBlock photoXML=vcard.getChildBlock("PHOTO").getChildBlock("BINVAL");
           photo=(byte[])photoXML.getChildBlocks().lastElement();
       } catch (Exception e) {};
    }

    public JabberDataBlock constructVCard(){
        JabberDataBlock vcardIq=new Iq(null, Iq.TYPE_SET, "vcard-set");
        JabberDataBlock vcardTemp=vcardIq.addChild("vCard", null);
        vcardTemp.setNameSpace("vcard-temp");
        
        int itemsCount=getCount();
        
        for (int i=0; i<itemsCount; i++){
            String field=getVCardData(i);
            if (field==null) continue;
            
            String f1=(String)VCard.vCardFields.elementAt(i);
            String f2=(String)VCard.vCardFields2.elementAt(i);
            
            JabberDataBlock subLevel=vcardTemp;
            if (f2!=null) {
                subLevel=vcardTemp.getChildBlock(f2);
                if (subLevel==null) subLevel=vcardTemp.addChild(f2, null);
            }
            subLevel.addChild(f1, field);
            
        }
        if (photo!=null) {
            vcardTemp.addChild("PHOTO", null).addChild("BINVAL", strconv.toBase64(photo));
        }
        //System.out.println(vcard.toString());
        return vcardIq;
    }
    
    public byte[] getPhoto() { return photo; }
    public void setPhoto(byte[] photo) {
        this.photo=photo;
    }
    
    public String getNickName() { return getVCardData(NICK_INDEX);}
    
    public static JabberDataBlock getVCardReq(String to, String id ) 
    {
        JabberDataBlock req=new Iq(to, Iq.TYPE_GET, id);
        req.addChild("vCard", null).setNameSpace( "vcard-temp" );

        return req;
    }
    
    public static void request(String jid) {
        StaticData.getInstance().roster.setQuerySign(true); 
        StaticData.getInstance().roster.theStream.send(getVCardReq(jid, "getvc"));
    }
    
    private void fieldsLoader(){
	Vector table[]=new StringLoader().stringLoader("/vcard.txt", 3);

	vCardFields=table[1];
        vCardFields2=table[0];
        vCardLabels=table[2];
        
    }
    public String getVCardData(int index) {
        return (String) vCardData.elementAt(index);
    }

    public void setVCardData(int index, String data) {
        vCardData.setElementAt(data, index);
    }
    
    public int getCount(){ return vCardFields.size(); }

    public String getJid() { return jid; }


}
/*
 * vCardForm.java
 *
 * Created on 3 Jrnz,hm 2005 г., 0:37
 *
 * Copyright (c) 2005-2006, Eugene Stahov (evgs), http://bombus.jrudevels.org
 * All rights reserved.
 */

package vcard;
import Client.StaticData;
//#if (FILE_IO)
import io.file.FileIO;
import io.file.browse.Browser;
import io.file.browse.BrowserListener;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
//#endif
import java.util.*;
import javax.microedition.lcdui.*;
import locale.SR;

/**
 *
 * @author EvgS
 */
public class vCardForm 
        implements CommandListener, Runnable
//#if (FILE_IO)
        , BrowserListener
//#endif
{
    
    private Display display;
    private Displayable parentView;
    
    protected Command cmdCancel=new Command(SR.MS_CANCEL, Command.BACK, 99);
    protected Command cmdPublish=new Command(SR.MS_PUBLISH, Command.OK /*Command.SCREEN*/, 1);
    protected Command cmdRefresh=new Command(SR.MS_REFRESH, Command.SCREEN, 2);
    protected Command cmdPhoto=new Command("Load Photo", Command.SCREEN,3);
    protected Command cmdDelPhoto=new Command("Clear Photo", Command.SCREEN,4);
    
    private Form f;
    private Vector items=new Vector();
    private VCard vcard;
    
    private byte[] photo;
    private int photoIndex;
    
    /** Creates a new instance of vCardForm */
    public vCardForm(Display display, VCard vcard, boolean editable) {
        this.display=display;
        parentView=display.getCurrent();
        
        this.vcard=vcard;
        
        f=new Form(SR.MS_VCARD);
        f.append(vcard.getJid());
        
        for (int index=0; index<vcard.getCount(); index++) {
            String data=vcard.getVCardData(index);
            String name=(String)VCard.vCardLabels.elementAt(index);
            Item item=null;
            if (editable) {
                item=new TextField(name, data, 200, TextField.ANY);
                items.addElement(item);
            } else if (data!=null) {
                item=new StringItem (name, data);
            }
            if (item!=null) {
                f.append(item);
//#if !(MIDP1)
                f.append(new Spacer(256, 3));
//#else
//--                f.append("\n");
//#endif
            }
        }
        
        
        photoIndex=f.append("[no photo available]");
        
        f.append("\n\n[end of vCard]");
        
        photo=vcard.getPhoto();
        setPhoto();
        
        f.addCommand(cmdCancel);
        f.addCommand(cmdRefresh);
        if (editable) {
            f.addCommand(cmdPublish);
//#if (FILE_IO)
            f.addCommand(cmdPhoto);
//#endif
            f.addCommand(cmdDelPhoto);
        }
        f.setCommandListener(this);
        display.setCurrent(f);
    }
    
    public void commandAction(Command c, Displayable d) {
        if (c==cmdCancel) destroyView();
        if (c==cmdRefresh) {
            VCard.request(vcard.getJid());
            destroyView();
        }
        
//#if (FILE_IO)
        if (c==cmdPhoto) {
            new Browser(display, this, false);
        }
//#endif
        if (c==cmdDelPhoto) {photo=null; setPhoto();}
        
        if (c!=cmdPublish) return;
        
        vcard.setPhoto(photo);
        
        for (int index=0; index<vcard.getCount(); index++) {
            String field=((TextField)items.elementAt(index)).getString();
            if (field.length()==0) field=null;
            vcard.setVCardData(index, field);
        }
        //System.out.println(vcard.constructVCard().toString());
        new Thread(this).start();
        destroyView();
    }
    
    private void destroyView() {
        display.setCurrent(parentView);
    }

    public void run() {
        StaticData.getInstance().roster.theStream.send(vcard.constructVCard());
        System.out.println("VCard sent");
    }

//#if (FILE_IO)
    public void BrowserFilePathNotify(String pathSelected) {
        try {
            FileIO f=FileIO.createConnection(pathSelected);
            InputStream is=f.openInputStream();
            byte[] b=new byte[(int)f.fileSize()];
            is.read(b);
            is.close();
            f.close();
            photo=b;
            setPhoto();
        } catch (Exception e) {e.printStackTrace();}
    }
//#endif

    private void setPhoto() {
        if (photo==null) return;
        String size=String.valueOf(photo.length)+" bytes";
        Item photoItem;
//#if !(MIDP1)
        try {
            Image photoImg=Image.createImage(photo, 0, photo.length);
            photoItem=new ImageItem(size, photoImg, 0, null);
        } catch (Exception e) { photoItem=new StringItem(size, "[Unsupported format]"); }
        f.set(photoIndex, photoItem);
//#endif
    }
}
